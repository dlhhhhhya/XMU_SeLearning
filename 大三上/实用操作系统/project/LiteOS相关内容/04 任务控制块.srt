1
00:00:01,266 --> 00:00:02,799
各位同学大家好

2
00:00:03,000 --> 00:00:04,733
下面我们开始学习

3
00:00:04,733 --> 00:00:06,899
鸿蒙赖头s任务管理

4
00:00:09,133 --> 00:00:11,266
本章主要分为三项内容

5
00:00:11,266 --> 00:00:12,899
首先是任务控制框

6
00:00:13,300 --> 00:00:15,300
然后介绍任务管理

7
00:00:15,533 --> 00:00:17,899
第三介绍任务状态切换

8
00:00:19,600 --> 00:00:21,600
在鸿蒙系统中所谓任务

9
00:00:22,000 --> 00:00:24,566
那么就是我们在传统操作系统中

10
00:00:24,566 --> 00:00:25,133
对应的现

11
00:00:25,133 --> 00:00:25,966
场的概念

12
00:00:26,466 --> 00:00:27,266
那么

13
00:00:28,200 --> 00:00:29,733
与进程类似啊

14
00:00:29,733 --> 00:00:32,499
进程操作系统对进程的管理

15
00:00:32,500 --> 00:00:35,866
主要是通过PCB process Ctrl blog来实现的

16
00:00:36,100 --> 00:00:38,466
那么Notos对

17
00:00:38,900 --> 00:00:40,666
线程也就是任务的管理

18
00:00:40,666 --> 00:00:43,099
主要是通过任务控制块来完成的

19
00:00:43,566 --> 00:00:46,199
那么首先我们来介绍一下任务控制块

20
00:00:46,566 --> 00:00:48,399
那么任务控制块

21
00:00:48,500 --> 00:00:50,400
在缝缝系统叫做let

22
00:00:51,000 --> 00:00:53,133
啊叫做lost task CB啊

23
00:00:53,133 --> 00:00:56,933
lost task CB那我们先简单的看一下啊

24
00:00:57,200 --> 00:00:57,933
在

25
00:00:57,933 --> 00:01:00,799
任务控制块儿中非常重要的一些啊

26
00:01:00,800 --> 00:01:01,700
乘员变量

27
00:01:01,800 --> 00:01:03,766
首先我们来看第一个乘员变量

28
00:01:03,766 --> 00:01:05,166
叫做Stack pointer

29
00:01:05,733 --> 00:01:06,499
那么这个是什么

30
00:01:06,500 --> 00:01:07,966
就是内核站的指针

31
00:01:08,133 --> 00:01:09,066
内核站的指针

32
00:01:09,066 --> 00:01:11,399
每一个任务啊都有内核站

33
00:01:11,600 --> 00:01:13,500
无论它是用户态的

34
00:01:13,666 --> 00:01:15,366
任务还是内核态的任务

35
00:01:15,500 --> 00:01:16,900
那么都有step pointer

36
00:01:16,900 --> 00:01:19,300
都指向了这个任务的内核指

37
00:01:19,333 --> 00:01:20,399
内核站指针

38
00:01:21,300 --> 00:01:24,400
task status表示的就是这个任务状态

39
00:01:24,500 --> 00:01:26,300
我们在学习进程的时候

40
00:01:26,300 --> 00:01:28,666
我们知道在鸿蒙操作系统中

41
00:01:28,933 --> 00:01:31,933
任务是拥有资源的基本单哦说错了

42
00:01:31,933 --> 00:01:34,299
进程是拥有资源的基本单位啊

43
00:01:34,300 --> 00:01:38,200
进程只有创建和结束两个状态

44
00:01:39,266 --> 00:01:40,499
啊创建结束

45
00:01:40,600 --> 00:01:41,666
还有就是僵尸

46
00:01:41,666 --> 00:01:43,599
这么几个非常简单的状态

47
00:01:43,733 --> 00:01:46,766
那么至于说运行态啊挂起态啊

48
00:01:46,766 --> 00:01:49,199
运行态啊挂起态啊左侧态啊

49
00:01:49,200 --> 00:01:50,000
我们在

50
00:01:50,000 --> 00:01:52,533
我们在操作系统学习的一些常用状态

51
00:01:52,533 --> 00:01:54,499
那么任务那个进程都

52
00:01:54,500 --> 00:01:56,766
是没有没有的那只有在任务里才有

53
00:01:56,933 --> 00:01:58,199
那后面我们会看啊

54
00:01:58,200 --> 00:01:59,466
这个task status

55
00:01:59,466 --> 00:02:01,266
就表示当前任务是就绪态的

56
00:02:01,266 --> 00:02:02,866
是运行态的还是阻塞态

57
00:02:02,866 --> 00:02:04,199
还是挂起态啊等等

58
00:02:04,800 --> 00:02:07,733
priority就是这个任务的优先级

59
00:02:07,900 --> 00:02:08,966
policy是什么呢

60
00:02:08,966 --> 00:02:10,966
就是任务的调度算法

61
00:02:10,966 --> 00:02:12,333
调度算法啊

62
00:02:12,333 --> 00:02:14,466
那么目前呢鸿蒙系统中

63
00:02:14,966 --> 00:02:17,566
典型的调度算法呢有什么呢

64
00:02:17,566 --> 00:02:18,766
有round Robin啊

65
00:02:18,766 --> 00:02:20,766
round Robin就是时间偏轮转

66
00:02:20,866 --> 00:02:23,966
还有就是first in first out啊先进先出

67
00:02:25,000 --> 00:02:26,566
啊那么timeslice是什么呢

68
00:02:26,566 --> 00:02:27,899
就是一个时间片

69
00:02:28,066 --> 00:02:29,399
比如说我们这个任务

70
00:02:29,400 --> 00:02:31,400
目前采用的是Rodrobin r

71
00:02:31,400 --> 00:02:32,533
r这种调度策略

72
00:02:32,533 --> 00:02:34,166
那么在每一个进程

73
00:02:34,166 --> 00:02:36,599
在每一个任务运行的时候都会为它

74
00:02:36,933 --> 00:02:38,299
分配一个时间片

75
00:02:38,333 --> 00:02:40,699
那么这个时间片的大小随着任务的

76
00:02:40,933 --> 00:02:43,599
就是随着就绪队列中任务的个数的增

77
00:02:43,600 --> 00:02:45,066
增加而减少啊

78
00:02:45,066 --> 00:02:45,966
增加而减少

79
00:02:46,100 --> 00:02:48,300
那后面我们在讲调度的时候会看一下

80
00:02:48,300 --> 00:02:49,933
这个timeslight是怎么计算

81
00:02:50,366 --> 00:02:51,733
那么Stack size是什么

82
00:02:51,733 --> 00:02:55,299
Stack size就是这个内核站的一个大小啊

83
00:02:55,300 --> 00:02:56,866
内核站空间的一个大小

84
00:02:57,100 --> 00:02:58,966
那么这个是在初始化的时候

85
00:02:58,966 --> 00:03:01,733
在创建任务的时候就赋予负值了啊

86
00:03:01,733 --> 00:03:02,533
负值了

87
00:03:02,666 --> 00:03:05,366
top of Stack就是站指针啊站指针

88
00:03:05,366 --> 00:03:08,999
task ID就是这个任务的这个ID号啊

89
00:03:09,000 --> 00:03:09,966
任务标识

90
00:03:10,200 --> 00:03:12,466
那么task entry这个非常重要啊

91
00:03:12,466 --> 00:03:13,566
task entry是什么呢

92
00:03:13,566 --> 00:03:15,133
这个task entry就是

93
00:03:15,133 --> 00:03:15,966
我们的任务

94
00:03:15,966 --> 00:03:18,166
实际上是要运行某一个函数的

95
00:03:18,466 --> 00:03:19,999
那么这个task entry指向的

96
00:03:20,000 --> 00:03:20,900
就是说这个任务

97
00:03:20,900 --> 00:03:22,666
实际运行的那个函数的

98
00:03:22,666 --> 00:03:25,099
地址实际运行的函数地址

99
00:03:25,200 --> 00:03:26,700
那么当这个函数

100
00:03:26,700 --> 00:03:28,100
当这个任务运行起来的时候

101
00:03:28,100 --> 00:03:29,933
它就到这个task entry啊

102
00:03:29,933 --> 00:03:31,866
还有与这个task entry非常

103
00:03:31,933 --> 00:03:33,666
相关的就是arguments

104
00:03:33,800 --> 00:03:35,966
argument这arguments four啊

105
00:03:35,966 --> 00:03:37,333
看ARGUMENT4是什么呢

106
00:03:37,333 --> 00:03:39,499
就是这个task entry要运行的时候

107
00:03:39,566 --> 00:03:41,799
它接收的这个输入参数的位置啊

108
00:03:41,800 --> 00:03:42,933
输入参数的位置

109
00:03:43,333 --> 00:03:44,399
那么这个是什么呢

110
00:03:44,400 --> 00:03:46,866
dry dry return value

111
00:03:46,866 --> 00:03:49,699
dry return value那这个就类似于什么呢

112
00:03:49,700 --> 00:03:52,266
就是类似于因为县城之间啊

113
00:03:52,266 --> 00:03:55,366
县城之间也有什么也有类似于那种啊

114
00:03:55,366 --> 00:03:56,333
同步的关系啊

115
00:03:56,333 --> 00:03:57,099
同步的关系

116
00:03:57,100 --> 00:03:58,700
那这个就是县城之间

117
00:03:58,700 --> 00:04:00,500
搞同步的这么一个东西啊

118
00:04:00,700 --> 00:04:01,900
搞同步的一个东西

119
00:04:02,366 --> 00:04:05,766
同步啊那这些是你看啊task

120
00:04:06,466 --> 00:04:10,999
啊sum of sum of信号量mutext task mutext啊

121
00:04:11,000 --> 00:04:12,933
护士所还有task invent

122
00:04:12,933 --> 00:04:16,166
那这些函数这些指针呢都和什么呢

123
00:04:16,300 --> 00:04:17,600
都和这个

124
00:04:17,766 --> 00:04:21,099
这个这个就是近同步与护士相关啊

125
00:04:21,100 --> 00:04:22,400
同步与护士相关

126
00:04:22,566 --> 00:04:23,366
嗯

127
00:04:24,466 --> 00:04:25,266
那么

128
00:04:25,566 --> 00:04:26,666
呃这个表示什么

129
00:04:26,666 --> 00:04:28,999
这个表示就是进程所持有的

130
00:04:29,000 --> 00:04:30,466
你看Toscal的SEMI

131
00:04:30,766 --> 00:04:31,933
进程持有的

132
00:04:31,933 --> 00:04:34,066
这个指向这个进程所持有的

133
00:04:34,766 --> 00:04:35,466
信号量啊

134
00:04:35,466 --> 00:04:38,499
指向这个进程所持有的互斥所啊

135
00:04:38,600 --> 00:04:39,066
等等

136
00:04:39,066 --> 00:04:41,566
那这个我们在讲同步与互斥的时候

137
00:04:41,566 --> 00:04:42,933
会讲到啊

138
00:04:42,933 --> 00:04:44,266
那task name是什么呢

139
00:04:44,266 --> 00:04:45,933
就是这个任务的这个

140
00:04:45,933 --> 00:04:47,999
这个任务的名名称对吧

141
00:04:48,000 --> 00:04:50,133
和task ID比较接近接近啊

142
00:04:50,133 --> 00:04:52,199
task ID pandalist是什么呢

143
00:04:52,200 --> 00:04:54,733
pandalist就是这个任务

144
00:04:54,733 --> 00:04:56,599
会被挂载到不同的位置

145
00:04:56,733 --> 00:04:58,399
那么它挂载的不同位置

146
00:04:58,400 --> 00:05:00,400
主要就通过这个pandalist来

147
00:05:00,533 --> 00:05:02,733
来挂spread list是什么呢

148
00:05:02,733 --> 00:05:03,466
spread list

149
00:05:03,466 --> 00:05:07,166
就是比如说一个进程有多个任务那

150
00:05:07,166 --> 00:05:07,999
么这个

151
00:05:08,700 --> 00:05:09,533
有多个任务

152
00:05:09,533 --> 00:05:11,699
那这些任务就通过这个spread list

153
00:05:11,700 --> 00:05:13,333
形成一个列表啊

154
00:05:13,333 --> 00:05:14,199
形成一个列表

155
00:05:15,200 --> 00:05:15,266
啊

156
00:05:15,266 --> 00:05:16,299
那么这个

157
00:05:16,933 --> 00:05:19,999
这两个以万的Max和以万mode的这个

158
00:05:20,000 --> 00:05:23,300
这个东西都和这个task 1万的相关啊

159
00:05:23,300 --> 00:05:24,333
TAS跟1万的相关

160
00:05:24,333 --> 00:05:26,266
那这个我们在讲那什么的时候

161
00:05:26,266 --> 00:05:28,766
再讲同比互斥的时候会会给大家介绍

162
00:05:29,266 --> 00:05:31,299
那这些东西是跟信号相关的啊

163
00:05:31,300 --> 00:05:32,600
信号处理相关的

164
00:05:32,866 --> 00:05:35,133
那这个是car的CPU是什么

165
00:05:35,133 --> 00:05:36,733
就是这个进程啊

166
00:05:36,733 --> 00:05:40,699
这个任务当时当前所运行的CPU号啊

167
00:05:40,700 --> 00:05:41,866
last的CPU是什么呢

168
00:05:41,866 --> 00:05:43,099
这个县城啊

169
00:05:43,100 --> 00:05:46,000
或者说这个任务最后一次运行的时候

170
00:05:46,300 --> 00:05:48,333
啊最后一次上一次运行的时候

171
00:05:48,333 --> 00:05:49,499
他的CPU号

172
00:05:49,600 --> 00:05:50,700
那这是什么呢

173
00:05:50,700 --> 00:05:53,333
就是这个县城或者这个任务的CPU

174
00:05:53,333 --> 00:05:54,266
亲和性啊

175
00:05:54,266 --> 00:05:55,066
亲和性

176
00:05:55,800 --> 00:05:58,800
啊那么啊这个表示的就是这个

177
00:05:58,866 --> 00:06:00,899
这个这个关于死锁啊

178
00:06:00,900 --> 00:06:02,566
关于死锁相关的一些东西

179
00:06:02,933 --> 00:06:03,699
那这个呢

180
00:06:03,700 --> 00:06:06,300
是关于虚拟存储的一些东西啊

181
00:06:06,300 --> 00:06:07,500
虚拟存储的一些东西

182
00:06:07,600 --> 00:06:09,866
那么WETP wet ID是什么呢

183
00:06:09,866 --> 00:06:13,099
wet ID我们前面在讲进程的时候讲过啊

184
00:06:13,366 --> 00:06:15,699
当执行wait系统调用的时候啊

185
00:06:15,700 --> 00:06:17,200
wait系统调用的时候

186
00:06:17,300 --> 00:06:18,666
那么这个县城

187
00:06:18,666 --> 00:06:19,366
或者这个任务

188
00:06:19,366 --> 00:06:21,299
究竟在等待着哪一个紫禁城

189
00:06:21,366 --> 00:06:23,199
那会把那个紫禁城的PID

190
00:06:23,200 --> 00:06:24,566
附在这个位置啊

191
00:06:24,566 --> 00:06:25,566
附在这个位置

192
00:06:25,666 --> 00:06:27,366
那这些东西都是与什么呢

193
00:06:27,366 --> 00:06:29,166
就是县城间通信啊

194
00:06:29,166 --> 00:06:32,399
或者进城间通信相关的一些成员变量

195
00:06:32,933 --> 00:06:33,733
no right now

196
00:06:36,266 --> 00:06:37,766
那么我们来看一下啊

197
00:06:37,900 --> 00:06:39,066
那么这个是

198
00:06:39,066 --> 00:06:40,999
首先我们看一下这个current CPU

199
00:06:41,000 --> 00:06:41,933
刚刚讲过

200
00:06:42,133 --> 00:06:42,899
那么鸿蒙

201
00:06:42,900 --> 00:06:44,500
内核呢支持多CPU

202
00:06:44,766 --> 00:06:46,466
多CPU的好处是效率高

203
00:06:46,466 --> 00:06:48,566
任务又叫现成也叫作业

204
00:06:48,933 --> 00:06:50,999
那CPU呢就是做作业的

205
00:06:51,133 --> 00:06:54,699
多个CPU呢就是有多个能做作业的

206
00:06:54,933 --> 00:06:57,366
一个作业能一鼓作气完成吗

207
00:06:57,366 --> 00:06:58,766
答案是往往不行

208
00:06:59,266 --> 00:07:02,466
因为现实不允许作业可以有n多

209
00:07:02,466 --> 00:07:04,466
而CPU数量非常有限

210
00:07:04,533 --> 00:07:06,133
所以经常坐着

211
00:07:06,133 --> 00:07:09,333
a作业被老板打断让去做b作业

212
00:07:10,000 --> 00:07:11,766
这老板就是调度算法

213
00:07:12,100 --> 00:07:13,566
a作业被打断

214
00:07:13,666 --> 00:07:14,566
回来接着

215
00:07:15,066 --> 00:07:17,566
做还是a

216
00:07:17,800 --> 00:07:18,933
作业被打断

217
00:07:18,933 --> 00:07:22,733
回来接着做的还是原来的那个CPU吗

218
00:07:22,733 --> 00:07:23,799
答案是不一定

219
00:07:24,100 --> 00:07:28,600
那么变量CPU affinity mask叫CPU亲和性

220
00:07:28,900 --> 00:07:30,900
它呢它的作用是指

221
00:07:31,266 --> 00:07:33,899
是可以指定a作业始终在同一个

222
00:07:33,900 --> 00:07:35,300
CPU来完成

223
00:07:35,866 --> 00:07:37,766
也可以随便交给调度算法

224
00:07:37,966 --> 00:07:39,299
分到谁就是谁

225
00:07:39,300 --> 00:07:40,533
这方面呢可以不挑

226
00:07:40,533 --> 00:07:42,266
所以这是CPU亲和性啊

227
00:07:42,366 --> 00:07:44,566
那为什么有color的CPU和辣子的CPU呢

228
00:07:44,566 --> 00:07:46,766
因为我们知道CPU有catch啊

229
00:07:46,766 --> 00:07:48,133
CPU内部有cash

230
00:07:48,366 --> 00:07:51,166
那么如果car的CPU或loss的CPU的

231
00:07:51,300 --> 00:07:52,366
是相同的话

232
00:07:52,400 --> 00:07:53,266
那么怎么样呢

233
00:07:53,266 --> 00:07:55,199
就是这个cash的利用率会更高一些

234
00:07:55,200 --> 00:07:57,066
那么我们关于这个详细的东西

235
00:07:57,066 --> 00:07:58,333
我们在线下的时候

236
00:07:58,500 --> 00:08:00,133
线下课程会详细讲解

237
00:08:02,000 --> 00:08:05,400
那么进程分内核态进程和用户态进程

238
00:08:05,700 --> 00:08:06,933
这两个区别

239
00:08:07,133 --> 00:08:09,966
表现在线程层面上就是

240
00:08:10,200 --> 00:08:12,066
内核态进程下

241
00:08:12,133 --> 00:08:14,766
创建任务只有内核站的站

242
00:08:14,766 --> 00:08:16,133
内核态的站空间

243
00:08:16,400 --> 00:08:19,933
那么具体的就是OS tax和Stack Alog负责

244
00:08:20,500 --> 00:08:22,133
内核态占空间的分配

245
00:08:22,133 --> 00:08:23,799
那这个函数我们后面会看啊

246
00:08:23,800 --> 00:08:26,366
还有就是OS task Stacky need

247
00:08:26,366 --> 00:08:28,999
负责对内核站进行初始化

248
00:08:29,733 --> 00:08:31,533
那么用户态下

249
00:08:31,566 --> 00:08:32,866
用户态进程下

250
00:08:33,366 --> 00:08:34,566
创建的任务

251
00:08:35,733 --> 00:08:39,099
除了有内核占内核态的占空间外呢

252
00:08:39,100 --> 00:08:42,300
还有用户态占空间那么

253
00:08:42,966 --> 00:08:43,566
内核

254
00:08:43,566 --> 00:08:46,966
用户态占空间主要通过OS user task stack init

255
00:08:47,300 --> 00:08:48,066
啊

256
00:08:48,066 --> 00:08:51,566
OS user task stack init负责对其初始化

257
00:08:51,700 --> 00:08:53,066
那么它的调用量是什么呢

258
00:08:53,066 --> 00:08:56,099
就是soi S E X C V E到loss

259
00:08:56,200 --> 00:09:01,600
do execute execute file到OS EX EC到OS EE

260
00:09:01,866 --> 00:09:06,299
OS exe start最后调用这个OS user task stack in need

261
00:09:06,400 --> 00:09:08,800
那后面我们也会分析这两个函数啊

262
00:09:09,700 --> 00:09:11,733
好我们现在就开始分析这两个函数

263
00:09:12,100 --> 00:09:13,900
首先OS task Stack need

264
00:09:13,900 --> 00:09:15,333
我们回忆一下是什么呀

265
00:09:15,400 --> 00:09:16,933
就是初始化什么呢

266
00:09:16,933 --> 00:09:19,933
用户的初始化现成的内核站啊

267
00:09:19,933 --> 00:09:21,166
初始化现成的内核站

268
00:09:21,566 --> 00:09:22,599
那我们来看一下啊

269
00:09:22,600 --> 00:09:23,733
我们看一下大家看

270
00:09:23,866 --> 00:09:25,866
首先呢首先啊

271
00:09:25,866 --> 00:09:28,466
这个这个这这两条语句是干嘛呢

272
00:09:28,500 --> 00:09:30,666
首先是对内核战进行一下初始化

273
00:09:30,766 --> 00:09:32,666
然后呢我们知道啊

274
00:09:32,666 --> 00:09:33,099
我们知道

275
00:09:33,100 --> 00:09:34,933
我们在讲这个系统调用的时候

276
00:09:34,933 --> 00:09:35,733
我们知道

277
00:09:35,733 --> 00:09:37,266
那么内核战

278
00:09:38,300 --> 00:09:39,500
我们在讲系统调用的时候

279
00:09:39,500 --> 00:09:40,200
我们知道

280
00:09:40,200 --> 00:09:42,733
内核站的一开始它是一个什么

281
00:09:43,066 --> 00:09:44,199
它是一个什么

282
00:09:44,266 --> 00:09:46,999
我们可以怎么样把这个内核站的站底

283
00:09:47,300 --> 00:09:48,533
强制转换一个

284
00:09:48,566 --> 00:09:50,599
转换成一个task context的

285
00:09:50,600 --> 00:09:51,766
这么一个结构体

286
00:09:51,933 --> 00:09:54,399
大家看是否还记得task context的结构体

287
00:09:54,500 --> 00:09:55,366
那这个结构体

288
00:09:55,366 --> 00:09:57,466
实际上就是各种各样的CQ寄存器

289
00:09:57,866 --> 00:09:58,899
各种各样的CPU寄存器

290
00:09:58,900 --> 00:10:01,600
大家看我在这个CPU寄存器里

291
00:10:01,600 --> 00:10:02,666
是怎么设置的呢

292
00:10:02,666 --> 00:10:03,999
你看啊我在这设置是这

293
00:10:04,000 --> 00:10:05,400
个你看我把这个

294
00:10:05,600 --> 00:10:07,900
寄存器的PC设置成什么了

295
00:10:08,066 --> 00:10:09,399
设置成了一个函数

296
00:10:09,466 --> 00:10:11,799
这个函数叫做OS task entry

297
00:10:12,333 --> 00:10:12,366
啊

298
00:10:12,366 --> 00:10:14,899
那么大家看内核站啊内核站

299
00:10:14,933 --> 00:10:16,599
所有的内核内核站

300
00:10:16,600 --> 00:10:19,700
它的这个PC都设置成了OS tax和entry

301
00:10:19,766 --> 00:10:20,699
那我们后面看一下

302
00:10:20,700 --> 00:10:22,900
它的为什么是这个OS tax和entry

303
00:10:23,133 --> 00:10:23,933
好吧

304
00:10:26,533 --> 00:10:27,866
好首先我们来看一下啊

305
00:10:27,933 --> 00:10:29,699
初始化任务的内核站

306
00:10:29,700 --> 00:10:32,533
将PC设为OS task安全的地址

307
00:10:32,800 --> 00:10:33,600
那么

308
00:10:34,166 --> 00:10:35,699
那么我们看一下这个函数呢

309
00:10:35,700 --> 00:10:40,166
就是初始化了任务上下文task context

310
00:10:40,266 --> 00:10:42,499
并将任务上下文放在了占底

311
00:10:42,500 --> 00:10:44,666
初始化任务上下文的目的是

312
00:10:44,900 --> 00:10:46,733
为了在运行阶段

313
00:10:46,933 --> 00:10:50,399
先初始化20-25 CPS2计存器的值

314
00:10:50,900 --> 00:10:53,133
保存上下文和恢复上下文

315
00:10:53,333 --> 00:10:55,299
都是针对寄存器值而言的

316
00:10:55,300 --> 00:10:58,266
这个工作呢是在内核态的战中完成的

317
00:10:58,266 --> 00:11:01,499
也就是说一个任务的上下文是保存在

318
00:11:01,866 --> 00:11:04,066
任务的内核战中的啊

319
00:11:04,200 --> 00:11:05,200
然后大家看

320
00:11:06,066 --> 00:11:06,699
在最后

321
00:11:06,700 --> 00:11:10,300
OS task Stack need的返回值将复制给

322
00:11:10,500 --> 00:11:11,333
将赋予什么呢

323
00:11:11,333 --> 00:11:13,599
Stack pointer也就是SP计算器

324
00:11:15,933 --> 00:11:16,166
好

325
00:11:16,166 --> 00:11:19,733
那这个就是这个task context的结构体

326
00:11:19,966 --> 00:11:23,099
鸿蒙Letos呢是基于任务进行调度的

327
00:11:23,100 --> 00:11:23,566
因此

328
00:11:23,566 --> 00:11:26,666
调度的本质就是CPU执行一个新的task

329
00:11:26,733 --> 00:11:30,499
老task在什么地方被中断谁也不清楚

330
00:11:30,500 --> 00:11:31,500
是随机的

331
00:11:31,733 --> 00:11:33,199
那如何保证

332
00:11:34,000 --> 00:11:37,266
老任务被再次调度选中时

333
00:11:37,566 --> 00:11:40,166
还能从上次被中断的地方继续

334
00:11:40,166 --> 00:11:41,266
运行下去呢

335
00:11:41,366 --> 00:11:43,866
答案是任务上下文CPU内的

336
00:11:44,200 --> 00:11:45,766
CPU内有一堆计算器

337
00:11:45,766 --> 00:11:47,366
CPU运行本质

338
00:11:47,766 --> 00:11:50,466
就是这些寄存器的值不断的变化

339
00:11:50,600 --> 00:11:53,700
只要切换时把这些值保存起来

340
00:11:53,766 --> 00:11:57,299
再还原回来就能保证task的连续执行

341
00:11:57,400 --> 00:11:59,000
让用户毫无感知

342
00:11:59,500 --> 00:12:00,300
鸿蒙内核

343
00:12:00,300 --> 00:12:02,700
给一个任务执行的时间是20毫秒

344
00:12:02,733 --> 00:12:05,399
那这个这个这个不一定是20毫秒啊

345
00:12:05,400 --> 00:12:08,000
后面我我们讲调子的时候会会会算

346
00:12:08,000 --> 00:12:09,100
会看他算的

347
00:12:09,333 --> 00:12:10,133
怎么算啊

348
00:12:10,300 --> 00:12:12,400
也就是说多任务竞争下

349
00:12:12,400 --> 00:12:15,133
一秒钟最多可以来回切换50次

350
00:12:16,200 --> 00:12:17,466
那么在这我们介绍

351
00:12:17,466 --> 00:12:19,266
几个特别的寄存器啊

352
00:12:19,366 --> 00:12:20,166
那么

353
00:12:20,766 --> 00:12:23,766
基本都是CPU寄存器的恢复

354
00:12:24,400 --> 00:12:25,300
嗯

355
00:12:25,933 --> 00:12:28,799
这些寄存器呢都是CPU CPU寄存器啊

356
00:12:28,800 --> 00:12:29,966
大家可以查一下

357
00:12:30,000 --> 00:12:31,266
那么我们具体来说一下

358
00:12:31,266 --> 00:12:33,066
这三个非常重要的寄存器

359
00:12:33,100 --> 00:12:36,766
SPLR和PC那么LR叫做link register

360
00:12:36,766 --> 00:12:37,966
它的用途有二

361
00:12:38,200 --> 00:12:40,766
一是保存子程序返回地址

362
00:12:40,933 --> 00:12:44,866
当调用BL BX BLX这都是跳转指令啊

363
00:12:44,866 --> 00:12:48,299
等跳转指令时会自动返回保存

364
00:12:49,133 --> 00:12:49,366
啊

365
00:12:49,366 --> 00:12:54,933
会自动保存返回地址到LR2是保存

366
00:12:55,000 --> 00:12:56,300
异常发生的

367
00:12:56,366 --> 00:12:57,499
异常返回地址

368
00:12:57,866 --> 00:12:59,866
那PC就是program counter

369
00:13:00,100 --> 00:13:01,333
为程序计数器

370
00:13:01,333 --> 00:13:03,266
用于保存程序的执行地址

371
00:13:03,266 --> 00:13:04,066
当

372
00:13:04,100 --> 00:13:06,400
发生当突然发生中断的时候呢

373
00:13:06,400 --> 00:13:08,366
保存的是PC的地址

374
00:13:08,800 --> 00:13:09,466
SP

375
00:13:09,466 --> 00:13:10,666
就是STAG pointer

376
00:13:10,766 --> 00:13:13,133
每一种异常模式呢都有其

377
00:13:13,700 --> 00:13:15,466
自己独立的R13

378
00:13:15,533 --> 00:13:18,566
那PC SP实际上就是R13计算器啊

379
00:13:18,933 --> 00:13:22,499
他通常指向异常模式所专用的对战

380
00:13:22,666 --> 00:13:24,666
当arm进入异常模式时

381
00:13:24,666 --> 00:13:28,133
程序就可以把一般通用计算器

382
00:13:28,133 --> 00:13:30,299
然后对战返回时再出战

383
00:13:30,500 --> 00:13:31,333
保证了

384
00:13:31,400 --> 00:13:34,666
各种模式下程序的状态的完整性啊

385
00:13:34,666 --> 00:13:36,733
这东西其实我们在前面讲这个系统

386
00:13:36,733 --> 00:13:37,199
调用的时候

387
00:13:37,200 --> 00:13:38,200
都已经说过啊

388
00:13:39,200 --> 00:13:40,000
好我们现在呢

389
00:13:40,000 --> 00:13:42,066
来看一个具体的一个例子啊

390
00:13:42,066 --> 00:13:42,933
具体的例子

391
00:13:43,000 --> 00:13:43,800
比如比如说

392
00:13:43,800 --> 00:13:44,966
这个是be catch

393
00:13:45,166 --> 00:13:46,333
叫be catch同步

394
00:13:46,333 --> 00:13:50,533
be catch嘶嘶as sin sink sink是同步的意思啊

395
00:13:50,533 --> 00:13:51,466
同步的缩写

396
00:13:51,566 --> 00:13:53,399
be catch sink spread

397
00:13:53,533 --> 00:13:55,599
同步现成的初始化工作

398
00:13:55,900 --> 00:13:56,700
好我们看一下啊

399
00:13:56,700 --> 00:13:58,366
这就是创建一个内核线程

400
00:13:58,366 --> 00:14:00,366
这个内核线程用用来干嘛呢

401
00:14:00,400 --> 00:14:02,400
用来同步这个be catch的啊

402
00:14:02,400 --> 00:14:03,933
用来同步这个be catch的

403
00:14:04,100 --> 00:14:05,000
好我们看一下啊

404
00:14:05,000 --> 00:14:06,533
它在这首先干嘛呢

405
00:14:06,533 --> 00:14:08,866
它在这首先有一个这样的一个参数啊

406
00:14:08,866 --> 00:14:09,899
这样的一个数据结构

407
00:14:09,900 --> 00:14:10,800
这个数据结构

408
00:14:10,866 --> 00:14:12,133
那这个数据结构干嘛呢

409
00:14:12,133 --> 00:14:14,299
它就是用来初始化这个

410
00:14:14,966 --> 00:14:16,199
啊就是你看啊在这

411
00:14:16,533 --> 00:14:18,066
lost task create

412
00:14:18,100 --> 00:14:19,133
把这个把这个

413
00:14:19,133 --> 00:14:21,566
把这个数据数据结构传进来了

414
00:14:21,566 --> 00:14:22,366
那么也就是说

415
00:14:22,366 --> 00:14:24,166
县城在进行初始化的时候

416
00:14:24,166 --> 00:14:25,766
要根据这个数据结构的信息

417
00:14:25,766 --> 00:14:27,066
填填入的信息

418
00:14:27,200 --> 00:14:30,466
对这个县城对这个内核县城的PCB

419
00:14:30,466 --> 00:14:31,533
还有就是内核

420
00:14:31,700 --> 00:14:33,200
内核站进行初始化

421
00:14:33,866 --> 00:14:35,599
啊我们看一下这个主要干嘛呢

422
00:14:35,600 --> 00:14:37,700
你看啊他在这个地方把一个函数

423
00:14:37,700 --> 00:14:40,333
这是这是函数叫做be catch thinks right

424
00:14:40,500 --> 00:14:42,000
这是这是这是一个函数

425
00:14:42,000 --> 00:14:44,100
它把这个函数的地址付给了谁呢

426
00:14:44,100 --> 00:14:46,133
付给了这个APP task的

427
00:14:46,866 --> 00:14:50,166
啊PPFN task entry啊

428
00:14:50,366 --> 00:14:51,399
啊这个干嘛用呢

429
00:14:51,400 --> 00:14:53,566
这个我们看我们在前面不是强调了吗

430
00:14:53,566 --> 00:14:56,199
你看在这个地方啊在这个地方啊

431
00:14:56,200 --> 00:14:56,733
在这个地方

432
00:14:56,733 --> 00:14:59,599
你看他是不是把PC复位OS task安锤

433
00:14:59,600 --> 00:15:00,466
这是一个函数

434
00:15:00,466 --> 00:15:02,299
那后面我们就知道这个函数要干嘛

435
00:15:02,300 --> 00:15:03,800
这个函数就叫借助于

436
00:15:04,333 --> 00:15:05,599
啊就要执行这个函数

437
00:15:05,600 --> 00:15:06,933
就要执行这个函数啊

438
00:15:07,066 --> 00:15:08,966
好那大家看这个是什么呢

439
00:15:08,966 --> 00:15:11,899
这个就是内核栅的大小叫be catch stack size

440
00:15:12,200 --> 00:15:13,766
啊你看这就是内核战的大小

441
00:15:13,766 --> 00:15:14,466
看到了吧

442
00:15:14,466 --> 00:15:15,466
那这是内核

443
00:15:15,466 --> 00:15:17,533
这个县城的名字就是任务的名字

444
00:15:17,533 --> 00:15:18,066
看到了吧

445
00:15:18,066 --> 00:15:19,733
那它的优先级是这个

446
00:15:19,766 --> 00:15:20,333
看到了吧

447
00:15:20,333 --> 00:15:23,066
那这个这个是这个这个任务啊

448
00:15:23,066 --> 00:15:24,333
这个任务要运行的函数

449
00:15:24,333 --> 00:15:25,766
这个函数的入口猜出几个呢

450
00:15:25,766 --> 00:15:26,566
只有一个

451
00:15:26,566 --> 00:15:28,699
看到了吧它这个0等于这个ID啊

452
00:15:28,700 --> 00:15:29,500
看到了吧

453
00:15:30,100 --> 00:15:31,000
好然后呢

454
00:15:31,000 --> 00:15:32,866
你看他把这些东西准备好之后

455
00:15:32,866 --> 00:15:34,699
就把这个结数据结构传到这

456
00:15:34,733 --> 00:15:37,999
传到这个lost task QA的函数里来了

457
00:15:38,466 --> 00:15:40,099
传到这个函数里来这个函数干嘛呢

458
00:15:40,100 --> 00:15:40,900
这个函数

459
00:15:41,166 --> 00:15:43,866
这个函数就利用这个APP task所

460
00:15:43,933 --> 00:15:45,366
所保存的数据来

461
00:15:45,700 --> 00:15:47,066
来怎么创建这个任务

462
00:15:47,166 --> 00:15:48,566
好我们具体来看一下啊

463
00:15:48,566 --> 00:15:50,566
具体来看一下这个lost task create

464
00:15:51,133 --> 00:15:52,366
那lost task create

465
00:15:52,366 --> 00:15:54,666
首先检查一下它是不是用户态

466
00:15:54,733 --> 00:15:55,933
显然不是用户态

467
00:15:56,200 --> 00:15:57,366
对吧不是用户太

468
00:15:57,466 --> 00:15:58,099
然后呢

469
00:15:58,100 --> 00:15:59,800
就调用最本质的就是在这儿呢

470
00:15:59,800 --> 00:16:02,600
调用这个lost task create only啊

471
00:16:02,600 --> 00:16:03,333
create only

472
00:16:03,333 --> 00:16:05,999
那我们看这个这个这个叫做init parameter

473
00:16:06,000 --> 00:16:08,866
那这个init parameter实际上就是这个这个

474
00:16:09,066 --> 00:16:10,799
APP task APP task

475
00:16:11,166 --> 00:16:12,266
好我们看一下啊

476
00:16:12,300 --> 00:16:13,966
好首先你看他在这啊

477
00:16:14,000 --> 00:16:15,700
你看叫lost toss和create

478
00:16:16,000 --> 00:16:17,933
那这个叫lost toss和create only

479
00:16:17,933 --> 00:16:18,466
是什么意思啊

480
00:16:18,466 --> 00:16:20,733
这个就是我创建一个任务

481
00:16:20,800 --> 00:16:21,600
啊

482
00:16:21,766 --> 00:16:22,166
是什么意思呢

483
00:16:22,166 --> 00:16:24,466
就是我把这个任务TCB啊填完整

484
00:16:24,466 --> 00:16:25,733
然后把它内核战初始化

485
00:16:25,733 --> 00:16:27,299
好但是我并不调度它

486
00:16:27,300 --> 00:16:28,200
那调度由谁干

487
00:16:28,200 --> 00:16:29,266
由下面这个地方干

488
00:16:29,266 --> 00:16:31,333
你看我把这个任务创建起来就only嘛

489
00:16:31,333 --> 00:16:32,999
就是仅把这个任务创建起来

490
00:16:33,266 --> 00:16:34,099
然后干嘛呢

491
00:16:34,166 --> 00:16:35,166
然后干嘛呢

492
00:16:35,266 --> 00:16:36,466
获得我刚刚创建

493
00:16:36,466 --> 00:16:38,566
通过task ID看task ID

494
00:16:38,766 --> 00:16:40,799
获得我刚刚创建这个任务的TCB

495
00:16:40,933 --> 00:16:41,533
然后呢

496
00:16:41,533 --> 00:16:43,999
把这个TCB怎么样插入到就绪队列里

497
00:16:44,000 --> 00:16:44,800
看到了吧

498
00:16:44,966 --> 00:16:47,299
查完就绪队列怎么样再用调度啊

499
00:16:47,300 --> 00:16:48,266
再进行调度

500
00:16:48,266 --> 00:16:49,599
所以这个叫task create

501
00:16:49,600 --> 00:16:51,800
task create是不但创建出来这个任务

502
00:16:51,800 --> 00:16:54,000
而且怎么样把它插入到就绪队列里

503
00:16:54,100 --> 00:16:55,300
然后进行调度

504
00:16:55,400 --> 00:16:56,966
而task create only是什么呢

505
00:16:56,966 --> 00:16:57,566
就是我把

506
00:16:57,566 --> 00:16:59,499
我只只是把这个任务创建起来了

507
00:16:59,500 --> 00:17:01,266
用这个初始化参数创建起来了

508
00:17:01,266 --> 00:17:03,099
但是不进行调度

509
00:17:03,566 --> 00:17:03,999
好我们

510
00:17:04,000 --> 00:17:06,866
再看一下这个lost task create only这个函数

511
00:17:06,933 --> 00:17:08,866
那这个函数主要完成的两大功能

512
00:17:08,866 --> 00:17:11,399
第一大功能是初始化这个任务的TCB

513
00:17:11,766 --> 00:17:13,166
分配这个任务啊

514
00:17:13,166 --> 00:17:14,066
为这个任务分配

515
00:17:14,066 --> 00:17:16,466
为新的任务分配TCB并进行初始化

516
00:17:16,466 --> 00:17:18,666
还有就是为这个新的任务分配内核战

517
00:17:18,666 --> 00:17:19,699
并初始化啊

518
00:17:19,700 --> 00:17:20,933
好我们首先看一下

519
00:17:21,166 --> 00:17:22,599
首先呢他检测一下啊

520
00:17:22,600 --> 00:17:24,200
他检测一下这个参数啊

521
00:17:24,200 --> 00:17:26,166
我传递的这个参数没问题

522
00:17:26,300 --> 00:17:27,900
更重要的是大家看他有个破

523
00:17:28,333 --> 00:17:29,133
为什么有破呢

524
00:17:29,133 --> 00:17:32,166
因为啊内核战就是从这个破啊

525
00:17:32,166 --> 00:17:34,133
这个破实际上是一个内存

526
00:17:34,166 --> 00:17:35,133
物理内存区域啊

527
00:17:35,133 --> 00:17:36,799
物理内存区域啊看没看到

528
00:17:36,800 --> 00:17:37,666
就是内存池

529
00:17:37,666 --> 00:17:38,499
物理内存池

530
00:17:38,666 --> 00:17:39,333
那为什么呢

531
00:17:39,333 --> 00:17:43,099
因为我要为这个内核任务分配什么呢

532
00:17:43,100 --> 00:17:44,100
分配这个

533
00:17:44,533 --> 00:17:45,933
分配这个这个内核站

534
00:17:45,966 --> 00:17:47,133
那这个内核站哪来的

535
00:17:47,133 --> 00:17:48,933
这个内核站实际上就是这个破了

536
00:17:48,933 --> 00:17:49,866
从这个破来的

537
00:17:49,866 --> 00:17:50,733
好吧好

538
00:17:50,733 --> 00:17:52,866
然后呢你看然后第二步是干嘛呢

539
00:17:52,866 --> 00:17:53,899
第二步是通过这个

540
00:17:53,900 --> 00:17:55,366
函数啊从这个

541
00:17:55,933 --> 00:17:58,499
pass这个TCB缓冲池里啊

542
00:17:58,500 --> 00:18:00,300
获得一个空白的缓冲池

543
00:18:00,766 --> 00:18:02,166
获得一个空白的TCB

544
00:18:02,266 --> 00:18:03,066
那这个怎么管理

545
00:18:03,066 --> 00:18:04,666
我们在第二部分会给大家介绍

546
00:18:04,666 --> 00:18:05,799
这个缓冲池怎么处置化

547
00:18:05,800 --> 00:18:07,333
我们在第二部分给大家介绍

548
00:18:07,400 --> 00:18:08,500
那这个破怎么处置化

549
00:18:08,500 --> 00:18:09,866
我们在内存管啊

550
00:18:09,866 --> 00:18:12,466
物理内存管理的时候会会跟大家交代

551
00:18:12,900 --> 00:18:15,066
然后呢这个是关于这个多核啊

552
00:18:15,066 --> 00:18:17,966
就是多核间负载均衡的这么一个东西

553
00:18:17,966 --> 00:18:20,133
大家可以看这实际上是个空函数

554
00:18:20,133 --> 00:18:21,533
没有实现啊没有实现

555
00:18:21,566 --> 00:18:22,133
好了

556
00:18:22,133 --> 00:18:24,533
你看我首先分配了一个空白的TCB

557
00:18:24,566 --> 00:18:25,666
然后再调用什么呢

558
00:18:25,666 --> 00:18:27,099
叫做OS task ilock

559
00:18:27,100 --> 00:18:29,066
从这个破这个地方你看

560
00:18:29,333 --> 00:18:30,066
申请这是什么

561
00:18:30,066 --> 00:18:31,599
这是不是就是内核站的大小

562
00:18:31,600 --> 00:18:32,800
我们前面是不是在这

563
00:18:33,400 --> 00:18:33,866
我们在

564
00:18:33,866 --> 00:18:36,166
我我们在前头是不是在这个地方啊

565
00:18:36,166 --> 00:18:37,466
啊在这个地方

566
00:18:38,866 --> 00:18:39,499
啊在这个地方

567
00:18:39,500 --> 00:18:41,200
你看是不是这个地方指定了对吧

568
00:18:41,200 --> 00:18:42,500
内核站的大小对吧

569
00:18:42,500 --> 00:18:43,500
好那怎么样呢

570
00:18:43,500 --> 00:18:46,200
这个函数就是说我从这个缓冲池里

571
00:18:46,666 --> 00:18:48,933
申申请一个这么大的空间啊

572
00:18:48,933 --> 00:18:50,966
保存在保存在这个里头

573
00:18:50,966 --> 00:18:53,166
把这个指头指针保存在这个位置

574
00:18:53,500 --> 00:18:54,666
好这是现在怎么样

575
00:18:54,666 --> 00:18:56,366
我现在这个任务TCB有了

576
00:18:56,366 --> 00:18:57,266
内核战也有了

577
00:18:57,266 --> 00:18:59,166
那现在我要怎么样分别对这个

578
00:18:59,700 --> 00:19:01,800
TCB和这个内核战进行初始化

579
00:19:01,800 --> 00:19:04,266
好那你看这个这个是什么呢

580
00:19:04,266 --> 00:19:06,299
这个是我看一下啊

581
00:19:07,666 --> 00:19:08,166
大家看

582
00:19:08,166 --> 00:19:09,966
这个是OS task STACK1 net

583
00:19:09,966 --> 00:19:11,799
首先对内核站进行初始化

584
00:19:11,866 --> 00:19:12,299
看到了吧

585
00:19:12,300 --> 00:19:14,666
然后就是OS task CB1 net

586
00:19:15,000 --> 00:19:18,166
对内核对这个任务的TCB进行初始化

587
00:19:18,166 --> 00:19:18,866
看到了吧

588
00:19:18,866 --> 00:19:20,266
最后呢如果成功了的话

589
00:19:20,266 --> 00:19:22,899
我就把这个task ID啊返回来

590
00:19:22,900 --> 00:19:23,366
看到了吧

591
00:19:23,366 --> 00:19:24,933
task ID返回来为什么要返回来呢

592
00:19:24,933 --> 00:19:26,899
你看这个地方返回来task ID

593
00:19:26,900 --> 00:19:28,300
然后怎么样啊

594
00:19:28,300 --> 00:19:31,366
根据这个task ID啊找到这个task CB

595
00:19:31,500 --> 00:19:32,800
那找到task CB之后

596
00:19:32,800 --> 00:19:35,000
就可以把这个task CB放到什么呢

597
00:19:35,000 --> 00:19:35,766
就绪队列里

598
00:19:35,766 --> 00:19:37,566
然后就开始进行调度啊

599
00:19:37,566 --> 00:19:38,799
这就是整个的过程

600
00:19:39,100 --> 00:19:40,600
好我们现在看一下重点

601
00:19:40,600 --> 00:19:41,466
我们看一下什么呢

602
00:19:41,466 --> 00:19:42,266
因为

603
00:19:42,366 --> 00:19:45,399
啊我们重点来看一下这个这个这个

604
00:19:45,533 --> 00:19:46,266
内核战啊

605
00:19:46,266 --> 00:19:48,999
内核战那好好好我们看下内核战

606
00:19:49,466 --> 00:19:51,266
那内核站他是怎么初始化的呢

607
00:19:51,266 --> 00:19:52,766
内核站我们看一下啊

608
00:19:52,933 --> 00:19:53,966
他在这个地方啊

609
00:19:53,966 --> 00:19:55,566
就是我们前面已经看到了

610
00:19:55,566 --> 00:19:56,466
内核站初始化

611
00:19:56,466 --> 00:19:57,966
最主要的就是说哎

612
00:19:58,133 --> 00:19:59,133
我们再回忆一下

613
00:19:59,133 --> 00:20:00,333
内核站是怎么回事来着

614
00:20:00,333 --> 00:20:01,866
内核这是内核站对吧

615
00:20:01,900 --> 00:20:03,100
他把内核站最底下

616
00:20:03,100 --> 00:20:05,100
做成了一个task Strak的结构体

617
00:20:05,666 --> 00:20:07,699
对吧task Strak的结构体

618
00:20:08,266 --> 00:20:09,999
task stroke的结构体啊

619
00:20:10,000 --> 00:20:11,466
task context的结构体

620
00:20:11,466 --> 00:20:12,999
task context的结构体

621
00:20:13,133 --> 00:20:13,733
那么我们知道

622
00:20:13,733 --> 00:20:15,866
task context的结构体有个PC指针

623
00:20:15,866 --> 00:20:17,199
对吧PC指针

624
00:20:17,333 --> 00:20:18,366
这个PC指针是什么

625
00:20:18,366 --> 00:20:19,966
就是说当这个任务返

626
00:20:20,100 --> 00:20:21,733
当这个任务返回的时候

627
00:20:21,733 --> 00:20:23,866
它就从当这个内核态任务返回的时候

628
00:20:23,866 --> 00:20:26,599
它就从这个PC指向的位置开始执行

629
00:20:26,600 --> 00:20:28,600
那我们看这个PC指向的是谁

630
00:20:28,666 --> 00:20:31,333
是一个叫做OS task entry的这样的一个指

631
00:20:31,366 --> 00:20:32,999
这样的一个函数指针啊

632
00:20:33,000 --> 00:20:33,666
那我们下面

633
00:20:33,666 --> 00:20:34,499
下面就来看一下

634
00:20:34,500 --> 00:20:35,966
这个函数指针长啥样啊

635
00:20:35,966 --> 00:20:38,999
你看OS task entry这就是这个函数指针啊

636
00:20:39,000 --> 00:20:40,133
你看大家看啊那

637
00:20:40,133 --> 00:20:41,699
OS task entry是干嘛的呢

638
00:20:41,700 --> 00:20:43,133
首先进行一些同步操作

639
00:20:43,200 --> 00:20:45,666
然后呢根据传递过来的task ID啊

640
00:20:45,666 --> 00:20:46,733
获得它的TCB

641
00:20:47,100 --> 00:20:48,366
为什么获得他的TCB呢

642
00:20:48,366 --> 00:20:50,466
因为你看他在这取TCB的谁

643
00:20:50,466 --> 00:20:52,099
task entry这个内容

644
00:20:52,166 --> 00:20:54,866
然后是这个这个那我们看一下啊

645
00:20:54,866 --> 00:20:55,699
task entry

646
00:20:55,700 --> 00:20:56,500
这是什么

647
00:20:57,766 --> 00:20:58,533
test

648
00:20:58,533 --> 00:20:59,099
安卓是什么

649
00:20:59,100 --> 00:21:00,666
你看在这个地方啊

650
00:21:00,666 --> 00:21:01,199
在这个地方

651
00:21:01,200 --> 00:21:03,966
你看针对我们这个be catch synchronize red

652
00:21:03,966 --> 00:21:04,699
这个函数

653
00:21:04,700 --> 00:21:05,366
就是这个

654
00:21:05,366 --> 00:21:06,266
是不是这个函数啊

655
00:21:06,266 --> 00:21:08,299
这个函数它是设置成这个了对吧

656
00:21:08,333 --> 00:21:10,399
哎这个ID是它的一个指针是不是

657
00:21:10,400 --> 00:21:11,500
那好我们看一下

658
00:21:11,666 --> 00:21:12,999
它在初始化

659
00:21:14,966 --> 00:21:17,366
那么他在初始化内核站的时候啊

660
00:21:17,366 --> 00:21:19,166
他在初始化内核站的时候呢

661
00:21:19,166 --> 00:21:19,966
你看

662
00:21:20,366 --> 00:21:22,566
那么实际上他在啊他在

663
00:21:22,566 --> 00:21:24,099
我看一下啊这后面有哎

664
00:21:24,866 --> 00:21:26,766
他这个后面我看一下啊他在啊

665
00:21:26,766 --> 00:21:28,199
他在初始化这个

666
00:21:28,333 --> 00:21:30,999
他在初始化这个踏克CB的时候

667
00:21:31,133 --> 00:21:31,933
他用啥了呢

668
00:21:31,933 --> 00:21:33,366
你看啊我们看一下啊

669
00:21:33,466 --> 00:21:35,499
我们看一下哎你看一下啊

670
00:21:35,500 --> 00:21:36,966
他在初始化这个

671
00:21:37,533 --> 00:21:39,733
它在初始化这个内核站的内啊

672
00:21:39,733 --> 00:21:40,766
TCB的时候怎么样

673
00:21:40,766 --> 00:21:41,399
你看

674
00:21:41,400 --> 00:21:45,133
它在这儿你看task CB task entry赋予谁

675
00:21:45,133 --> 00:21:46,966
是不是an it parameter方

676
00:21:47,866 --> 00:21:50,333
PFN task entry看到了这个吧

677
00:21:50,333 --> 00:21:51,866
看它在这对

678
00:21:51,966 --> 00:21:54,199
用这个玩意儿对这个task entry进行触刷

679
00:21:54,200 --> 00:21:55,133
而这个东西是啥

680
00:21:55,133 --> 00:21:57,399
是不是就是我们刚才说的这个这个纸

681
00:21:57,500 --> 00:21:58,300
这个指针

682
00:21:58,933 --> 00:22:00,533
看是不是这个

683
00:22:01,166 --> 00:22:02,199
看到了吧是这个

684
00:22:02,333 --> 00:22:03,199
所以说呢

685
00:22:03,200 --> 00:22:04,733
所以说我在这想说的什么

686
00:22:04,733 --> 00:22:06,566
这个有点提前了有点反了

687
00:22:06,600 --> 00:22:09,100
你看这个函数它在这

688
00:22:09,100 --> 00:22:11,566
你看task entry是统一统一的入口

689
00:22:11,600 --> 00:22:13,666
但是在task entry它运行的是哪个函数

690
00:22:13,666 --> 00:22:14,566
它运行的是这个函数

691
00:22:14,566 --> 00:22:15,933
而这个函数是啥呢

692
00:22:15,966 --> 00:22:17,799
这个函数就是这个函数

693
00:22:18,333 --> 00:22:19,266
以及这个参数

694
00:22:19,266 --> 00:22:19,966
看到了吧

695
00:22:19,966 --> 00:22:21,533
所以当这个task啊

696
00:22:21,533 --> 00:22:23,866
他把这个task task安锤大

697
00:22:23,866 --> 00:22:25,366
大家想大家考虑一下

698
00:22:25,366 --> 00:22:26,666
大家自己脑补一下啊

699
00:22:26,666 --> 00:22:29,466
大脑补一下就是说我首先怎么样呢

700
00:22:29,466 --> 00:22:31,366
哎我首先把这个TCB

701
00:22:31,900 --> 00:22:33,600
我把这个TCB的这个

702
00:22:34,500 --> 00:22:36,500
TCB的这个函数设置好了

703
00:22:36,500 --> 00:22:38,200
这是什么呢PFN

704
00:22:40,133 --> 00:22:43,133
PFN然后这个PFN指向的就是这个

705
00:22:43,133 --> 00:22:44,133
具体的函数啊

706
00:22:44,133 --> 00:22:45,199
这个具体的函数

707
00:22:45,466 --> 00:22:48,799
然后呢我把这个内核站的PC设置好了

708
00:22:48,800 --> 00:22:49,600
这个PC

709
00:22:51,966 --> 00:22:53,533
TC事啊这个PC是谁呢

710
00:22:53,533 --> 00:22:56,299
这个PC指向的就是这个OS task entry

711
00:22:57,000 --> 00:22:59,733
啊指向的就是这个OS task entry对吧

712
00:22:59,733 --> 00:23:01,099
那好那么这样的话

713
00:23:01,100 --> 00:23:01,966
当我把然后

714
00:23:01,966 --> 00:23:04,133
我就把这个TCB加到这个旧序队列里

715
00:23:04,133 --> 00:23:06,566
对吧这个TCB加到这个旧序队列里

716
00:23:06,766 --> 00:23:08,666
然后当调度运行的时候怎么样

717
00:23:08,666 --> 00:23:09,333
调度运行的时候

718
00:23:09,333 --> 00:23:11,199
它就到内核站里找到这个PC指针

719
00:23:11,200 --> 00:23:11,800
开始执行

720
00:23:11,800 --> 00:23:13,500
它从这个地方开始执行

721
00:23:13,500 --> 00:23:14,933
而这个PC指针指向的是这个

722
00:23:14,933 --> 00:23:16,133
它就开始运行这个函数

723
00:23:16,333 --> 00:23:17,933
当它运行到这个函数的时候它干嘛

724
00:23:17,933 --> 00:23:19,799
它就到这个task Strak

725
00:23:20,000 --> 00:23:22,600
task CB的这个task entry也就是这个位置

726
00:23:22,800 --> 00:23:24,466
把这个真正的内核

727
00:23:24,466 --> 00:23:25,899
把这个真正的函数找出来

728
00:23:25,900 --> 00:23:26,733
然后开始运行

729
00:23:27,100 --> 00:23:29,066
那这就是大家看这样的话怎么样

730
00:23:29,066 --> 00:23:30,766
当一调度这个任务控制块的时候

731
00:23:30,766 --> 00:23:32,999
他就开始运行起来这个真正的函数了

732
00:23:33,133 --> 00:23:34,766
那这就是整个的一个过程

733
00:23:36,666 --> 00:23:38,066
那好我们再看那么

734
00:23:38,066 --> 00:23:39,966
我们看一下这个就是

735
00:23:40,300 --> 00:23:41,733
在初始化任务

736
00:23:41,900 --> 00:23:44,000
TCB的时候它是怎么工作的啊

737
00:23:44,066 --> 00:23:45,866
那首先大家看啊它怎么样呢

738
00:23:45,866 --> 00:23:49,266
你看它就开始对这个policy进行复制

739
00:23:49,266 --> 00:23:51,133
然后呢调用这个base一net

740
00:23:51,266 --> 00:23:52,899
进行一些基础配置

741
00:23:52,900 --> 00:23:53,700
看到了吧

742
00:23:53,900 --> 00:23:56,000
然后呢你再看啊这个是什么呢

743
00:23:56,000 --> 00:23:58,866
这个是这个是啥呢这个是

744
00:24:00,800 --> 00:24:02,933
啊如果这个任务是用户态的话

745
00:24:02,933 --> 00:24:04,133
那他还要进行一些

746
00:24:04,133 --> 00:24:05,499
用户空间的一些配置

747
00:24:05,533 --> 00:24:08,099
同时调用这个OS user task一net啊

748
00:24:08,166 --> 00:24:09,099
这个因为什么呢

749
00:24:09,100 --> 00:24:10,933
因为这个task CB1 net

750
00:24:11,533 --> 00:24:12,766
那它包括两种情况

751
00:24:12,766 --> 00:24:13,966
第一种情况是内核态的

752
00:24:13,966 --> 00:24:15,699
一种情况是用户态的

753
00:24:15,700 --> 00:24:16,800
如果是内核态的话

754
00:24:16,800 --> 00:24:18,733
他就只进行这个基础配置

755
00:24:18,766 --> 00:24:19,799
如果是用户态的话

756
00:24:19,800 --> 00:24:21,600
他就除了进行这个基础配置之外呢

757
00:24:21,600 --> 00:24:23,500
还得进行用户占的配置

758
00:24:23,500 --> 00:24:24,566
因为有两个占空间

759
00:24:24,566 --> 00:24:27,133
而这个就是对用户占空间的进行配置

760
00:24:27,133 --> 00:24:27,933
啊

761
00:24:28,333 --> 00:24:30,333
好我们因为我们现在讲的是内核

762
00:24:30,333 --> 00:24:32,099
所以我们就来看一下内核这样的配置

763
00:24:32,100 --> 00:24:32,933
他怎么办呢

764
00:24:32,933 --> 00:24:35,466
他就把从上层传递过来的这个

765
00:24:35,600 --> 00:24:37,533
根据上层传递过来这个初始化参数

766
00:24:37,533 --> 00:24:40,266
参数把这个函数所接收的这些

767
00:24:40,266 --> 00:24:42,466
那个把函数所接收的这些

768
00:24:42,766 --> 00:24:43,566
啊参数值

769
00:24:43,600 --> 00:24:45,200
还有这个函数入口弄来了啊

770
00:24:45,200 --> 00:24:46,300
在这在这个地方

771
00:24:46,300 --> 00:24:48,200
你看在这个地方已经画出来了是吧

772
00:24:48,466 --> 00:24:49,966
在这个地方啊你看有这个

773
00:24:49,966 --> 00:24:51,133
你看他首先是什么

774
00:24:51,133 --> 00:24:52,399
你看在这

775
00:24:52,566 --> 00:24:54,133
你看就是说这时候怎么样呢

776
00:24:54,133 --> 00:24:54,933
这个

777
00:24:55,566 --> 00:24:56,733
他对应的就是这个

778
00:24:56,733 --> 00:24:57,533
看到了吧

779
00:24:57,600 --> 00:24:59,066
那么另外这个这个

780
00:24:59,066 --> 00:25:00,299
这个参数对应的是谁

781
00:25:00,300 --> 00:25:01,100
就是这个

782
00:25:02,733 --> 00:25:04,499
就这个好吧

783
00:25:08,466 --> 00:25:08,933
好

784
00:25:08,933 --> 00:25:10,899
那么刚才呢我们给大家介绍的是什么

785
00:25:10,900 --> 00:25:13,533
呢就是用户现成在创建的时候啊

786
00:25:13,533 --> 00:25:14,933
不内核内核任务

787
00:25:14,966 --> 00:25:17,133
创建内核任务的时候是如何对

788
00:25:17,800 --> 00:25:19,000
内核站进行初始化的

789
00:25:19,000 --> 00:25:19,600
那现在呢

790
00:25:19,600 --> 00:25:20,566
我们再介绍一下

791
00:25:20,566 --> 00:25:22,266
用户站是怎么初始化的

792
00:25:22,266 --> 00:25:23,066
我们知道

793
00:25:23,166 --> 00:25:25,299
用户站是只有用户县城

794
00:25:25,400 --> 00:25:27,366
在创建用户县城的时候才需要

795
00:25:27,366 --> 00:25:29,133
这个才需要建立的

796
00:25:29,300 --> 00:25:31,700
那好那什么是用户县城呢

797
00:25:31,700 --> 00:25:33,466
什么时候创建用户县城呢

798
00:25:33,466 --> 00:25:34,733
那我们知道啊

799
00:25:34,766 --> 00:25:36,299
当我们执行fork的时候

800
00:25:36,300 --> 00:25:37,866
我们实际上是生成了一个

801
00:25:38,333 --> 00:25:39,166
用户进城

802
00:25:39,166 --> 00:25:39,966
用户进城

803
00:25:40,133 --> 00:25:40,666
那么

804
00:25:40,666 --> 00:25:43,266
要想让这个用户进城执行真正的代码

805
00:25:43,266 --> 00:25:45,399
我要通过exec系统调用

806
00:25:45,500 --> 00:25:48,266
那么execc系统调用实际上是什么呢

807
00:25:48,266 --> 00:25:50,466
实际上就是打开一个可制性文件啊

808
00:25:50,466 --> 00:25:51,799
把它装入到内存里啊

809
00:25:51,800 --> 00:25:52,900
把它装入到内存

810
00:25:52,900 --> 00:25:54,000
装内存哪个位置呢

811
00:25:54,000 --> 00:25:54,933
就是这个位置

812
00:25:55,566 --> 00:25:57,499
啊那我们在讲ELF文件的时候

813
00:25:57,500 --> 00:26:01,900
因为ELF文件啊ELF文件

814
00:26:02,100 --> 00:26:05,133
ELF文件ELF可格格式的文件

815
00:26:05,133 --> 00:26:05,999
是在呃

816
00:26:06,000 --> 00:26:07,566
类优那个操作系统中支持的

817
00:26:07,566 --> 00:26:08,866
可制性文件的格式

818
00:26:09,200 --> 00:26:11,200
那么所以EXEC

819
00:26:11,666 --> 00:26:13,599
EXEC系统调用干嘛呢

820
00:26:13,600 --> 00:26:17,466
首先啊将这个ELF文件从啊

821
00:26:18,333 --> 00:26:20,733
管从硬盘或者从外存装入到什么呢

822
00:26:20,733 --> 00:26:23,266
装入到内存里啊他装入到哪个位置呢

823
00:26:23,266 --> 00:26:24,999
装入到这个内存的这个位置

824
00:26:25,000 --> 00:26:25,766
那这个是什么呢

825
00:26:25,766 --> 00:26:26,899
这个是虚拟地址空间

826
00:26:26,900 --> 00:26:29,533
这个是这个进程的虚拟地址空间啊

827
00:26:29,533 --> 00:26:31,499
这个我们后面啊讲讯

828
00:26:31,700 --> 00:26:34,900
讲那个存主管理中也会也会说啊

829
00:26:35,066 --> 00:26:36,466
好那么他怎么样呢

830
00:26:36,466 --> 00:26:37,566
他首先把

831
00:26:38,266 --> 00:26:40,799
可执行文件啊装入到这个这个位置

832
00:26:40,800 --> 00:26:42,133
看到了装入到这个位置

833
00:26:42,300 --> 00:26:44,400
然后呢开始运行开始运行

834
00:26:46,200 --> 00:26:46,766
好

835
00:26:46,766 --> 00:26:48,066
那么就就执

836
00:26:48,066 --> 00:26:52,933
行这个OXEE啊又这个OSEXEC start啊

837
00:26:52,933 --> 00:26:54,533
OSEEXEC start

838
00:26:54,966 --> 00:26:56,366
那么重点看什么呢

839
00:26:56,366 --> 00:26:57,499
重点看这个位置啊

840
00:26:57,500 --> 00:26:58,100
这个位置

841
00:26:58,100 --> 00:26:59,500
那么如果装在这个位置的话

842
00:26:59,500 --> 00:27:01,133
那么大家可以想象这个是什么

843
00:27:01,133 --> 00:27:02,566
这个就是这个内函数啊

844
00:27:02,566 --> 00:27:04,866
你可以简单的认为这就是个内函数

845
00:27:05,166 --> 00:27:07,499
在虚拟地址空间中的这个位置啊

846
00:27:07,500 --> 00:27:09,166
就是这个虚拟地址空间中的位置

847
00:27:09,200 --> 00:27:11,100
你现在不知道什么虚拟空地址空间

848
00:27:11,100 --> 00:27:13,400
那你你就把他认为是内存地址就行了

849
00:27:13,466 --> 00:27:14,666
就是main的内存地址

850
00:27:14,666 --> 00:27:15,899
main函数的内存地址

851
00:27:15,966 --> 00:27:16,766
大家看

852
00:27:16,966 --> 00:27:18,366
他在这怎么样呢

853
00:27:18,366 --> 00:27:19,533
他在这个地方啊

854
00:27:19,533 --> 00:27:20,733
他在这个地方呢

855
00:27:20,766 --> 00:27:22,366
把这个啊

856
00:27:23,333 --> 00:27:23,799
看到了吧

857
00:27:23,800 --> 00:27:24,600
他把这个

858
00:27:24,966 --> 00:27:25,799
把这个may

859
00:27:25,933 --> 00:27:28,599
的地址付给了task CB的task entry

860
00:27:28,700 --> 00:27:31,133
然后呢又把用这个task entry呢

861
00:27:31,166 --> 00:27:33,699
作为参数入口参数啊

862
00:27:33,700 --> 00:27:36,600
传递给给了这个OS user task stack in need

863
00:27:36,733 --> 00:27:37,533
看到了吧

864
00:27:37,533 --> 00:27:40,566
好那我们重点来看一下这个OS task

865
00:27:40,566 --> 00:27:41,466
stack in need

866
00:27:41,966 --> 00:27:43,333
那我们看一下这个函数是什么

867
00:27:43,333 --> 00:27:43,933
这个参数什么

868
00:27:43,933 --> 00:27:45,966
这个参数就是这个面函数的地址

869
00:27:46,000 --> 00:27:47,066
这个面函数的地址

870
00:27:47,200 --> 00:27:49,500
那么啊这个context是什么呢

871
00:27:49,500 --> 00:27:50,266
这个context

872
00:27:50,266 --> 00:27:52,399
实际上就是用户占的什么呢

873
00:27:52,500 --> 00:27:54,533
用户占的这个啊

874
00:27:54,533 --> 00:27:56,266
用户占的这个这个

875
00:27:56,733 --> 00:27:56,933
当然

876
00:27:56,933 --> 00:27:58,966
用户站和什么内核站都是一样的啊

877
00:27:58,966 --> 00:28:00,166
他都会怎么样呢

878
00:28:00,166 --> 00:28:03,866
都会开始是一个task contact的结构体

879
00:28:03,933 --> 00:28:06,599
只不过啊只不过这个用户站在哪呢

880
00:28:06,600 --> 00:28:08,566
站在虚拟地质空间啊

881
00:28:08,566 --> 00:28:09,499
在用户的

882
00:28:09,700 --> 00:28:12,800
在这个用户用户任务的虚拟地质空间

883
00:28:12,800 --> 00:28:14,600
而这个内核站在用户

884
00:28:15,000 --> 00:28:16,066
用户任务的

885
00:28:16,166 --> 00:28:18,166
嗯那个内核内核空间

886
00:28:18,166 --> 00:28:19,699
内核空间啊

887
00:28:19,700 --> 00:28:20,766
那么这个是

888
00:28:20,766 --> 00:28:23,199
这个就是虚拟地址空间中的用户站

889
00:28:23,200 --> 00:28:25,133
用户站那么你注意他在怎么样

890
00:28:25,133 --> 00:28:26,666
你看他在这个地方呢

891
00:28:26,733 --> 00:28:29,366
把这个内函数的指针啊放到这个task

892
00:28:29,366 --> 00:28:31,399
安锤了那么在返回的时候啊

893
00:28:31,400 --> 00:28:32,933
在返回的时候内核站

894
00:28:33,666 --> 00:28:34,866
啊内核太怎么样呢

895
00:28:34,866 --> 00:28:36,733
他只会怎么样返回到哪呢

896
00:28:36,733 --> 00:28:37,533
他返

897
00:28:38,500 --> 00:28:40,900
内核战只会返回到什么呢

898
00:28:41,100 --> 00:28:43,366
就是说当系统调换返回的时候

899
00:28:43,366 --> 00:28:45,066
他只能返回啊进行切换

900
00:28:45,066 --> 00:28:47,566
返回到那个就是被中断的那个位置

901
00:28:47,700 --> 00:28:49,133
然后呢怎么样呢

902
00:28:49,133 --> 00:28:50,699
返回到用户态的时候啊

903
00:28:50,700 --> 00:28:51,666
返回到用户态的时候

904
00:28:51,666 --> 00:28:53,999
就根据用户占的占底去返回

905
00:28:54,000 --> 00:28:56,500
而这时候用户占的占底是这个面函数

906
00:28:56,500 --> 00:28:58,466
所以就开始执行这个面函数了

907
00:28:58,533 --> 00:28:59,333
啊

908
00:29:00,000 --> 00:29:02,100
那么注意看这里的内容

909
00:29:02,100 --> 00:29:03,766
用户站的初始化时

910
00:29:03,800 --> 00:29:05,166
用户站的初始化时

911
00:29:05,166 --> 00:29:07,299
修改了任务的上下文内容

912
00:29:07,766 --> 00:29:10,166
那么任务的上下文内容呢

913
00:29:10,166 --> 00:29:12,333
是始终保存在内核战中的

914
00:29:12,466 --> 00:29:14,266
那注意的这个不要搞混了啊

915
00:29:14,266 --> 00:29:16,666
UOS user task Stack need呢

916
00:29:16,666 --> 00:29:18,799
只是修改上下文地址中的内容

917
00:29:18,966 --> 00:29:20,866
context sp的值被修改了

918
00:29:20,866 --> 00:29:23,366
这意味着任务被调度后啊

919
00:29:23,366 --> 00:29:25,166
首先是恢复上下文

920
00:29:25,666 --> 00:29:26,266
啊

921
00:29:26,266 --> 00:29:28,999
那么既要重置SP计算器的值

922
00:29:29,066 --> 00:29:31,266
SP的值呢变为context SP

923
00:29:31,566 --> 00:29:32,199
此时呢

924
00:29:32,200 --> 00:29:35,966
就指向了用户占空间运行的context PC

925
00:29:36,266 --> 00:29:37,466
那么也被改变了

926
00:29:37,466 --> 00:29:41,066
这意味着啊入口函数也修改了啊

927
00:29:41,066 --> 00:29:41,866
那么这时候呢

928
00:29:41,866 --> 00:29:42,566
这个

929
00:29:42,566 --> 00:29:45,266
这个这个就开始内函数就开始运行了

930
00:29:46,966 --> 00:29:49,199
那么这些函数这些东西是什么呢

931
00:29:49,200 --> 00:29:52,733
就是说关于这个同步与互斥的啊

932
00:29:53,333 --> 00:29:53,766
啊

933
00:29:53,766 --> 00:29:55,766
资源是有限的CPU也是资源

934
00:29:55,766 --> 00:29:58,199
除了CPU还有其他设备那么护

935
00:29:58,200 --> 00:30:00,766
斥量能解决这个问题啊

936
00:30:00,766 --> 00:30:03,933
办事前呢先拿锁拿到了锁执行

937
00:30:04,466 --> 00:30:06,766
拿到了拿到了锁再执行

938
00:30:06,800 --> 00:30:08,466
没有拿到锁就需要排队

939
00:30:08,666 --> 00:30:10,466
在lock list上排队

940
00:30:10,466 --> 00:30:12,733
那注意lock list呢是一个双向列表

941
00:30:13,300 --> 00:30:16,000
啊他是内核最重要的结构体

942
00:30:16,000 --> 00:30:19,166
上面挂的是等待等所的任务

943
00:30:19,166 --> 00:30:20,799
护士量解决是

944
00:30:21,066 --> 00:30:21,533
护士量

945
00:30:21,533 --> 00:30:24,366
解决任务间资源紧张的竞争性问题

946
00:30:24,766 --> 00:30:28,566
另外一个是用于任务的同步的信号量

947
00:30:28,600 --> 00:30:31,666
那么任务和任务之间是会有关联的

948
00:30:31,700 --> 00:30:32,800
那么现实生活中

949
00:30:32,800 --> 00:30:36,700
公司的a d用户之间本身有业务往来

950
00:30:36,700 --> 00:30:37,500
是正

951
00:30:38,000 --> 00:30:40,333
业务往来的业务往来

952
00:30:40,366 --> 00:30:43,199
那么CPU在帮b做作业的时候呢

953
00:30:43,200 --> 00:30:44,966
发现前置条件是需要a

954
00:30:45,300 --> 00:30:47,066
完成某项任务才能进行

955
00:30:47,066 --> 00:30:51,099
这时b就需要主动让出CPU先办完a事

956
00:30:51,400 --> 00:30:52,266
a的事啊

957
00:30:52,266 --> 00:30:52,733
信号量

958
00:30:52,733 --> 00:30:54,966
就来解决任务间的这个同步问题

959
00:30:55,100 --> 00:30:55,333
啊

960
00:30:55,333 --> 00:30:56,533
同步和护士啊

961
00:30:57,166 --> 00:30:59,399
那么这个是关于任务的一些东西啊

962
00:30:59,400 --> 00:31:01,800
这些这些这些这些参数啊

963
00:31:02,333 --> 00:31:02,566
啊

964
00:31:02,566 --> 00:31:02,933
这些东西

965
00:31:02,933 --> 00:31:04,966
我们前面已经给大家介绍过了啊

966
00:31:06,133 --> 00:31:06,933
那么

967
00:31:07,666 --> 00:31:08,366
那么这个呢

968
00:31:08,366 --> 00:31:10,766
是关于这个任务之间互相进行

969
00:31:10,766 --> 00:31:11,933
互相通信的啊

970
00:31:11,933 --> 00:31:15,299
那么这个很重要解决任务间通信问题

971
00:31:15,933 --> 00:31:19,166
要知道进城负责的是资源的管理功能

972
00:31:19,366 --> 00:31:22,599
就是进城并不负责内容的生产和消费

973
00:31:22,800 --> 00:31:25,133
他只负责保管啊

974
00:31:25,133 --> 00:31:27,333
他只负责管理确保你的内容

975
00:31:27,400 --> 00:31:29,200
到达率的和完整性

976
00:31:29,200 --> 00:31:31,466
那生产者和消费者始终是任务

977
00:31:31,733 --> 00:31:34,699
那么light IPC是鸿蒙专用专有的

978
00:31:35,000 --> 00:31:36,900
通信消息队列实现

979
00:31:37,066 --> 00:31:39,733
那么简单说它是基于文件的

980
00:31:39,766 --> 00:31:43,366
而传统的IPC消息是基于内存的

981
00:31:46,733 --> 00:31:47,866
那么最后呢是一

982
00:31:47,866 --> 00:31:49,166
些辅助的啊辅助的

983
00:31:49,166 --> 00:31:50,799
那么比如说啊这个

984
00:31:50,800 --> 00:31:53,000
这个就是关于这个思索检测的啊

985
00:31:53,000 --> 00:31:55,200
那这是调度的一些统计啊

986
00:31:55,200 --> 00:31:56,500
统统计的东西

987
00:31:57,933 --> 00:31:59,266
好那么

988
00:32:00,100 --> 00:32:01,066
第一部分啊

989
00:32:01,066 --> 00:32:03,533
任务的TCB我们就给大家说到这里

