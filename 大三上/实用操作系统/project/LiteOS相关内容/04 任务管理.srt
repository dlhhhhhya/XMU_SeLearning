1
00:00:00,900 --> 00:00:02,200
各位同学大家好

2
00:00:02,200 --> 00:00:04,066
那下面我们继续介绍

3
00:00:04,066 --> 00:00:06,733
任务管理和任务状态切换

4
00:00:09,666 --> 00:00:11,566
首先我们来介绍任务管理

5
00:00:11,566 --> 00:00:13,199
那么任务管理主要包括

6
00:00:13,266 --> 00:00:15,399
任务任务时的初始化

7
00:00:15,533 --> 00:00:17,599
以及两个基本操作

8
00:00:17,733 --> 00:00:19,933
分别是任务进入就绪队列

9
00:00:19,933 --> 00:00:22,166
和任务从就绪队列中移除

10
00:00:22,766 --> 00:00:23,999
首先我们看一下

11
00:00:24,566 --> 00:00:25,866
任务池的初始化

12
00:00:25,866 --> 00:00:28,599
如此多的任务怎么管理和执行

13
00:00:29,066 --> 00:00:31,466
管理靠任务池和就绪队列

14
00:00:31,733 --> 00:00:33,966
执行靠调度算法

15
00:00:34,166 --> 00:00:36,966
首先我们来看一下任务池的初始化

16
00:00:37,166 --> 00:00:40,466
那么它的它是OS task以腻的函数

17
00:00:41,100 --> 00:00:42,266
那我们来看一下

18
00:00:43,300 --> 00:00:47,300
那么首先g task Max number等于什么呢

19
00:00:47,300 --> 00:00:50,666
等于128 那么也就是说这个是1128

20
00:00:50,666 --> 00:00:54,866
也就是Letos中最多支持128个任务啊

21
00:00:54,866 --> 00:00:57,566
那我们前面知道它最多支持64个进程

22
00:00:57,566 --> 00:00:58,766
128个任务

23
00:00:59,466 --> 00:01:00,466
那么这个呢

24
00:01:00,466 --> 00:01:03,199
是计算需要分配的总内存的大小

25
00:01:03,200 --> 00:01:04,000
看到了吧

26
00:01:04,266 --> 00:01:07,866
啊这乘以这是lost lost TOSS CP的大小

27
00:01:07,966 --> 00:01:09,866
然后呢就从这个内存池中啊

28
00:01:09,866 --> 00:01:11,699
内存池中分配这么多的

29
00:01:11,966 --> 00:01:12,999
这么一个数组

30
00:01:13,100 --> 00:01:14,533
这是一个很大的数组

31
00:01:14,966 --> 00:01:15,899
然后呢

32
00:01:16,466 --> 00:01:18,599
然后如果分配不成功的返回错误

33
00:01:18,666 --> 00:01:19,166
否则呢

34
00:01:19,166 --> 00:01:21,966
对这个数组的所有内容进行初始化

35
00:01:21,966 --> 00:01:23,333
全部清除为0

36
00:01:23,666 --> 00:01:25,766
然后呢然后呢

37
00:01:25,766 --> 00:01:26,666
组织成列表

38
00:01:26,666 --> 00:01:27,899
看到了组织成列表

39
00:01:28,266 --> 00:01:29,299
组织成两个列表

40
00:01:29,300 --> 00:01:32,300
一个是free task一个是recycle list

41
00:01:32,866 --> 00:01:33,499
1这个是什么

42
00:01:33,500 --> 00:01:35,066
就是空弦踏斯的列表

43
00:01:35,066 --> 00:01:35,933
那当前怎么样

44
00:01:35,933 --> 00:01:37,166
所有的任务啊

45
00:01:37,166 --> 00:01:38,399
所有这128个任务

46
00:01:38,400 --> 00:01:40,366
全都任务的TCB都是空弦的

47
00:01:40,366 --> 00:01:41,266
所以都在这里

48
00:01:41,333 --> 00:01:42,466
而这个列表是空的

49
00:01:42,466 --> 00:01:42,999
看到了吗

50
00:01:43,000 --> 00:01:44,333
那这就是组织个列表

51
00:01:45,466 --> 00:01:47,499
然后呢对调度器进行初始化

52
00:01:50,933 --> 00:01:54,099
那么当一个任务刚刚被建立的时候

53
00:01:54,100 --> 00:01:56,366
任何或者一个任务的时间片

54
00:01:56,366 --> 00:01:58,066
耗尽等情况发生时

55
00:01:58,066 --> 00:02:00,366
该任务将放弃CPU的使用权

56
00:02:00,700 --> 00:02:03,866
其状态由running状态改变为ready状态

57
00:02:03,866 --> 00:02:07,666
此时需要将该任务的TCB啊

58
00:02:07,666 --> 00:02:08,766
任务的task CB

59
00:02:08,766 --> 00:02:11,366
插入到Letos系统的就绪队列中

60
00:02:11,566 --> 00:02:13,599
这个称这个操作称为入队

61
00:02:13,900 --> 00:02:17,066
其时间函数为HPF引q

62
00:02:17,500 --> 00:02:20,900
如果一个任务由调度器的调度

63
00:02:21,200 --> 00:02:23,933
或其他原因如收到了q信号等

64
00:02:24,000 --> 00:02:25,333
由ready状态

65
00:02:25,900 --> 00:02:27,466
转换为running状态

66
00:02:29,166 --> 00:02:30,899
当然这个这个这个是调度啊

67
00:02:30,900 --> 00:02:32,133
说的是第一种情况

68
00:02:32,366 --> 00:02:33,333
那么其

69
00:02:33,933 --> 00:02:38,333
taskcb需要从Letos 4的就绪队列中移除

70
00:02:38,733 --> 00:02:40,933
那么这个操作叫做出对

71
00:02:40,933 --> 00:02:43,599
其实践函数为hpfdq

72
00:02:43,866 --> 00:02:45,299
下面我们首先来看

73
00:02:45,566 --> 00:02:48,066
Letos系统中的旧序队列的数结构

74
00:02:48,066 --> 00:02:52,166
然后呢再介绍HPF引q和HPFDQ两个函数

75
00:02:53,333 --> 00:02:55,133
首先我们来看一下这个

76
00:02:55,166 --> 00:02:56,099
这个数据结构啊

77
00:02:56,100 --> 00:02:56,933
这数据结构

78
00:02:56,966 --> 00:02:57,766
这数据结构

79
00:02:57,966 --> 00:03:00,133
那么首先最主要的这个数据结构

80
00:03:00,133 --> 00:03:00,933
第一个数这个

81
00:03:00,933 --> 00:03:02,499
这是第一个数据结构啊

82
00:03:02,500 --> 00:03:04,066
第一个数据结构叫做什么呢

83
00:03:04,066 --> 00:03:05,733
就是说叫做

84
00:03:06,366 --> 00:03:08,966
啊叫做global schedule run q啊

85
00:03:08,966 --> 00:03:10,333
那么它是有几个呢

86
00:03:10,333 --> 00:03:12,866
就是有car number有CPU这么number number

87
00:03:13,100 --> 00:03:15,966
大家看每个CPU都有一个schedule

88
00:03:15,966 --> 00:03:18,533
schedule run q类型的结构体

89
00:03:18,866 --> 00:03:20,533
那么这个结构题保存在这个结

90
00:03:20,733 --> 00:03:21,566
全局数组中

91
00:03:21,566 --> 00:03:23,699
也就是说每一个CPU啊都有一个

92
00:03:24,066 --> 00:03:25,266
都有一个run q啊

93
00:03:25,266 --> 00:03:26,066
都有一个run q

94
00:03:26,133 --> 00:03:27,566
那这个run q是什么东西呢

95
00:03:27,566 --> 00:03:30,333
我们来看一下啊首先有个time out q

96
00:03:30,733 --> 00:03:31,999
那Timod q是什么玩

97
00:03:32,000 --> 00:03:34,133
意呢这个Timod q就是啊

98
00:03:34,166 --> 00:03:35,999
你从这个名字上你就可可以知道

99
00:03:36,000 --> 00:03:36,700
这个是什么呢

100
00:03:36,700 --> 00:03:38,466
就是超时队列啊

101
00:03:38,466 --> 00:03:39,266
超时队列

102
00:03:39,300 --> 00:03:40,966
那我给你举个例子啊

103
00:03:40,966 --> 00:03:42,333
比如说我现在呢

104
00:03:42,333 --> 00:03:43,333
就是有一个线

105
00:03:43,333 --> 00:03:44,933
有一个任务在等待一个锁

106
00:03:45,400 --> 00:03:46,200
啊等待一个锁

107
00:03:46,200 --> 00:03:47,266
那这个等待锁呢

108
00:03:47,266 --> 00:03:48,499
我并不是说无限期等待

109
00:03:48,500 --> 00:03:50,133
我就等待一个时间段啊

110
00:03:50,133 --> 00:03:51,566
如果这个时间段超了

111
00:03:51,700 --> 00:03:54,066
我拿不到这锁我也我也我也怎么样

112
00:03:54,066 --> 00:03:56,199
我也唤醒我也把这个任务唤醒

113
00:03:56,366 --> 00:03:58,366
所以这样的这样的定时任务

114
00:03:58,366 --> 00:03:59,899
再比如说我设置个闹铃啊

115
00:03:59,900 --> 00:04:01,533
这个闹铃也是个定时任务

116
00:04:01,666 --> 00:04:02,999
所有的这些定时任务啊

117
00:04:03,000 --> 00:04:06,100
都被插入到这个time out q里啊

118
00:04:06,100 --> 00:04:07,066
time out q里

119
00:04:07,133 --> 00:04:08,999
那第二个是一个什么

120
00:04:09,066 --> 00:04:10,199
第二个是一个什么呢

121
00:04:10,200 --> 00:04:12,066
就是叫做HPF run q

122
00:04:12,166 --> 00:04:14,666
这个HPF run q才是真正的就绪队列

123
00:04:14,666 --> 00:04:16,766
我们往里插的时候我们就往这个插

124
00:04:17,166 --> 00:04:18,399
啊往这这个离场

125
00:04:18,566 --> 00:04:20,966
那么这这个这个数据结构离场

126
00:04:20,966 --> 00:04:22,299
response time是什么呢

127
00:04:22,300 --> 00:04:23,200
就是response time

128
00:04:23,200 --> 00:04:24,766
后面我们讲进程调度的时候

129
00:04:24,766 --> 00:04:25,766
我们知道这个是什么

130
00:04:25,766 --> 00:04:28,466
就是说这个啊time out q啊

131
00:04:28,466 --> 00:04:31,333
这个这个超时队列的什么超时时间啊

132
00:04:31,333 --> 00:04:32,133
超时时间

133
00:04:32,200 --> 00:04:33,000
超时时间

134
00:04:33,066 --> 00:04:35,066
那最早的这也就也就是说

135
00:04:35,133 --> 00:04:36,199
time out q和什么呢

136
00:04:36,200 --> 00:04:39,066
和这个和这个啊和这个run q啊

137
00:04:39,100 --> 00:04:41,100
这两个队列里哪个先早

138
00:04:41,200 --> 00:04:43,500
那么这就是response time就是谁啊

139
00:04:43,500 --> 00:04:45,166
它主要指的是这个啊它俩

140
00:04:45,533 --> 00:04:47,699
这两个队列里的任务谁的超时任务

141
00:04:47,700 --> 00:04:50,500
为什么你会说因为因为run q里超时

142
00:04:50,500 --> 00:04:51,600
是不是也有一个时间

143
00:04:51,600 --> 00:04:52,333
时间片调度

144
00:04:52,333 --> 00:04:52,866
每个任务都

145
00:04:52,866 --> 00:04:53,999
有个时间片对吧

146
00:04:54,066 --> 00:04:55,933
啊那下一次调度的时间片

147
00:04:56,000 --> 00:04:57,733
和这个下一个超时队列中

148
00:04:57,733 --> 00:04:59,299
任务超时的时间谁短

149
00:04:59,466 --> 00:05:00,933
这个response time就是谁

150
00:05:01,133 --> 00:05:02,366
那response ID是什么呢

151
00:05:02,366 --> 00:05:05,299
就是区分到底这个response time是谁的

152
00:05:05,300 --> 00:05:07,300
如果是time outq里的话

153
00:05:07,300 --> 00:05:10,533
那么这个response ID就是一个无效值

154
00:05:10,600 --> 00:05:12,966
如果是来自于这个这个run q里的话

155
00:05:12,966 --> 00:05:15,899
那么这个response ID就是这个run q的这个

156
00:05:15,900 --> 00:05:17,700
一个一个任务task ID

157
00:05:17,700 --> 00:05:18,500
啊

158
00:05:19,133 --> 00:05:20,499
那么idotask ID是什么呢

159
00:05:20,500 --> 00:05:21,700
就是我们知道

160
00:05:21,766 --> 00:05:23,066
这个schedule run q

161
00:05:23,066 --> 00:05:25,199
是是是每一个CPU都有一个的

162
00:05:25,266 --> 00:05:27,599
所以这个idotask就是这个

163
00:05:27,866 --> 00:05:28,699
当这个任务

164
00:05:28,700 --> 00:05:29,500
当这个CPU

165
00:05:29,500 --> 00:05:30,800
上没有任务可以运行的时候

166
00:05:30,800 --> 00:05:32,900
也就是说当这个run q为空的时候

167
00:05:32,900 --> 00:05:35,866
它要运行的这个任务叫做踏idotask

168
00:05:36,200 --> 00:05:37,866
那task low CON的是什么呢

169
00:05:37,866 --> 00:05:39,866
这个这个就是说一些统计啊

170
00:05:39,866 --> 00:05:40,866
这是一个统计

171
00:05:40,900 --> 00:05:42,133
统计量啊统计量

172
00:05:42,500 --> 00:05:43,800
那么这个是什么呢

173
00:05:43,800 --> 00:05:44,666
schedule flag

174
00:05:44,666 --> 00:05:45,766
schedule flag是什么呢

175
00:05:45,766 --> 00:05:46,666
就是说啊

176
00:05:46,966 --> 00:05:48,699
调我们在讲调度的时候啊

177
00:05:48,700 --> 00:05:50,100
当我们在讲调度的时候

178
00:05:50,100 --> 00:05:51,166
比如说现在呢

179
00:05:51,166 --> 00:05:53,599
我们发现检测发现已经超时了

180
00:05:53,966 --> 00:05:54,799
啊已经超时了

181
00:05:54,800 --> 00:05:57,100
就是说这个当前这个时间片

182
00:05:57,533 --> 00:05:58,699
就是在超时队列中

183
00:05:58,700 --> 00:05:59,933
已经有超时的队列了

184
00:05:59,933 --> 00:06:00,866
所以他就怎么样

185
00:06:00,866 --> 00:06:03,166
把这个flag有一个need rescued啊

186
00:06:03,166 --> 00:06:04,999
有一个这么一个标志它就会指一

187
00:06:05,000 --> 00:06:07,100
那这样的话再进行嗯

188
00:06:07,100 --> 00:06:07,533
就是说

189
00:06:07,533 --> 00:06:09,899
比如说内核态向用户态返回的时候

190
00:06:10,000 --> 00:06:12,133
那么就会检查这个flag

191
00:06:12,200 --> 00:06:14,766
有没有这个need resguide标记啊

192
00:06:14,766 --> 00:06:16,333
还有就是比如说有发生了一些

193
00:06:16,333 --> 00:06:16,799
事件

194
00:06:16,800 --> 00:06:19,533
需要重新计算这个response time的时候

195
00:06:19,800 --> 00:06:21,500
他也要设置这个标记

196
00:06:21,533 --> 00:06:23,299
从而重新计算这个response

197
00:06:23,300 --> 00:06:24,866
比如说我有一个新的time out的任务

198
00:06:24,866 --> 00:06:26,499
插入到这个time out的队列里

199
00:06:26,500 --> 00:06:28,500
那这时候我就需要把这个标记纸

200
00:06:28,566 --> 00:06:30,366
把这个相应的标记纸纸上

201
00:06:30,700 --> 00:06:31,066
这样的话

202
00:06:31,066 --> 00:06:33,266
他就会怎么样重新计算这个response time

203
00:06:33,333 --> 00:06:33,999
所有这些东西

204
00:06:34,000 --> 00:06:35,700
我们在后面讲调度的时候

205
00:06:35,700 --> 00:06:36,966
会给大家详细介绍

206
00:06:36,966 --> 00:06:39,733
那我们这次呢主要看这个HPF run q

207
00:06:39,933 --> 00:06:41,199
那我们看HPF run q

208
00:06:41,200 --> 00:06:42,133
其实我们在前面讲

209
00:06:42,133 --> 00:06:43,099
这个优先级队列的时候

210
00:06:43,100 --> 00:06:44,133
已经讲过了啊

211
00:06:44,133 --> 00:06:44,999
你看它是一个什么呢

212
00:06:45,000 --> 00:06:46,700
它是有一个位图beat map

213
00:06:46,800 --> 00:06:47,266
然后呢

214
00:06:47,266 --> 00:06:49,399
又有一个32个优先级的这么一个run

215
00:06:49,400 --> 00:06:51,200
q list那么在这个地方呢

216
00:06:51,200 --> 00:06:54,200
你看啊这个run q list又是一个SPFQ

217
00:06:54,366 --> 00:06:56,466
那这个SPFQ呢又是什么呢

218
00:06:56,466 --> 00:06:59,533
又是一个数组又是一个位列速度

219
00:06:59,600 --> 00:07:01,400
那现在为什么会有这个速度

220
00:07:01,400 --> 00:07:03,900
就这个为什么又是一个速度呢

221
00:07:03,900 --> 00:07:04,733
是因为啊

222
00:07:04,733 --> 00:07:05,699
在运行的时候

223
00:07:05,700 --> 00:07:07,533
这个任务的优先级会改变

224
00:07:07,533 --> 00:07:07,933
那这时

225
00:07:07,933 --> 00:07:09,933
我们会涉及到一个优先级反转的概念

226
00:07:09,933 --> 00:07:11,766
啊优先级反转概念这个东西

227
00:07:11,766 --> 00:07:13,733
我们再讲这个就是

228
00:07:14,100 --> 00:07:15,500
同步与互斥的时候啊

229
00:07:15,500 --> 00:07:16,733
在讲同步与互斥的时候

230
00:07:16,733 --> 00:07:18,266
我们会讲到这一点啊

231
00:07:18,266 --> 00:07:19,866
所以你在这里就记住就可以了

232
00:07:19,866 --> 00:07:21,666
在这个地方我们需要一个beat map啊

233
00:07:21,666 --> 00:07:22,533
需要一个beat map

234
00:07:22,800 --> 00:07:25,733
然后呢这个地方是已就绪的任务数

235
00:07:25,800 --> 00:07:26,766
那这个是什么呢

236
00:07:26,766 --> 00:07:28,699
就是说每个优先级已就绪的任务数

237
00:07:28,700 --> 00:07:31,500
这个是真正的每个优先级上的队列

238
00:07:31,500 --> 00:07:33,366
我们就在这个队列任务里去找

239
00:07:34,700 --> 00:07:36,933
啊所以这就是整个这么一个啊

240
00:07:36,933 --> 00:07:40,066
你看看sky two run q结构体中的HPF run q

241
00:07:40,066 --> 00:07:42,866
指针指向一个HPF runq类型的结构体

242
00:07:43,166 --> 00:07:46,499
那么HPF runq结构体中包含了一个q beatmap

243
00:07:46,600 --> 00:07:49,466
表示32个优先级中哪个

244
00:07:49,800 --> 00:07:53,000
哪个的旧区队列不空HPFQ

245
00:07:53,900 --> 00:07:55,800
类型的数组q list

246
00:07:56,200 --> 00:07:57,200
的每个成员

247
00:07:57,200 --> 00:07:58,966
用来具体存放啊

248
00:07:58,966 --> 00:08:00,733
存放某个优先级的就绪队列

249
00:08:00,866 --> 00:08:01,699
具体的

250
00:08:01,733 --> 00:08:05,699
这些就绪任务被挂载到了这个HPFQ的

251
00:08:05,800 --> 00:08:07,533
priority q list的这个

252
00:08:07,966 --> 00:08:10,199
数组数组的某一个双向列表上

253
00:08:10,266 --> 00:08:11,366
那为什么会这样呢

254
00:08:11,366 --> 00:08:12,599
为什么这这是一个双向列表

255
00:08:12,600 --> 00:08:13,466
这也是个双向列表

256
00:08:13,466 --> 00:08:15,266
就是因为啊进程啊

257
00:08:15,266 --> 00:08:17,133
进程在运行不任务在运行的时候

258
00:08:17,133 --> 00:08:18,666
它的优先机可能会变啊

259
00:08:18,666 --> 00:08:20,299
它有个原始优先机

260
00:08:20,300 --> 00:08:21,566
在我们这里叫做什么呢

261
00:08:21,566 --> 00:08:22,866
叫做base prioritate

262
00:08:22,866 --> 00:08:25,066
还有一个prioritate这个prioritate是什么呢

263
00:08:25,066 --> 00:08:26,666
就是说运行的优先机

264
00:08:26,866 --> 00:08:28,366
他这可能会变好吧

265
00:08:28,366 --> 00:08:29,166
嗯

266
00:08:29,900 --> 00:08:32,133
好我们来看一下这个入队操作啊

267
00:08:32,133 --> 00:08:32,933
入队操作

268
00:08:33,400 --> 00:08:36,966
首先是入队操作实际上就是这个HPF INQ

269
00:08:37,133 --> 00:08:39,733
那么这个就是说准备进入的这个run q

270
00:08:39,733 --> 00:08:41,533
这个就是准备入队的这个task

271
00:08:41,533 --> 00:08:42,499
CB结构体

272
00:08:42,866 --> 00:08:44,499
那么既然他要入队的话

273
00:08:44,500 --> 00:08:45,533
首先这个他CB

274
00:08:45,533 --> 00:08:47,766
必须要判断他是不是运行态的

275
00:08:47,800 --> 00:08:49,466
如果他不是运行态的话怎么样

276
00:08:49,466 --> 00:08:50,399
那就怎么样

277
00:08:50,500 --> 00:08:52,933
你看如果他啊如果这个

278
00:08:53,366 --> 00:08:55,966
成立的话就表示说什么表示他什么

279
00:08:56,100 --> 00:08:58,000
如果当前任务呢

280
00:08:58,000 --> 00:08:59,566
我看一下如果当前任务呢

281
00:08:59,566 --> 00:09:00,999
不处于就绪状态

282
00:09:01,166 --> 00:09:04,533
那么就会获取调度经历了几个周期并

283
00:09:04,533 --> 00:09:05,866
更新啊开始

284
00:09:06,066 --> 00:09:06,933
开始时间

285
00:09:07,466 --> 00:09:08,266
那么

286
00:09:08,266 --> 00:09:10,733
否则的话你看啊这是debug啊这debug

287
00:09:10,733 --> 00:09:13,533
这debug啊这个debug啊这debug

288
00:09:13,900 --> 00:09:15,733
嗯该对debug啊这个是

289
00:09:16,600 --> 00:09:19,266
这个是啊这个是如果啊当前队列啊

290
00:09:19,266 --> 00:09:20,533
我知道了我明白了

291
00:09:20,533 --> 00:09:21,333
这是啥意思呢

292
00:09:21,333 --> 00:09:22,799
就是说啊你看这是什么

293
00:09:22,800 --> 00:09:23,733
in q是什么意思呢

294
00:09:23,733 --> 00:09:25,499
in q实际上就是

295
00:09:26,133 --> 00:09:29,133
把一个任务由是啊转入到一个就绪态

296
00:09:29,133 --> 00:09:29,899
大家想一想啊

297
00:09:29,900 --> 00:09:32,300
如果一个任务现在是运行态的话

298
00:09:32,300 --> 00:09:34,533
他进入就比如说他的时间片到了

299
00:09:34,533 --> 00:09:37,199
那么他就会由运行态变成就绪态对吧

300
00:09:37,200 --> 00:09:40,500
所以你看他首先判断一下当前任务

301
00:09:42,166 --> 00:09:45,733
啊当前任务啊当前任务是不是嗯

302
00:09:46,000 --> 00:09:48,600
如果当前任务是运行态的话啊

303
00:09:48,866 --> 00:09:51,366
如果当前任务是运行态的话就不执行

304
00:09:51,366 --> 00:09:52,566
如果当前任务不是

305
00:09:52,900 --> 00:09:54,166
运行态的话就执行

306
00:09:54,200 --> 00:09:55,166
那么它就啊

307
00:09:55,166 --> 00:09:57,533
如果当前任务不是运行态的话

308
00:09:57,533 --> 00:09:58,099
就执行它

309
00:09:58,100 --> 00:09:58,600
怎么样

310
00:09:58,600 --> 00:10:01,733
task start time表示它进入就绪队列的时间

311
00:10:01,733 --> 00:10:02,299
看到了吧

312
00:10:02,300 --> 00:10:03,866
表示它进入就绪队列的时间

313
00:10:04,066 --> 00:10:05,266
然后呢就怎么样呢

314
00:10:05,266 --> 00:10:08,299
就把这个task CB调用这个这个函数啊

315
00:10:08,300 --> 00:10:09,933
把它插入到这个运行队列里

316
00:10:09,933 --> 00:10:10,666
看到了吗

317
00:10:10,666 --> 00:10:12,466
那这个函数我们在前面讲

318
00:10:12,500 --> 00:10:13,500
已经讲过了啊

319
00:10:13,500 --> 00:10:15,266
这个函数我们在前面已经讲过了

320
00:10:15,666 --> 00:10:17,299
好那在这我们再简单说一下啊

321
00:10:17,300 --> 00:10:18,933
在这个地方我们再说一下啊

322
00:10:18,933 --> 00:10:22,533
首先大家看一下啊首先是获得什么呢

323
00:10:22,533 --> 00:10:23,666
获得这个调度域

324
00:10:23,766 --> 00:10:25,866
然后然为什么获得调度域呢

325
00:10:25,866 --> 00:10:28,199
因为调度我们前面说过了有两种

326
00:10:28,533 --> 00:10:29,133
两种方法

327
00:10:29,133 --> 00:10:31,799
一种是rundrobe啊就时间片轮转

328
00:10:31,800 --> 00:10:32,566
一种是什么呢

329
00:10:32,566 --> 00:10:34,599
一种是这个先进先出

330
00:10:34,600 --> 00:10:36,800
啊我们给主要看一下这时间片轮转

331
00:10:36,933 --> 00:10:38,699
那时间片轮转指的是什么意思呢

332
00:10:38,700 --> 00:10:41,000
你看啊在这儿有两个if

333
00:10:41,066 --> 00:10:42,399
if啊和else

334
00:10:42,400 --> 00:10:43,900
if和else那这是什么意思呢

335
00:10:43,900 --> 00:10:44,966
就是说if什么呢

336
00:10:44,966 --> 00:10:48,399
task CB timeslides大于这个

337
00:10:48,400 --> 00:10:48,900
这是什么呢

338
00:10:48,900 --> 00:10:50,733
是最小时间片啊最小时间片

339
00:10:50,733 --> 00:10:52,266
最小时间片好像是5毫秒

340
00:10:52,266 --> 00:10:54,199
大家可以自己看一下这是什么

341
00:10:54,300 --> 00:10:55,100
这表示什么意思呢

342
00:10:55,100 --> 00:10:58,300
就是说如果一个当前任务啊当前

343
00:10:58,300 --> 00:10:59,966
比如现在一个任务正在运行

344
00:11:00,100 --> 00:11:02,000
如果当前任务运行的时候

345
00:11:02,000 --> 00:11:03,533
他被插入到就绪队列里

346
00:11:03,533 --> 00:11:04,399
我要分情况

347
00:11:04,533 --> 00:11:05,266
那什么情况

348
00:11:05,266 --> 00:11:05,966
有两种情况

349
00:11:05,966 --> 00:11:06,599
第一种情况

350
00:11:06,600 --> 00:11:09,066
就是说任务是被其他任务抢占的

351
00:11:09,166 --> 00:11:10,466
另外一种情况就是任务

352
00:11:10,466 --> 00:11:13,166
这个任务的时间片快到了啊他被

353
00:11:13,566 --> 00:11:15,499
啊就是这个时间片将近了

354
00:11:15,533 --> 00:11:17,599
已经用尽了他的时间片已经用尽了

355
00:11:17,600 --> 00:11:20,366
然后他才被插入到这个就绪队列里

356
00:11:20,366 --> 00:11:21,199
那大家想一想

357
00:11:21,200 --> 00:11:24,133
如果这个time slice大于这个最小时间片

358
00:11:24,133 --> 00:11:24,999
这是什么意思呢

359
00:11:25,000 --> 00:11:26,866
就是说这个任务怎么样啊

360
00:11:27,166 --> 00:11:27,866
是被抢占的

361
00:11:27,866 --> 00:11:29,366
因为他剩余的时间还很多

362
00:11:29,500 --> 00:11:29,933
所以怎么样

363
00:11:29,933 --> 00:11:31,333
如果他是被抢占的话我怎么样

364
00:11:31,333 --> 00:11:34,299
我用投插的方式把它插入到就绪队里

365
00:11:34,666 --> 00:11:35,466
LS是什么意思呢

366
00:11:35,466 --> 00:11:36,533
LS就是说这个任务

367
00:11:36,533 --> 00:11:38,499
它的时间片已经耗尽了

368
00:11:38,500 --> 00:11:39,533
才才被查入的

369
00:11:39,533 --> 00:11:39,999
所以我怎么样

370
00:11:40,000 --> 00:11:41,900
我会调用timeslides caclid

371
00:11:41,966 --> 00:11:42,466
重新

372
00:11:42,466 --> 00:11:44,699
为这个任务计算一个新的时间片啊

373
00:11:44,700 --> 00:11:46,100
然后把这个计算出来的时间片

374
00:11:46,100 --> 00:11:48,333
付给这task CB的timeslise

375
00:11:48,333 --> 00:11:49,199
然后围查

376
00:11:49,333 --> 00:11:49,799
看到了吧

377
00:11:49,800 --> 00:11:50,866
把它围查进来

378
00:11:51,300 --> 00:11:51,866
看到了吧

379
00:11:51,866 --> 00:11:53,466
那这个就是整个这个

380
00:11:53,533 --> 00:11:54,333
然后怎么样呢大

381
00:11:54,333 --> 00:11:56,766
家看既然既然他已经是什么呢

382
00:11:56,933 --> 00:11:58,899
已已经被插入到队列里了

383
00:11:58,900 --> 00:11:59,666
就是队列里了

384
00:11:59,666 --> 00:12:01,666
所以怎么样呢我就怎么样把这个

385
00:12:02,400 --> 00:12:04,166
把这个它的任务设置成什么

386
00:12:04,166 --> 00:12:05,666
task status ready

387
00:12:05,700 --> 00:12:06,500
看到了吧

388
00:12:06,700 --> 00:12:08,100
那么如果它是被阻塞的话

389
00:12:08,100 --> 00:12:10,600
我就把这个阻塞task status blog去掉

390
00:12:10,666 --> 00:12:13,166
然后把它转换成task status ready

391
00:12:14,166 --> 00:12:14,966
好

392
00:12:15,700 --> 00:12:17,900
那么这个呢是优先级对列的插入

393
00:12:17,900 --> 00:12:19,366
就是操作一些beat MAF

394
00:12:19,366 --> 00:12:20,966
啊这个我们前面已经介绍了

395
00:12:20,966 --> 00:12:22,499
所以在这我们就不介绍了

396
00:12:23,766 --> 00:12:25,699
好刚才介绍的是入队操作

397
00:12:25,700 --> 00:12:29,333
现在我们来看一下出队操作叫做HPFDQ

398
00:12:29,333 --> 00:12:32,199
啊HPFDQ那出队操作是什么意思呢

399
00:12:32,200 --> 00:12:33,166
就是说当

400
00:12:33,300 --> 00:12:34,733
如果它在就绪队列里

401
00:12:34,733 --> 00:12:36,899
表示当前任务状态是就绪态

402
00:12:36,900 --> 00:12:37,466
看到了吗

403
00:12:37,466 --> 00:12:37,766
所以

404
00:12:37,766 --> 00:12:39,999
首先判断一下当前任务是不是就绪态

405
00:12:40,000 --> 00:12:41,100
如果不是就绪态就

406
00:12:41,866 --> 00:12:43,533
不进行操作就不合法了

407
00:12:43,600 --> 00:12:45,333
只有当当前任务是就绪态的时候

408
00:12:45,333 --> 00:12:46,466
才调用这个DELETE

409
00:12:46,466 --> 00:12:46,866
看到了吗

410
00:12:46,866 --> 00:12:47,533
delete

411
00:12:47,533 --> 00:12:50,533
那这个DELETE就是把这个任务这个任务

412
00:12:51,266 --> 00:12:53,199
它它用panda list它挂到这个什么

413
00:12:53,200 --> 00:12:54,800
挂到这个就绪队列里

414
00:12:54,900 --> 00:12:56,400
然后它有优先级是吧

415
00:12:56,466 --> 00:12:57,333
啊还有什么呢

416
00:12:57,333 --> 00:12:59,099
base优优先级看到了吧

417
00:12:59,100 --> 00:13:01,600
那么就把它怎么样从这个就序队列里

418
00:13:01,600 --> 00:13:03,066
这个run q里拿出来

419
00:13:03,066 --> 00:13:04,166
看到了拿出来删掉

420
00:13:04,166 --> 00:13:05,333
看到了然后呢

421
00:13:05,333 --> 00:13:07,999
同时把它的这个状态的ready给去掉

422
00:13:08,533 --> 00:13:09,066
那么这个呢

423
00:13:09,066 --> 00:13:10,099
就是我们已经

424
00:13:10,100 --> 00:13:12,166
我们已经啊给大家介绍了

425
00:13:12,166 --> 00:13:13,333
给大家介绍过

426
00:13:19,700 --> 00:13:20,933
那么给大家介绍完了

427
00:13:20,933 --> 00:13:23,366
这个入队和出队的操作之后呢

428
00:13:23,366 --> 00:13:24,366
下面我们来看一下

429
00:13:24,366 --> 00:13:26,133
这个任务状态的切换

430
00:13:27,000 --> 00:13:28,166
那么任务状态就

431
00:13:28,166 --> 00:13:30,666
是华为letter OS系统中的任务

432
00:13:30,666 --> 00:13:32,066
有多种运行状态

433
00:13:32,333 --> 00:13:33,666
系统初始化完成后

434
00:13:33,733 --> 00:13:34,699
创建的任务

435
00:13:34,700 --> 00:13:37,200
就可以在系统中竞争一定的资源

436
00:13:37,600 --> 00:13:39,133
由内核进行调度

437
00:13:39,200 --> 00:13:41,666
任务状态通常分为以下四种

438
00:13:41,866 --> 00:13:43,999
首先是以下这么五种啊

439
00:13:44,166 --> 00:13:45,199
不能说四种

440
00:13:45,333 --> 00:13:47,733
一种是ready啊就绪态

441
00:13:48,133 --> 00:13:51,066
该任务在就绪队列中只等待CPU运行

442
00:13:51,066 --> 00:13:53,133
running该任务正在执行阻塞

443
00:13:53,133 --> 00:13:55,699
blocked该任务不在就绪队列中

444
00:13:55,700 --> 00:13:57,500
包括任务被挂起

445
00:13:57,866 --> 00:13:59,299
任务被延时

446
00:13:59,300 --> 00:14:01,166
任务正在等待信号量

447
00:14:01,466 --> 00:14:04,533
读写队列或者等待事件等啊

448
00:14:04,533 --> 00:14:07,466
还有就是挂起啊该任务被用户挂起

449
00:14:07,466 --> 00:14:08,299
还有退出

450
00:14:08,500 --> 00:14:11,800
该任务运行结束等待系统回收资源

451
00:14:12,600 --> 00:14:13,800
那么这五个状态呢

452
00:14:13,800 --> 00:14:15,566
我们看一下有这么一个

453
00:14:15,566 --> 00:14:17,133
有这么一个转换关系啊

454
00:14:17,133 --> 00:14:18,333
有这么一个转换关系

455
00:14:18,533 --> 00:14:19,333
那么

456
00:14:19,500 --> 00:14:21,700
这五个状态一共有这么7种转换关系

457
00:14:21,700 --> 00:14:23,566
我们首先看第一种转

458
00:14:23,566 --> 00:14:24,899
转换关系就是就序态

459
00:14:24,900 --> 00:14:25,500
到什么呢

460
00:14:25,500 --> 00:14:26,300
到

461
00:14:26,566 --> 00:14:28,699
运行态就是这个一看到了这个一

462
00:14:28,800 --> 00:14:31,266
那么任务创建后就进入就绪态

463
00:14:31,266 --> 00:14:32,666
发生任务切换时

464
00:14:32,666 --> 00:14:35,099
就绪队列中最高优先级的任务未执行

465
00:14:35,200 --> 00:14:36,566
从而进入运行态

466
00:14:36,766 --> 00:14:37,966
但此时

467
00:14:38,100 --> 00:14:41,533
但此刻该任务依旧在就绪队列中

468
00:14:41,533 --> 00:14:42,599
这个是

469
00:14:43,666 --> 00:14:45,766
第二由运行态到就绪态

470
00:14:45,800 --> 00:14:48,900
有更高优先级任务创建或恢复后

471
00:14:49,100 --> 00:14:50,533
会发生任务调度

472
00:14:50,533 --> 00:14:52,399
此刻就绪队列中

473
00:14:52,400 --> 00:14:54,966
最高优先级任务变为运行态

474
00:14:55,166 --> 00:14:55,933
那么

475
00:14:55,933 --> 00:14:59,199
原先运行的任务由运行态变为就绪态

476
00:14:59,200 --> 00:15:00,733
依然在就绪队列中

477
00:15:01,500 --> 00:15:04,966
那么第三啊第三是由运行态到阻塞态

478
00:15:05,266 --> 00:15:07,299
正在运行的任务发生阻塞

479
00:15:07,333 --> 00:15:10,666
延时读写啊读信号量等时

480
00:15:10,866 --> 00:15:13,766
该任务会从就绪列列中删除

481
00:15:13,766 --> 00:15:16,666
任务状态由运行态变为阻塞态

482
00:15:16,866 --> 00:15:19,066
然后发生任务切换

483
00:15:19,300 --> 00:15:21,300
就绪运行啊

484
00:15:21,300 --> 00:15:24,133
运行就绪队列中优先级最高的任务

485
00:15:25,133 --> 00:15:26,366
那么第四个啊

486
00:15:26,366 --> 00:15:28,999
第四个就是主色态到就绪态

487
00:15:29,500 --> 00:15:32,966
任务也可能在就绪态时变成主色态

488
00:15:32,966 --> 00:15:37,099
此时任务状态就由就绪态变为主色态

489
00:15:37,533 --> 00:15:40,999
该任务从就绪队列中删除不参与任何

490
00:15:41,500 --> 00:15:44,700
调度直至该任务被恢复啊

491
00:15:44,700 --> 00:15:47,366
这是阻塞态到就绪态啊

492
00:15:47,366 --> 00:15:49,733
不说错啊啊

493
00:15:49,766 --> 00:15:52,166
主色态主色态到就绪态啊

494
00:15:52,466 --> 00:15:55,099
那么其他状态到挂起态啊

495
00:15:55,100 --> 00:15:56,100
这是第五

496
00:15:56,100 --> 00:15:58,100
其他状态比如说就绪态运行态

497
00:15:58,100 --> 00:15:59,700
主色态到什么呢

498
00:15:59,700 --> 00:16:00,866
到这个挂起态

499
00:16:01,166 --> 00:16:03,966
那么其他状态的任务调用挂起接口

500
00:16:04,066 --> 00:16:07,099
任务状态由其他状态变为挂起态

501
00:16:07,666 --> 00:16:10,099
那么第六是挂起态到就绪态啊

502
00:16:10,100 --> 00:16:11,333
挂起态就就绪态

503
00:16:11,733 --> 00:16:14,533
挂起的任务被恢复后啊resume调用

504
00:16:14,533 --> 00:16:18,133
此时被恢复的任务会被加入就绪队列

505
00:16:18,133 --> 00:16:20,133
从而由挂起态变为就绪态

506
00:16:20,133 --> 00:16:21,699
此时如果被

507
00:16:21,700 --> 00:16:24,300
恢复任务的优先级高于正在运行

508
00:16:24,466 --> 00:16:25,266
任务的优先级

509
00:16:25,266 --> 00:16:26,599
则会发生任务切换

510
00:16:27,133 --> 00:16:29,266
该任务由就绪态变为运行态

511
00:16:29,266 --> 00:16:31,099
最后就是其他任务到退出态

512
00:16:31,133 --> 00:16:31,966
就是第7

513
00:16:32,933 --> 00:16:34,566
运行中的任务运行结束

514
00:16:34,866 --> 00:16:36,399
或调用删除接口

515
00:16:36,666 --> 00:16:40,266
任务状态由其他状态变为退出态

516
00:16:40,566 --> 00:16:41,366
退出态

517
00:16:41,800 --> 00:16:44,566
包含任务运行结束的正常退出态

518
00:16:44,566 --> 00:16:46,133
以及invite的状态

519
00:16:47,133 --> 00:16:48,733
好那么我们下面呢

520
00:16:48,733 --> 00:16:51,766
就分别给大家介绍一下这个啊

521
00:16:51,766 --> 00:16:53,199
各种状态的变换啊

522
00:16:53,200 --> 00:16:54,600
它的这个这个函数

523
00:16:54,600 --> 00:16:56,766
比如说啊我们看我们第一个是什么呢

524
00:16:56,766 --> 00:16:57,866
就绪态的运行态

525
00:16:57,866 --> 00:16:58,966
所以我们首先给大家介绍

526
00:16:58,966 --> 00:17:00,599
就绪态的运行态是怎么做的

527
00:17:00,933 --> 00:17:02,299
那么实际上是旧渠道进行

528
00:17:02,300 --> 00:17:04,133
它实际上就是发生进程切换对吧

529
00:17:04,133 --> 00:17:04,733
发生进程切

530
00:17:04,733 --> 00:17:06,266
换那么发生进程切换

531
00:17:06,266 --> 00:17:08,933
主要是通过调用OS schedule reschedule

532
00:17:09,000 --> 00:17:11,100
来来实现reschedule

533
00:17:11,600 --> 00:17:14,100
那么大家看他主要经过了这么四步

534
00:17:14,100 --> 00:17:16,600
第一步就是获取当前CPU啊

535
00:17:16,600 --> 00:17:18,000
通过这个函数获取

536
00:17:18,600 --> 00:17:21,700
获得当前CPU的就绪队列保存在这个RQ

537
00:17:21,733 --> 00:17:22,766
这个run q中

538
00:17:23,000 --> 00:17:23,933
然后呢

539
00:17:23,966 --> 00:17:27,499
获取啊获取car OS盖Carron task和guide

540
00:17:27,500 --> 00:17:30,400
获取当前正在CPU上运行的任务的TCB

541
00:17:30,533 --> 00:17:32,333
保存在run task指针中

542
00:17:32,966 --> 00:17:35,666
获取当前CPU就需队列中

543
00:17:35,666 --> 00:17:37,466
优先级最高的任务的TCB

544
00:17:37,466 --> 00:17:38,899
保存在旧task中

545
00:17:39,100 --> 00:17:41,366
然后调用这个sky to task switch

546
00:17:41,366 --> 00:17:43,799
完成新旧任务的上下文切换

547
00:17:43,800 --> 00:17:46,400
你就可以想象这个什么TCB的切换

548
00:17:46,400 --> 00:17:47,266
那这个这个

549
00:17:47,266 --> 00:17:47,799
这个函数

550
00:17:47,800 --> 00:17:48,600
我们在后面

551
00:17:48,600 --> 00:17:50,166
给大家介绍继承调度的时候

552
00:17:50,166 --> 00:17:51,166
会详细介绍

553
00:17:51,400 --> 00:17:52,366
会介绍啊

554
00:17:52,900 --> 00:17:56,100
那么第二个是旧序态变成运行态啊

555
00:17:56,100 --> 00:17:57,400
旧序态变成运行态

556
00:17:57,533 --> 00:17:59,199
那么它是主要是通过

557
00:17:59,200 --> 00:18:03,200
OS current task get的功能啊OS

558
00:18:05,300 --> 00:18:07,266
啊就觉得啊现在下面我们怎么样呢

559
00:18:07,266 --> 00:18:09,133
就是OS current guide啊

560
00:18:09,133 --> 00:18:10,099
解释这个函数

561
00:18:10,200 --> 00:18:12,866
那么o s current task guide的功能是

562
00:18:12,866 --> 00:18:15,266
获得正在运行的任务的TCP地址

563
00:18:15,533 --> 00:18:19,133
该函数调用ARC current task guide函数

564
00:18:19,133 --> 00:18:20,499
从这个函数的名称

565
00:18:20,733 --> 00:18:22,133
也就是up开头可见

566
00:18:22,200 --> 00:18:24,966
它是一个与体结构相关的什么呀

567
00:18:25,200 --> 00:18:26,966
啊相关的函数啊

568
00:18:26,966 --> 00:18:28,899
那么在这里头你看它调用了什么呢

569
00:18:28,900 --> 00:18:29,966
它调用了这个红

570
00:18:30,300 --> 00:18:32,800
那这个红你看这是一个计算器读写啊

571
00:18:32,866 --> 00:18:37,099
通过arm SY system registrate红啊

572
00:18:37,100 --> 00:18:39,566
执行MRC汇编指令

573
00:18:39,700 --> 00:18:42,533
读取C13计算器该计存器中

574
00:18:42,533 --> 00:18:45,299
保存着当前正在运行任务TCB的地址

575
00:18:45,333 --> 00:18:47,299
那这是和arm处理器相关的啊

576
00:18:47,300 --> 00:18:48,333
你看在这个地方

577
00:18:50,700 --> 00:18:55,900
那么HPF run q top task get啊负责什么呢

578
00:18:55,900 --> 00:18:57,666
负责查找到

579
00:18:57,966 --> 00:18:59,399
负责找到就绪队列中

580
00:18:59,400 --> 00:19:00,666
优先级最高的任务

581
00:19:00,666 --> 00:19:01,566
主要通过

582
00:19:02,133 --> 00:19:05,799
HPF run q中的beatmap利用CLZ函数进行

583
00:19:05,800 --> 00:19:06,133
那这个

584
00:19:06,133 --> 00:19:08,066
我们在前面已经给大家介绍过了啊

585
00:19:08,266 --> 00:19:09,166
对多核情况呢

586
00:19:09,166 --> 00:19:10,066
还要检查

587
00:19:10,066 --> 00:19:12,499
找到的任务与当前CPU的亲和性

588
00:19:12,533 --> 00:19:14,333
如果找到了新的就绪任务

589
00:19:14,333 --> 00:19:16,533
则调用HPF DDQ

590
00:19:16,700 --> 00:19:19,166
函数将该任务从就绪队列中移除

591
00:19:21,200 --> 00:19:22,700
那好这是第一

592
00:19:23,333 --> 00:19:25,599
啊第二个就是运行态到就绪态

593
00:19:25,666 --> 00:19:27,299
那什么叫运行态到就绪态呢

594
00:19:27,300 --> 00:19:28,400
就是说比如说啊

595
00:19:28,400 --> 00:19:30,400
一个进程的时间片耗尽了

596
00:19:30,800 --> 00:19:33,200
那么这个我们我们在讲schedule的时候

597
00:19:33,300 --> 00:19:35,366
其实也也也就表示什么

598
00:19:35,466 --> 00:19:36,933
咱们这个schedule是什么呢

599
00:19:36,933 --> 00:19:37,933
这个schedule是什么

600
00:19:37,933 --> 00:19:38,866
就是说carrying

601
00:19:38,866 --> 00:19:41,666
它就是从就绪它从运行它变就绪态

602
00:19:41,900 --> 00:19:43,733
那我们现在刚才强调的只是什么呢

603
00:19:43,733 --> 00:19:46,099
只是后一个进程后一个任务

604
00:19:46,133 --> 00:19:47,899
那我们在这举的是一个什么例子呢

605
00:19:47,900 --> 00:19:48,600
就是说如果

606
00:19:48,600 --> 00:19:50,866
当前进程调用这个IO的系统

607
00:19:50,866 --> 00:19:52,999
调用IO的系统调用主动放弃

608
00:19:53,366 --> 00:19:54,533
啊CPU的时候

609
00:19:54,533 --> 00:19:55,399
那就会怎么样

610
00:19:55,400 --> 00:19:57,333
调用这个sys该do EU的

611
00:19:57,366 --> 00:19:58,466
那么具体的就调

612
00:19:58,466 --> 00:20:00,133
会调用这个lost task EU的

613
00:20:00,133 --> 00:20:01,733
lost task EU的干嘛呢

614
00:20:01,766 --> 00:20:02,333
它是什么

615
00:20:02,333 --> 00:20:04,333
首先取得当前任务的TCB

616
00:20:04,466 --> 00:20:07,466
然后呢让这个放到这个run task指针中

617
00:20:07,466 --> 00:20:09,599
然后调用这个run task EU的

618
00:20:09,600 --> 00:20:12,566
那具体来说就是调用这个HPFEO的函数

619
00:20:12,800 --> 00:20:14,266
这个HPFU的是什么呢

620
00:20:14,266 --> 00:20:15,733
首先是获得什么呢

621
00:20:15,800 --> 00:20:18,466
获得run q啊获得当前CP的run q

622
00:20:18,700 --> 00:20:20,800
然后呢啊然后呢

623
00:20:20,800 --> 00:20:21,366
怎么样呢

624
00:20:21,366 --> 00:20:23,566
就是说调用这个d q q

625
00:20:23,766 --> 00:20:24,566
怎么样呢

626
00:20:24,566 --> 00:20:25,366
啊引q

627
00:20:25,366 --> 00:20:26,766
因为它是由旧绪态啊

628
00:20:26,766 --> 00:20:27,866
由运行态变成旧序态

629
00:20:27,866 --> 00:20:29,733
所以把当前任务插入到运行队列里

630
00:20:29,733 --> 00:20:30,299
看到了吗

631
00:20:30,300 --> 00:20:33,200
获取运行队列啊插入到就就绪队列

632
00:20:33,200 --> 00:20:33,966
然后怎么样

633
00:20:33,966 --> 00:20:35,099
重新进行调度

634
00:20:35,100 --> 00:20:36,333
看到了重新进行调度

635
00:20:37,300 --> 00:20:37,966
好

636
00:20:37,966 --> 00:20:39,966
那么这是第二种

637
00:20:39,966 --> 00:20:41,866
第三种就是运行态变阻色态

638
00:20:41,866 --> 00:20:42,999
我们在前面讲这个

639
00:20:43,000 --> 00:20:43,900
weight系统调用的时候

640
00:20:43,900 --> 00:20:46,066
讲过啊weight系统调用weightpid

641
00:20:46,066 --> 00:20:49,099
比如说weightpid会调用这个SOS weight ID

642
00:20:49,266 --> 00:20:51,066
调用lost weight ID调用

643
00:20:51,133 --> 00:20:55,266
OS weight借调用OS weight insert weight

644
00:20:55,533 --> 00:20:57,566
weight list in order

645
00:20:57,600 --> 00:20:58,533
那我们看一下啊

646
00:20:58,533 --> 00:20:59,199
我们知道

647
00:20:59,200 --> 00:21:01,166
如果一个县城调用了weight系统

648
00:21:01,266 --> 00:21:03,333
weight PID系统调用的话啊

649
00:21:03,333 --> 00:21:04,166
那么它会怎么样

650
00:21:04,166 --> 00:21:05,733
它会在什么呢

651
00:21:05,733 --> 00:21:06,866
它会在那个进程的

652
00:21:06,866 --> 00:21:07,766
我们再回顾一下

653
00:21:07,766 --> 00:21:10,066
它会在进程PCB的那个weightlist

654
00:21:10,666 --> 00:21:11,666
那个队列里啊

655
00:21:11,666 --> 00:21:14,166
wetlist那个队列里进进行等待对吧

656
00:21:14,166 --> 00:21:15,399
挂到那个wetlist里

657
00:21:15,400 --> 00:21:18,200
所以你看他在这就是process wetlist啊

658
00:21:18,300 --> 00:21:19,333
附附到这个

659
00:21:19,666 --> 00:21:20,533
附到这个list里了

660
00:21:20,533 --> 00:21:21,299
看到了吧

661
00:21:21,300 --> 00:21:23,366
然后呢他会把当前的这个线程

662
00:21:23,366 --> 00:21:24,599
根据这个wet不同的

663
00:21:25,300 --> 00:21:26,333
为他不同的类型

664
00:21:26,333 --> 00:21:28,299
保存的这个队列的不同的位置

665
00:21:28,566 --> 00:21:29,966
最前面是个Pro啊

666
00:21:29,966 --> 00:21:32,166
等待某一个具体的紫紫禁城

667
00:21:32,466 --> 00:21:35,133
那么等待任何一个等待这个group啊

668
00:21:35,133 --> 00:21:37,266
等待等待附进程啊

669
00:21:37,266 --> 00:21:39,266
同一个进程组中的任何一个

670
00:21:39,266 --> 00:21:40,166
子进程的话

671
00:21:40,200 --> 00:21:41,366
就是在中间啊

672
00:21:41,400 --> 00:21:42,700
等待任何一个进程的话

673
00:21:42,700 --> 00:21:44,100
就是在最后看到了吧

674
00:21:44,100 --> 00:21:46,366
也就是说根据runtars格weight flag

675
00:21:46,366 --> 00:21:47,533
在到weight flag

676
00:21:47,533 --> 00:21:48,899
在PCB的weight list中

677
00:21:48,900 --> 00:21:50,766
找到run toss格的插入位置

678
00:21:50,966 --> 00:21:52,566
然后保存在list中

679
00:21:52,866 --> 00:21:55,766
最后怎么样它调用这个task weight啊

680
00:21:55,766 --> 00:21:57,299
task weight那具体来说

681
00:21:57,300 --> 00:21:59,700
就是会调用这个HPF weight函数

682
00:21:59,766 --> 00:22:00,866
那么它怎么样呢

683
00:22:00,866 --> 00:22:02,733
它首先就把当前任务

684
00:22:02,733 --> 00:22:05,866
当前任务的状态只转换成判定阻塞态

685
00:22:06,166 --> 00:22:07,966
然后呢把它插入到什么

686
00:22:07,966 --> 00:22:09,166
你看这个绿色是什么

687
00:22:09,166 --> 00:22:10,533
就是就这个看到吗

688
00:22:10,533 --> 00:22:11,333
这是啥呀

689
00:22:11,333 --> 00:22:12,666
这个就是找到什么呢

690
00:22:12,666 --> 00:22:14,166
找到相应的这个位置

691
00:22:14,166 --> 00:22:15,533
找到相应插入的位置

692
00:22:15,533 --> 00:22:16,866
然后把它插入到这个位置

693
00:22:16,866 --> 00:22:17,666
看到了吧

694
00:22:18,100 --> 00:22:19,800
啊插入到Pro的这个位置

695
00:22:19,800 --> 00:22:21,600
还是跟GID这个位置

696
00:22:21,600 --> 00:22:23,800
还是any的这个位置啊

697
00:22:23,800 --> 00:22:25,700
然后呢调用这个什么

698
00:22:26,100 --> 00:22:27,866
调用这个调度调度参数

699
00:22:27,866 --> 00:22:29,366
调度调度函数看到了吧

700
00:22:29,566 --> 00:22:31,533
那么这个就是这个wait

701
00:22:32,066 --> 00:22:32,899
好第四个是什么

702
00:22:32,900 --> 00:22:34,400
就是主色态叫就绪态

703
00:22:34,400 --> 00:22:35,200
那这是什么意思呢

704
00:22:35,200 --> 00:22:36,466
比如说我刚才呢一个

705
00:22:36,466 --> 00:22:38,099
我在等待一个紫禁城

706
00:22:38,133 --> 00:22:39,866
那么那个紫禁城如果退出了的话

707
00:22:39,866 --> 00:22:42,099
就会调用着OS process natural一个GT

708
00:22:42,466 --> 00:22:44,099
然后进而调用这个osweight

709
00:22:44,100 --> 00:22:45,766
check and wig parent process

710
00:22:45,766 --> 00:22:47,266
最后调用这个osweight

711
00:22:47,600 --> 00:22:48,866
wig task函数

712
00:22:48,866 --> 00:22:50,699
那我们看那么这个是什么呢

713
00:22:50,700 --> 00:22:51,566
就是说啊

714
00:22:51,566 --> 00:22:53,499
首先首先你看它就在这

715
00:22:53,800 --> 00:22:54,766
这个函数的核心

716
00:22:54,766 --> 00:22:57,099
实际上就是调用这个task weight wig函数

717
00:22:57,666 --> 00:22:58,099
那么

718
00:22:58,100 --> 00:23:00,733
具体来讲就是调用这个HPF位函数

719
00:23:00,733 --> 00:23:02,333
那么这个函数干嘛呢啊

720
00:23:02,333 --> 00:23:03,733
首先就是既然我要唤醒

721
00:23:03,733 --> 00:23:04,599
一个任务的话

722
00:23:04,600 --> 00:23:05,500
任务的话那我怎么样

723
00:23:05,500 --> 00:23:08,000
我要把这个任务被唤醒的任务从那个

724
00:23:08,166 --> 00:23:09,499
wetlist那个

725
00:23:09,866 --> 00:23:11,866
附近城的啊附近啊

726
00:23:11,966 --> 00:23:13,999
从那个附近城的wetlist中

727
00:23:15,500 --> 00:23:16,733
删除掉看到了删除掉

728
00:23:16,733 --> 00:23:18,733
然后把它的状态到panding

729
00:23:18,733 --> 00:23:19,733
这个状态怎么样

730
00:23:19,933 --> 00:23:21,166
也去掉看到了吗

731
00:23:21,166 --> 00:23:23,333
也去掉然后呢怎么样

732
00:23:23,533 --> 00:23:25,766
然后呢把这个任务你看我唤醒他们

733
00:23:25,766 --> 00:23:27,066
我们就要把这个任务怎么样

734
00:23:27,066 --> 00:23:28,099
把这个被唤醒的任务

735
00:23:28,100 --> 00:23:30,166
插入到这个旧绪堆列中啊

736
00:23:30,166 --> 00:23:30,966
这就是

737
00:23:31,766 --> 00:23:32,566
到就绪态

738
00:23:32,566 --> 00:23:34,366
那么其他态叫挂起态

739
00:23:34,366 --> 00:23:35,533
那怎么叫挂起态呢

740
00:23:35,533 --> 00:23:37,333
就是说当任务通

741
00:23:37,566 --> 00:23:38,699
以某种方式啊

742
00:23:38,700 --> 00:23:40,566
以某种方式调用这个suspend系统

743
00:23:40,566 --> 00:23:41,466
调用的时候

744
00:23:41,466 --> 00:23:44,299
那实际上就调用这个lost task suspend函数

745
00:23:44,466 --> 00:23:48,066
那么调loss task suspend函数的时候呢

746
00:23:48,066 --> 00:23:51,699
它就本质上是调用这个OS task suspend啊

747
00:23:51,700 --> 00:23:54,100
那么这个OS task suspend呢

748
00:23:54,100 --> 00:23:55,500
进而调用这个什么呢

749
00:23:55,566 --> 00:23:57,566
HPF suspend函数

750
00:23:57,733 --> 00:23:59,933
那么HPF suspend函数干嘛呢

751
00:23:59,933 --> 00:24:02,133
就是说它最简单的函式

752
00:24:02,133 --> 00:24:03,399
最简单的方式就是说

753
00:24:03,866 --> 00:24:06,199
如果啊他本身是一个就绪态的话

754
00:24:06,200 --> 00:24:08,733
他就把这个任务从就绪态队列中移除

755
00:24:08,733 --> 00:24:09,133
看到了吧

756
00:24:09,133 --> 00:24:10,199
出队看到了吧

757
00:24:10,200 --> 00:24:10,900
然后呢

758
00:24:10,900 --> 00:24:13,533
不管怎么样都要进行进程调度啊

759
00:24:13,533 --> 00:24:14,566
进行进程调度

760
00:24:17,200 --> 00:24:17,866
你想一想啊

761
00:24:17,866 --> 00:24:20,399
比如说当前进程如果处于运行态的话

762
00:24:20,400 --> 00:24:22,533
那怎么样我就不用不用摘除了

763
00:24:22,533 --> 00:24:24,166
因为他不再就绪就绪队列

764
00:24:24,166 --> 00:24:25,799
我就直接进行进程调度

765
00:24:25,966 --> 00:24:27,899
如果他是一个就绪队列

766
00:24:27,900 --> 00:24:29,966
就绪就绪就绪态任务的话

767
00:24:29,966 --> 00:24:32,966
我首先要把他从就绪任务中摘除

768
00:24:32,966 --> 00:24:33,799
然后怎么样

769
00:24:33,966 --> 00:24:35,933
再怎么样再进行这个啊

770
00:24:36,366 --> 00:24:37,966
再进行这个进程调度

771
00:24:39,400 --> 00:24:39,966
好

772
00:24:39,966 --> 00:24:40,966
那么由什么

773
00:24:40,966 --> 00:24:43,366
呢由挂起态变成就绪态

774
00:24:43,800 --> 00:24:46,900
前面我是调suspend现在呢我我调resume

775
00:24:47,100 --> 00:24:48,666
那么调入resume就是什么意思呢

776
00:24:48,666 --> 00:24:50,933
就是说我把一个处于挂起态的进程

777
00:24:50,933 --> 00:24:52,466
怎么样让它继续啊

778
00:24:52,466 --> 00:24:53,366
变成就绪态

779
00:24:53,466 --> 00:24:54,399
那这个是什么意思呢

780
00:24:54,400 --> 00:24:56,966
这个就是说它除了怎么样删除这些

781
00:24:57,466 --> 00:24:59,399
啊修改这个标志之外呢你看啊

782
00:24:59,400 --> 00:25:00,400
修改这些标志之外呢

783
00:25:00,400 --> 00:25:03,566
最本质的就是调用这个OS task resume

784
00:25:03,566 --> 00:25:06,699
那么主要是调用这个HPF resume函数

785
00:25:06,733 --> 00:25:08,599
那么调HPF resume函数

786
00:25:08,600 --> 00:25:10,600
就是把这个status的suspend

787
00:25:10,666 --> 00:25:11,733
标志给干掉

788
00:25:11,733 --> 00:25:12,866
看到了吧干掉了

789
00:25:13,300 --> 00:25:13,900
然后呢

790
00:25:13,900 --> 00:25:16,400
就是说如果啊这个任务不是主色台变

791
00:25:16,600 --> 00:25:19,300
你看如果这个任务他没有不是主色的

792
00:25:19,300 --> 00:25:20,266
那怎么样我就

793
00:25:20,533 --> 00:25:21,299
如果是阻塞的话

794
00:25:21,300 --> 00:25:23,466
那怎么样他还在原来的阻塞队列里

795
00:25:23,533 --> 00:25:24,599
否则我就不管

796
00:25:24,700 --> 00:25:26,933
否则的话怎么样那就他是就绪的

797
00:25:26,966 --> 00:25:28,799
或者是运行的时候被suspend了

798
00:25:28,800 --> 00:25:30,100
那怎么那不管怎么样

799
00:25:30,100 --> 00:25:31,933
我就会把它怎么样设置成什么

800
00:25:31,933 --> 00:25:33,133
把它插入到就绪的队列里

801
00:25:33,133 --> 00:25:34,199
你注意在这看

802
00:25:34,466 --> 00:25:34,766
那怎么样

803
00:25:34,766 --> 00:25:36,099
我把这个need的resguide you

804
00:25:36,100 --> 00:25:37,200
这个标志指成处了

805
00:25:37,200 --> 00:25:37,733
看到了吧

806
00:25:37,733 --> 00:25:39,099
那为什么会指成处呢

807
00:25:39,100 --> 00:25:40,166
就是因为啊

808
00:25:40,166 --> 00:25:42,799
这个我们后面会讲啊在教训在对

809
00:25:42,866 --> 00:25:44,533
在这个你还

810
00:25:44,533 --> 00:25:47,333
你还是不是记得我们前面在讲这个

811
00:25:47,700 --> 00:25:50,200
在讲这个数据结构的时候啊在讲这个

812
00:25:50,500 --> 00:25:51,800
在讲这个数据结构的时候啊

813
00:25:51,800 --> 00:25:53,600
你看就是这个标志啊

814
00:25:53,600 --> 00:25:54,266
这个标志

815
00:25:54,266 --> 00:25:55,733
如果那个read scadium

816
00:25:55,733 --> 00:25:57,299
read scadium被指成处的话

817
00:25:57,300 --> 00:25:58,566
他就会设置这个标志

818
00:25:58,600 --> 00:25:59,666
那设置这个标志的话

819
00:25:59,666 --> 00:26:01,599
就会引引发进程调动啊

820
00:26:01,600 --> 00:26:02,966
就会引发进程调动

821
00:26:06,333 --> 00:26:06,899
好

822
00:26:06,900 --> 00:26:09,933
那么最后一个就是说其他态到退出态

823
00:26:09,933 --> 00:26:12,533
那好那怎么样其他态到退出态呢

824
00:26:12,533 --> 00:26:13,699
我们再回忆一下

825
00:26:13,766 --> 00:26:16,366
那么在初始化内核战中啊

826
00:26:16,366 --> 00:26:17,799
在初始化内核战意见中呢

827
00:26:17,800 --> 00:26:18,966
OS task

828
00:26:19,400 --> 00:26:22,766
entry啊是内核的入口参数入口函数

829
00:26:22,800 --> 00:26:24,133
那么当我们再看一下

830
00:26:24,133 --> 00:26:25,566
这就是那个函数啊

831
00:26:25,566 --> 00:26:26,199
大家想一下

832
00:26:26,200 --> 00:26:27,333
当内核站初始化的时候

833
00:26:27,333 --> 00:26:29,066
它被指指定成这个函数

834
00:26:29,066 --> 00:26:29,866
这个函数你看

835
00:26:30,066 --> 00:26:31,766
运行这个运行这个对吧

836
00:26:31,766 --> 00:26:33,799
运行这个命令运行这个函数

837
00:26:33,800 --> 00:26:35,566
大家想一下如果这个函数退出

838
00:26:35,566 --> 00:26:36,399
这个函数运行完了

839
00:26:36,400 --> 00:26:37,400
是不是它就运行这个了

840
00:26:37,400 --> 00:26:38,333
那这个是不是

841
00:26:38,400 --> 00:26:39,200
大家看啊

842
00:26:39,533 --> 00:26:41,333
当内核任务执行完毕后

843
00:26:41,366 --> 00:26:43,533
将继续执行后面继续后面执行

844
00:26:43,533 --> 00:26:46,466
也就是会执行这个OS running task to exit

845
00:26:46,500 --> 00:26:48,100
也就是运行这个退出态

846
00:26:48,133 --> 00:26:49,499
但是这个很好很少发生

847
00:26:49,500 --> 00:26:49,933
为什么呢

848
00:26:49,933 --> 00:26:50,733
因为内核

849
00:26:50,733 --> 00:26:52,566
内核线上一般都是一个无限循环

850
00:26:52,600 --> 00:26:54,266
也就是这个东西都是一个无限循环

851
00:26:54,266 --> 00:26:55,699
所以不会退出除非异常

852
00:26:56,333 --> 00:26:58,333
知道吧异常才会执行这个啊

853
00:26:58,366 --> 00:26:59,766
那好那这个是什么意思呢

854
00:26:59,766 --> 00:27:01,133
这个主要有三个啊

855
00:27:01,133 --> 00:27:02,866
主要有三个就是

856
00:27:04,100 --> 00:27:04,933
主要有三个

857
00:27:04,966 --> 00:27:06,533
三个任务三个步骤

858
00:27:06,533 --> 00:27:07,799
首先是退出

859
00:27:08,066 --> 00:27:09,066
检查一下啊

860
00:27:09,166 --> 00:27:10,499
大大家看检查一下什么

861
00:27:10,500 --> 00:27:12,500
我退出当前退出这个县城

862
00:27:12,600 --> 00:27:13,700
是不是主县城

863
00:27:13,700 --> 00:27:14,766
如果是主县城的话

864
00:27:14,766 --> 00:27:16,533
那我就退回整个县城组

865
00:27:16,733 --> 00:27:18,733
那第二个任务是第二个是什么呢

866
00:27:18,733 --> 00:27:21,399
就是说如果当前退出的这个县城呢

867
00:27:21,500 --> 00:27:24,100
是这个任务这个进程的最后一个县城

868
00:27:24,100 --> 00:27:25,466
那我也只退出整个县城

869
00:27:25,466 --> 00:27:27,999
我这都需要怎么样释放资源的啊

870
00:27:28,000 --> 00:27:29,333
释放资源通知附

871
00:27:29,666 --> 00:27:31,066
通知进程释放资源的

872
00:27:31,066 --> 00:27:31,999
那我们主要讲的

873
00:27:32,000 --> 00:27:33,500
是一个普通的进程啊

874
00:27:33,500 --> 00:27:34,700
普通的任务退出啊

875
00:27:34,700 --> 00:27:35,566
普通任务退出

876
00:27:35,733 --> 00:27:38,666
那么针对这个是针对一个普退出

877
00:27:38,666 --> 00:27:41,599
针对退出一个普通的没有状元的任务

878
00:27:41,966 --> 00:27:42,599
那么同时呢

879
00:27:42,600 --> 00:27:44,933
也不是线程组的最后一个线程

880
00:27:44,933 --> 00:27:45,733
这种情况

881
00:27:45,766 --> 00:27:46,533
那这个函数

882
00:27:46,533 --> 00:27:49,766
核心函数就是这个OS inactive task和DELETE

883
00:27:50,100 --> 00:27:50,800
啊什么意思啊

884
00:27:50,800 --> 00:27:54,266
就是我把这个不活跃的线程给退删除

885
00:27:54,266 --> 00:27:55,799
我删除这个不活跃的线程

886
00:27:55,933 --> 00:27:56,766
那怎么办呢

887
00:27:56,766 --> 00:27:58,333
实际上他会调用这个task

888
00:27:58,500 --> 00:28:00,900
OS o OPS一个z函数

889
00:28:00,966 --> 00:28:03,866
那么最终它会调用这个HPF一个z的

890
00:28:03,866 --> 00:28:05,366
那调HPF一个z的呢

891
00:28:05,366 --> 00:28:07,099
你看如果当前这个任务

892
00:28:07,100 --> 00:28:09,733
它要区分当前任务是不是预就绪态啊

893
00:28:09,966 --> 00:28:10,799
如果是就绪态的话

894
00:28:10,800 --> 00:28:11,266
我就怎么样

895
00:28:11,266 --> 00:28:14,199
要把这个任务从就绪队列中删除啊

896
00:28:14,200 --> 00:28:16,100
然后呢如果他是主色态的话

897
00:28:16,100 --> 00:28:18,266
我要把他从相应的主色队列里删除

898
00:28:18,266 --> 00:28:19,266
同时呢也要

899
00:28:20,333 --> 00:28:22,866
把他的这个标志给指给给清除掉

900
00:28:22,866 --> 00:28:23,666
看到了吧

901
00:28:23,766 --> 00:28:24,566
清除掉

902
00:28:24,600 --> 00:28:26,400
然后呢还要判断一些其他状态

903
00:28:26,400 --> 00:28:27,666
他是不是delay的

904
00:28:27,666 --> 00:28:29,866
是不是有带时钟的啊

905
00:28:29,866 --> 00:28:30,699
如果是这样的话

906
00:28:30,700 --> 00:28:31,500
我还要把这个任务

907
00:28:31,500 --> 00:28:33,333
从这个相应的这个对列中删除

908
00:28:33,866 --> 00:28:34,366
看到了吧

909
00:28:34,366 --> 00:28:35,199
把这个队列

910
00:28:35,366 --> 00:28:36,966
那所以一个自己的实际上是什么呢

911
00:28:36,966 --> 00:28:37,366
就是把

912
00:28:37,366 --> 00:28:39,566
这个任务从相应的不同队列中删除

913
00:28:39,700 --> 00:28:40,366
那他在哪

914
00:28:40,366 --> 00:28:41,799
他可能在哪些队列里呢

915
00:28:41,800 --> 00:28:43,766
他可能在这个就绪队列里

916
00:28:43,800 --> 00:28:44,766
可能在哪呢

917
00:28:44,766 --> 00:28:45,933
可能在这个

918
00:28:46,400 --> 00:28:49,100
可能在这个就是某一个资源的

919
00:28:49,266 --> 00:28:50,666
比如说锁的队列里

920
00:28:50,666 --> 00:28:51,999
也可能在这个什么

921
00:28:52,200 --> 00:28:54,500
也可能在这个就是超时队列里啊

922
00:28:54,500 --> 00:28:55,366
他可能只一个任务

923
00:28:55,366 --> 00:28:56,466
只可能在这三个队列

924
00:28:56,466 --> 00:28:58,533
里那我就把它给怎么样

925
00:28:59,000 --> 00:28:59,666
删删除掉

926
00:28:59,666 --> 00:29:00,666
看到了删除掉

927
00:29:00,666 --> 00:29:02,733
同时呢处理一下这个status啊

928
00:29:02,733 --> 00:29:03,666
处理一下status

929
00:29:04,066 --> 00:29:04,866
最后怎么样呢

930
00:29:04,866 --> 00:29:05,699
最后就是什么

931
00:29:05,700 --> 00:29:09,533
你看最后调用这个OS delete task from process

932
00:29:09,533 --> 00:29:10,899
把它从这个名字上

933
00:29:10,900 --> 00:29:11,700
你也可以知道

934
00:29:11,700 --> 00:29:13,600
把这个任务从这个进程中删除

935
00:29:13,600 --> 00:29:15,100
我们知道这个任务怎么样

936
00:29:15,100 --> 00:29:16,733
这个任务是不是被挂在这个

937
00:29:16,866 --> 00:29:17,866
这个进程的

938
00:29:18,200 --> 00:29:20,366
spread lease的这个双向列表里对吧

939
00:29:20,366 --> 00:29:21,933
那好你看它是什么意思

940
00:29:21,933 --> 00:29:22,933
就是把这个任务

941
00:29:22,933 --> 00:29:24,266
从这个双向列表中删除

942
00:29:24,266 --> 00:29:25,399
然后把这个被删除的任务

943
00:29:25,400 --> 00:29:26,500
插入到什么呢

944
00:29:26,533 --> 00:29:28,166
插入到这个recycle lease中

945
00:29:28,166 --> 00:29:29,933
这recycle lease是什么东西

946
00:29:29,966 --> 00:29:30,766
大家还记得吗

947
00:29:30,766 --> 00:29:33,099
我们在初始化这个任务池的时候

948
00:29:34,566 --> 00:29:36,333
我们在初始化这个任务池的时候

949
00:29:36,333 --> 00:29:36,899
啊看

950
00:29:36,900 --> 00:29:38,000
这初始化这个任务池

951
00:29:38,000 --> 00:29:38,933
都初始化两个列表

952
00:29:38,933 --> 00:29:40,499
一个是空闲任务块

953
00:29:40,566 --> 00:29:41,333
一个是什么

954
00:29:41,333 --> 00:29:43,866
一个是这个回带回收的任务

955
00:29:43,866 --> 00:29:45,666
任务这个任任务这个列表

956
00:29:45,666 --> 00:29:47,199
那刚才那个插入

957
00:29:47,600 --> 00:29:48,500
刚才那个插入

958
00:29:48,500 --> 00:29:50,500
就插入到这个待回收的这个列表中

959
00:29:50,566 --> 00:29:52,133
然后后台有一个后台任务

960
00:29:52,133 --> 00:29:54,166
这后台任务定期的就把这个任务

961
00:29:54,166 --> 00:29:57,199
把这个recycle在recycle意思中的这个TCB

962
00:29:57,333 --> 00:29:59,933
插入到这个free task的TCB中

963
00:30:00,533 --> 00:30:01,133
啊

964
00:30:01,133 --> 00:30:03,699
那这就是啊删除

965
00:30:03,900 --> 00:30:04,700
啊删除

966
00:30:06,900 --> 00:30:08,066
好那么

967
00:30:08,933 --> 00:30:11,899
我们至此呢我们就给大家介绍完毕了

968
00:30:11,900 --> 00:30:14,900
这个啊这个任务的这个

969
00:30:15,966 --> 00:30:17,933
啊关于任务的这个管理啊

970
00:30:18,000 --> 00:30:19,800
以及任务状态的切换这部分

