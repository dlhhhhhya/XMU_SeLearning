1
00:00:02,500 --> 00:00:04,166
各位同学大家好

2
00:00:04,700 --> 00:00:06,466
下面我们为大家介绍

3
00:00:06,466 --> 00:00:08,399
鸿蒙iOS进程管理

4
00:00:08,800 --> 00:00:09,900
这部分的代码

5
00:00:13,766 --> 00:00:16,466
那么我们这一章呢主要讲解四个问题

6
00:00:16,766 --> 00:00:18,699
第一就是进程控制块

7
00:00:19,133 --> 00:00:21,533
第二呢就是进程的管理

8
00:00:21,800 --> 00:00:24,300
第三部分是fork进程

9
00:00:24,300 --> 00:00:25,866
也就是创建一个进程

10
00:00:26,100 --> 00:00:28,133
第四个呢是进程回收

11
00:00:28,900 --> 00:00:29,700
那么

12
00:00:29,900 --> 00:00:31,900
我们为什么要按照这种方式来

13
00:00:31,900 --> 00:00:33,166
给大家介绍呢

14
00:00:34,100 --> 00:00:37,700
首先我们知道进程控制块是啊

15
00:00:37,700 --> 00:00:39,866
进程在操作系

16
00:00:39,866 --> 00:00:40,399
接受操作

17
00:00:40,400 --> 00:00:42,766
系统管理的一个非常重要的数据结构

18
00:00:43,500 --> 00:00:45,666
因此呢我们首先要给大家介绍一下

19
00:00:45,666 --> 00:00:47,266
在Letos系统中

20
00:00:47,466 --> 00:00:50,466
那么进程控制块它究竟长什么样了

21
00:00:50,766 --> 00:00:53,299
那么第二部分呢我们介绍进程管理

22
00:00:53,466 --> 00:00:54,799
进程管理主要是什么意思呢

23
00:00:54,800 --> 00:00:55,866
就是我们知道

24
00:00:56,300 --> 00:00:58,366
那么在利用那个操作系统中

25
00:00:58,366 --> 00:00:59,366
所有的进程呢

26
00:00:59,366 --> 00:01:01,333
都被组织成一棵树的形式

27
00:01:01,666 --> 00:01:04,399
那么我们看一下在Letos系统中

28
00:01:04,533 --> 00:01:06,533
那么它包括哪些

29
00:01:06,766 --> 00:01:09,966
那么它的这棵进程树是怎么构成的啊

30
00:01:10,333 --> 00:01:12,299
那么第三个就是fork进程

31
00:01:12,300 --> 00:01:13,733
fork进程主要是

32
00:01:14,366 --> 00:01:15,799
进程的创建啊

33
00:01:15,800 --> 00:01:17,300
讲进程的创建过程

34
00:01:17,500 --> 00:01:19,733
那我们在说进程的时候曾经说过

35
00:01:19,733 --> 00:01:21,499
进程是啊

36
00:01:21,500 --> 00:01:23,133
在Letos中啊

37
00:01:23,600 --> 00:01:25,766
啊进程主要有两个啊

38
00:01:25,800 --> 00:01:27,166
就是说在一般操作系统中

39
00:01:27,166 --> 00:01:28,566
进程主要有两个功能

40
00:01:28,566 --> 00:01:30,966
一个是拥有资源的

41
00:01:31,466 --> 00:01:32,266
基本单位

42
00:01:32,266 --> 00:01:35,166
第二个是进行计算啊进行运算

43
00:01:35,566 --> 00:01:38,299
但是在letter IS中进程主要是拥有资源

44
00:01:38,300 --> 00:01:40,366
那我们就看一下在fork过程中

45
00:01:40,500 --> 00:01:42,733
这个资源它是如何拥有资源的

46
00:01:43,700 --> 00:01:45,766
啊最后一个呢就是进程

47
00:01:45,900 --> 00:01:47,333
当进程死亡的时候

48
00:01:47,333 --> 00:01:49,599
那么我们要对进程进行回收啊

49
00:01:49,600 --> 00:01:51,733
那我们看一下他是怎么样回收的这

50
00:01:51,733 --> 00:01:52,766
里头有两个非常

51
00:01:52,800 --> 00:01:54,700
有个非常重要的系统标准

52
00:01:54,700 --> 00:01:55,766
就是wait

53
00:01:56,133 --> 00:01:57,166
wait PID啊

54
00:01:57,166 --> 00:01:59,066
wait PID那我们看一下这个

55
00:01:59,500 --> 00:02:00,933
这是怎么互相配合的

56
00:02:02,666 --> 00:02:04,733
首先我们看一下第一个问题

57
00:02:04,733 --> 00:02:07,533
就是在Letos中啊

58
00:02:07,566 --> 00:02:10,299
所定义的为进程所定义的进程控制块

59
00:02:10,300 --> 00:02:12,266
process control blog PCB

60
00:02:12,733 --> 00:02:15,266
啊我们看这是一个非常复杂的一个

61
00:02:15,500 --> 00:02:18,000
也很大很大的一个数据结构啊

62
00:02:18,566 --> 00:02:19,299
看

63
00:02:19,300 --> 00:02:20,100
那么

64
00:02:20,366 --> 00:02:22,866
这就是process CB的这么一个数据结构

65
00:02:23,266 --> 00:02:24,899
那么这个结构体呢比较复杂

66
00:02:24,900 --> 00:02:26,200
虽然呢有有注释

67
00:02:26,200 --> 00:02:28,000
看每一个结构体成员

68
00:02:28,200 --> 00:02:29,800
这个成员变量边上都有注释

69
00:02:29,800 --> 00:02:33,100
但是呢还不是很清晰啊也没有模块化

70
00:02:33,200 --> 00:02:35,800
那么下面呢我们就分6个大块啊

71
00:02:35,800 --> 00:02:38,100
把这个这个复杂结构体呢

72
00:02:38,100 --> 00:02:39,933
分项给大家进行一些

73
00:02:40,200 --> 00:02:41,100
进行介绍

74
00:02:42,000 --> 00:02:44,566
好首先呢我们看啊

75
00:02:44,566 --> 00:02:45,466
在PCB中呢

76
00:02:45,466 --> 00:02:47,699
有一些结构体的成员

77
00:02:47,800 --> 00:02:50,800
是和任务也就是线程相关的啊

78
00:02:50,933 --> 00:02:52,133
那么在赖头s中

79
00:02:52,133 --> 00:02:54,333
进程和线程的关系是一比n的

80
00:02:54,333 --> 00:02:55,733
也就是一对多的关系

81
00:02:56,100 --> 00:02:58,133
进程可以有多个任务

82
00:02:58,766 --> 00:02:59,899
也就是多个线程

83
00:02:59,900 --> 00:03:03,333
但一个任务不能同属于多个进程啊

84
00:03:03,333 --> 00:03:06,133
就是说它只是一个单纯的一对多关系

85
00:03:06,466 --> 00:03:09,166
任务就是线程是CPU的调度单位

86
00:03:09,533 --> 00:03:13,266
任务是作为一种资源被进程管理的

87
00:03:14,266 --> 00:03:17,133
进程为任务提供内存支持

88
00:03:17,300 --> 00:03:20,066
提供文件支持提供设备支持

89
00:03:20,266 --> 00:03:22,733
那大家看啊在这句话里说的是什么呀

90
00:03:23,166 --> 00:03:24,733
任务也是进程的一种资源

91
00:03:24,733 --> 00:03:26,099
所以后面我们再看

92
00:03:26,100 --> 00:03:28,066
当我们创建任务的时候啊

93
00:03:28,100 --> 00:03:30,666
那么一般来讲也会怎么样呢

94
00:03:30,700 --> 00:03:32,900
啊就是说会拷贝啊

95
00:03:32,900 --> 00:03:35,266
会拷贝这个进程的一些资源

96
00:03:35,733 --> 00:03:36,666
啊一些资源

97
00:03:36,766 --> 00:03:37,799
那么进程

98
00:03:38,000 --> 00:03:39,800
进程资源还包除了任务之外呢

99
00:03:39,800 --> 00:03:40,766
还包括什么

100
00:03:40,866 --> 00:03:42,133
还包括内存

101
00:03:42,300 --> 00:03:43,700
还包括文件

102
00:03:43,733 --> 00:03:45,366
还包括设备等等

103
00:03:47,100 --> 00:03:49,400
那么晋城是怎么管理县城的呢

104
00:03:49,666 --> 00:03:52,933
那么晋城怎么同步县城的状态呢

105
00:03:53,533 --> 00:03:56,999
那么我们看啊首先进程加载时呢

106
00:03:57,200 --> 00:04:00,200
会找到面函数创建第一个线程

107
00:04:00,400 --> 00:04:02,000
那么我们把这个线程称为

108
00:04:02,000 --> 00:04:03,300
一般称为主线程

109
00:04:03,600 --> 00:04:06,933
面函数啊就是这个线程的入口函数

110
00:04:06,933 --> 00:04:08,966
一切呢都从这里开始

111
00:04:09,866 --> 00:04:13,566
执行过程中根据代码创建新的线程

112
00:04:13,966 --> 00:04:14,899
那么其本质

113
00:04:14,900 --> 00:04:17,333
和may函数创建的线程没有区别

114
00:04:17,400 --> 00:04:19,333
只是呢这时候的入口函

115
00:04:19,366 --> 00:04:21,766
入口函数呢我们可以自己确定啊

116
00:04:22,366 --> 00:04:24,066
然后呢进行统一

117
00:04:24,133 --> 00:04:26,499
这些所有的县城啊统一参与调度

118
00:04:26,666 --> 00:04:27,766
那在这个里头呢

119
00:04:27,766 --> 00:04:29,999
他给他他举了个加瓦的例子啊

120
00:04:30,000 --> 00:04:30,466
当然

121
00:04:30,466 --> 00:04:33,166
这个在烂铜s中目前还不支持加瓦

122
00:04:33,333 --> 00:04:33,966
但是呢

123
00:04:33,966 --> 00:04:36,366
为了就是因为大家有加瓦的经验嘛

124
00:04:36,366 --> 00:04:39,066
所以我们用一个Java的程序

125
00:04:39,066 --> 00:04:39,866
作为一个例子啊

126
00:04:39,866 --> 00:04:40,599
比如说在Java里

127
00:04:40,600 --> 00:04:43,266
我们经常use red来创建一个线程

128
00:04:43,400 --> 00:04:46,333
然后通过run啊通过run来运行一个

129
00:04:46,933 --> 00:04:48,899
运行一个函数啊运行一个函数

130
00:04:48,900 --> 00:04:51,466
那么这个呢在c语言里也一样啊

131
00:04:51,466 --> 00:04:54,333
也一样有piece red create这个

132
00:04:54,666 --> 00:04:57,099
这个还有piece red exit等等啊

133
00:04:57,100 --> 00:04:58,133
这些系统调用

134
00:04:58,866 --> 00:05:01,266
县城和县城的关系可以是独立的

135
00:05:01,266 --> 00:05:02,266
也就是detached

136
00:05:02,700 --> 00:05:04,000
那么也可以是连结的

137
00:05:04,000 --> 00:05:05,766
也就是draw drainable啊

138
00:05:06,000 --> 00:05:07,500
连结是指什么呢

139
00:05:07,500 --> 00:05:08,500
连接是指

140
00:05:09,133 --> 00:05:09,466
啊

141
00:05:09,466 --> 00:05:12,499
指的是一个县城可以操作另一个县城

142
00:05:12,733 --> 00:05:13,766
那么包括啊

143
00:05:13,766 --> 00:05:15,966
一个县城可以回收另一个县城的资源

144
00:05:15,966 --> 00:05:17,666
或者是把对方给杀掉

145
00:05:18,400 --> 00:05:19,066
那么进城

146
00:05:19,066 --> 00:05:22,733
的主线城或所有线城运行结束后

147
00:05:23,133 --> 00:05:25,933
进城转为僵尸态就是尊北啊

148
00:05:25,933 --> 00:05:27,466
注意啊这是什么意思呢

149
00:05:27,466 --> 00:05:28,966
这是这是一个祸的条件

150
00:05:28,966 --> 00:05:29,766
就是说

151
00:05:29,800 --> 00:05:32,100
如果进城的主线城也是main推出了

152
00:05:32,100 --> 00:05:33,133
那么这个进城

153
00:05:33,566 --> 00:05:34,566
就退出了啊

154
00:05:34,566 --> 00:05:35,366
就退出了

155
00:05:35,366 --> 00:05:37,066
或者是这个晋城的所有县城

156
00:05:37,066 --> 00:05:37,866
比如说这个晋城

157
00:05:37,866 --> 00:05:39,999
我们说晋城县城这个一对多关系

158
00:05:40,166 --> 00:05:42,399
那么如果隶属于这个晋城的所有县

159
00:05:42,400 --> 00:05:43,166
城都退出了

160
00:05:43,166 --> 00:05:44,866
但是这晋城也会退出

161
00:05:45,066 --> 00:05:46,699
但是晋城的退出是有个过程

162
00:05:46,700 --> 00:05:47,900
他不会马上退出

163
00:05:48,000 --> 00:05:49,133
他会首先转成

164
00:05:49,133 --> 00:05:49,933
转换成什么呢

165
00:05:49,933 --> 00:05:51,133
一个僵尸态啊

166
00:05:51,533 --> 00:05:53,333
一般当所有线程结束后

167
00:05:53,333 --> 00:05:54,933
进城才自然死亡

168
00:05:55,266 --> 00:05:55,866
自然消亡

169
00:05:55,866 --> 00:05:58,066
也就是natural natural dance

170
00:05:58,133 --> 00:06:00,266
dance啊啊natral exit啊

171
00:06:00,266 --> 00:06:01,099
natural exit

172
00:06:02,366 --> 00:06:03,299
那我们看一下啊

173
00:06:03,300 --> 00:06:06,800
在Letos中和线程相关的有这么几个啊

174
00:06:06,800 --> 00:06:08,200
这么几个啊

175
00:06:08,200 --> 00:06:09,600
你看首先是什么呢

176
00:06:09,600 --> 00:06:10,866
spread group ID

177
00:06:11,066 --> 00:06:12,566
那这个从这个名字上

178
00:06:12,566 --> 00:06:13,533
你可以知道这是什么

179
00:06:13,533 --> 00:06:14,666
线程组的

180
00:06:15,333 --> 00:06:16,866
啊线程组的这个ID啊

181
00:06:16,933 --> 00:06:17,966
那么一般来讲

182
00:06:18,100 --> 00:06:19,766
一般来讲这个线程组就是什么

183
00:06:19,766 --> 00:06:20,766
就是主线程

184
00:06:20,800 --> 00:06:21,900
主线程的ID啊

185
00:06:21,900 --> 00:06:22,700
主线程ID

186
00:06:23,366 --> 00:06:24,666
那么第二个是什么呢

187
00:06:24,666 --> 00:06:26,299
Stride sliving list

188
00:06:26,500 --> 00:06:27,266
这个是什么呀

189
00:06:27,266 --> 00:06:28,599
就是线程的一个列表

190
00:06:28,666 --> 00:06:30,333
那么这个列表中

191
00:06:30,333 --> 00:06:33,066
你看这是一个lost DL list的一个列表

192
00:06:33,066 --> 00:06:35,333
这个列表呢挂载着隶属于这个线

193
00:06:35,533 --> 00:06:37,499
隶属于某一个进程的所有线程啊

194
00:06:37,500 --> 00:06:38,900
所有线程都在这挂着

195
00:06:39,300 --> 00:06:41,700
那么这个Sprite number就是这地方有几个

196
00:06:41,700 --> 00:06:43,566
什么有几个啊

197
00:06:43,666 --> 00:06:45,899
TCB结构task stroke

198
00:06:46,266 --> 00:06:49,366
task control嗯block啊

199
00:06:49,366 --> 00:06:50,766
TCB嘛结构题

200
00:06:50,766 --> 00:06:52,666
那这地方就是number是几表示线

201
00:06:52,666 --> 00:06:53,466
上的个数

202
00:06:54,200 --> 00:06:55,800
啊那么啊这个是什么呢

203
00:06:55,800 --> 00:06:57,366
就是活活动线程的格数

204
00:06:57,366 --> 00:06:58,599
活动线程的格数

205
00:06:58,766 --> 00:07:00,466
那这个当然这上这个spread

206
00:07:00,466 --> 00:07:02,666
slablice都挂的都是活动线程啊

207
00:07:02,900 --> 00:07:05,666
另外一个是spread什么spread con

208
00:07:05,933 --> 00:07:07,533
spread con就是说啊

209
00:07:07,733 --> 00:07:08,733
总共的线程数

210
00:07:08,733 --> 00:07:09,133
为什么呢

211
00:07:09,133 --> 00:07:10,466
因为有的线程是什么

212
00:07:10,466 --> 00:07:12,333
是处于等待态的啊

213
00:07:12,666 --> 00:07:13,966
就是比如说处于什么呢

214
00:07:13,966 --> 00:07:16,099
就是处于wait状态啊什么的

215
00:07:16,166 --> 00:07:17,066
它会挂到别的

216
00:07:17,066 --> 00:07:18,933
就是waiting list的那些列表里

217
00:07:18,933 --> 00:07:19,899
那这上都是什么呢

218
00:07:19,900 --> 00:07:22,733
这上就是所有的啊所有的这个线程数

219
00:07:26,700 --> 00:07:29,533
那么进城是家族式管理的

220
00:07:29,900 --> 00:07:31,933
内核态用户啊

221
00:07:32,133 --> 00:07:33,966
嗯process CB数据结构呢

222
00:07:33,966 --> 00:07:36,066
除了包含跟县城相关的一些结构

223
00:07:36,066 --> 00:07:38,399
之外呢还包含一些什么呢

224
00:07:38,400 --> 00:07:39,966
就是啊

225
00:07:40,333 --> 00:07:42,199
进城的这个家族式管理的一些

226
00:07:42,200 --> 00:07:43,566
数据结构啊

227
00:07:43,566 --> 00:07:44,366
数据成员

228
00:07:45,066 --> 00:07:47,133
内核态进程和用户态进程呢

229
00:07:47,133 --> 00:07:50,266
分别有自己的根组线啊

230
00:07:50,266 --> 00:07:50,666
组

231
00:07:50,666 --> 00:07:54,099
组线进程在内核初始化时就创建好了

232
00:07:54,166 --> 00:07:55,666
那这里主要指的是什么呢

233
00:07:55,666 --> 00:07:58,199
分别是1号进程和2号进程

234
00:07:58,600 --> 00:07:59,666
1号进程是什么呢

235
00:07:59,666 --> 00:08:01,566
就是用户态进程的祖先

236
00:08:01,700 --> 00:08:04,366
是以利他进以利以利他进程

237
00:08:04,533 --> 00:08:07,766
而2号进程是所有内核态进程的祖先

238
00:08:07,933 --> 00:08:09,533
叫做k process进程

239
00:08:09,733 --> 00:08:11,466
那么进程刚生下来

240
00:08:12,000 --> 00:08:14,333
就确定了自己的基因

241
00:08:14,600 --> 00:08:17,366
基因就决定了他们的权限不权限不同

242
00:08:17,900 --> 00:08:19,000
啊父亲是谁

243
00:08:19,066 --> 00:08:20,866
兄弟姐妹都有

244
00:08:21,400 --> 00:08:22,566
是啊

245
00:08:23,066 --> 00:08:26,266
兄弟姐妹有都有谁啊都已经安排好了

246
00:08:26,366 --> 00:08:28,866
进城呢可以有自己的子子孙孙啊

247
00:08:28,866 --> 00:08:30,699
很像我们人类的传承方式

248
00:08:30,866 --> 00:08:32,066
那么以这种方式

249
00:08:32,066 --> 00:08:34,166
最终就形成了一个树状的结构

250
00:08:34,266 --> 00:08:35,166
每个进城

251
00:08:35,366 --> 00:08:37,466
都能在这棵树中找到自己的位置

252
00:08:38,366 --> 00:08:39,199
啊那么进城的

253
00:08:39,200 --> 00:08:41,100
管理遵循以下几点原则

254
00:08:41,566 --> 00:08:43,499
那么第一个原则就是进城退出时

255
00:08:43,500 --> 00:08:46,333
会主动主动释放持有的进城资源

256
00:08:47,533 --> 00:08:49,699
但持有的进程PCB资源

257
00:08:49,766 --> 00:08:52,133
需要附进程通过wait或者wait PID

258
00:08:52,133 --> 00:08:53,166
这样的系统调用

259
00:08:53,366 --> 00:08:55,466
或附进程退出时进行回收

260
00:08:55,566 --> 00:08:57,666
那这就解释了前面我们说的

261
00:08:57,666 --> 00:08:59,266
为什么进程在退出的时候

262
00:08:59,266 --> 00:09:00,133
不是马上退出

263
00:09:00,133 --> 00:09:01,533
而是有一个僵尸态

264
00:09:01,933 --> 00:09:03,199
那什么叫僵尸态呢

265
00:09:03,200 --> 00:09:04,400
就是一个进程啊

266
00:09:04,466 --> 00:09:06,566
他把自己的所有资源释放掉以后

267
00:09:06,566 --> 00:09:08,166
除了p就是一个进程

268
00:09:08,166 --> 00:09:10,599
除了PCB没有被释放掉之外呢

269
00:09:10,600 --> 00:09:12,200
他把所有的资源都释放了

270
00:09:12,200 --> 00:09:14,333
那么我们管这个状态叫做僵尸态

271
00:09:14,400 --> 00:09:16,533
那他的PCB由谁来回收呢

272
00:09:16,533 --> 00:09:17,333
是由这个

273
00:09:17,333 --> 00:09:19,966
他的附进程通过wait wait和wait PID

274
00:09:19,966 --> 00:09:20,966
来进行回收的

275
00:09:22,000 --> 00:09:22,766
那么当

276
00:09:22,766 --> 00:09:25,566
啊他的附进程把PID回收完毕之后

277
00:09:25,566 --> 00:09:26,566
那这个进程啊

278
00:09:26,566 --> 00:09:29,599
就彻底的从这个系统中消失了啊

279
00:09:30,533 --> 00:09:32,999
一个紫禁城的消亡要通知附近城

280
00:09:33,000 --> 00:09:36,266
以便附近城在族谱中抹掉他的痕迹

281
00:09:36,266 --> 00:09:38,533
所以大家看你看这个就是说什么

282
00:09:38,533 --> 00:09:39,933
就是附近城啊

283
00:09:39,933 --> 00:09:42,933
负责回收紫禁城的PCB啊

284
00:09:42,933 --> 00:09:44,899
从而实现这个目的啊

285
00:09:44,900 --> 00:09:46,500
实现这个目的就是附近城

286
00:09:46,600 --> 00:09:48,666
在族谱中把紫禁城的痕迹抹掉

287
00:09:49,266 --> 00:09:52,299
一些异常情况下的进城啊

288
00:09:52,300 --> 00:09:55,100
紫禁城消亡没有通知附近城

289
00:09:55,300 --> 00:09:57,300
那么也就是说在某些情况下呀

290
00:09:57,300 --> 00:09:58,566
有一些紫禁城

291
00:09:58,566 --> 00:10:00,866
他消亡的时候没有告知他的附近城

292
00:10:01,066 --> 00:10:02,966
那么系统也会定时

293
00:10:03,133 --> 00:10:05,566
也会有定时任务检测啊

294
00:10:05,766 --> 00:10:06,566
检测到

295
00:10:07,133 --> 00:10:09,599
并且对他们的资源进行回收啊

296
00:10:09,933 --> 00:10:11,199
那么这个是

297
00:10:11,866 --> 00:10:12,799
进城创建后

298
00:10:12,800 --> 00:10:14,800
只能操作自己的进城空间资源

299
00:10:14,800 --> 00:10:16,400
无法操作其他进

300
00:10:16,400 --> 00:10:17,200
城的资源

301
00:10:17,566 --> 00:10:20,533
当然一个进城主动共享资源除外

302
00:10:21,700 --> 00:10:24,200
进程间有多种通讯方式

303
00:10:24,200 --> 00:10:27,366
包括世界信号消息队列

304
00:10:27,766 --> 00:10:28,766
管道等等

305
00:10:28,966 --> 00:10:30,199
那么light IPC

306
00:10:30,200 --> 00:10:33,666
是进程间基于文件的一种通讯方式

307
00:10:33,900 --> 00:10:37,000
它的特点是传递的信息量可以很大

308
00:10:37,166 --> 00:10:38,799
好那我们现在看一下什么

309
00:10:38,800 --> 00:10:40,066
我看一下这个

310
00:10:40,766 --> 00:10:42,399
跟这个相关的一些结构

311
00:10:42,400 --> 00:10:44,000
结构体成员变量表什么意思

312
00:10:44,000 --> 00:10:46,066
我们看首先process name是什么呀

313
00:10:46,166 --> 00:10:48,899
就是每个进程都有一个进程的名字

314
00:10:49,000 --> 00:10:51,733
那这个process ID就是进程的标志符ID

315
00:10:51,866 --> 00:10:53,666
那它实际上就是PCB数组的

316
00:10:53,666 --> 00:10:55,866
这个是缩引号

317
00:10:56,166 --> 00:10:57,766
那process data是什么

318
00:10:57,766 --> 00:10:59,466
就是这个进程的状态啊

319
00:10:59,466 --> 00:11:00,699
通通过他名有意思

320
00:11:00,700 --> 00:11:03,200
比如说我们在上课讲他这个进程

321
00:11:03,366 --> 00:11:04,933
当然是因为他不是调度啊

322
00:11:04,933 --> 00:11:05,333
所以

323
00:11:05,333 --> 00:11:07,399
说这个进程状态相对来讲比较简单

324
00:11:07,733 --> 00:11:08,766
还有priority啊

325
00:11:08,766 --> 00:11:11,566
priority表示的是默认的一个

326
00:11:12,366 --> 00:11:14,933
呃哎这Pro alt我看一下有没有啊

327
00:11:14,933 --> 00:11:16,133
这Pro alt有没有

328
00:11:17,166 --> 00:11:18,899
呃没有没有

329
00:11:18,966 --> 00:11:20,199
因为是这样啊因为是这样

330
00:11:20,200 --> 00:11:21,900
这个我做的这个缓动片呢

331
00:11:21,900 --> 00:11:23,800
比这个这个引用的这个

332
00:11:24,266 --> 00:11:24,799
比较老啊

333
00:11:24,800 --> 00:11:25,766
所以这个没有

334
00:11:25,766 --> 00:11:26,566
这priority啊

335
00:11:26,566 --> 00:11:29,666
policy timeslide这些这些东西都没有啊

336
00:11:29,933 --> 00:11:31,399
那有Ctrl ID啊

337
00:11:31,400 --> 00:11:32,900
好我们一起看一下这个吧

338
00:11:33,200 --> 00:11:34,333
process name是什么呢

339
00:11:34,333 --> 00:11:36,299
process name是进程的名称

340
00:11:36,566 --> 00:11:38,099
这个呢是进程的ID

341
00:11:38,133 --> 00:11:39,933
这个是进程的状态

342
00:11:40,066 --> 00:11:40,966
那这个是什么呢

343
00:11:40,966 --> 00:11:44,766
就是嗯那个终端号啊

344
00:11:44,766 --> 00:11:46,099
终端号终端号

345
00:11:46,100 --> 00:11:48,066
这个我们讲那个设备的时候会讲

346
00:11:48,333 --> 00:11:49,599
那这个是process Mo的

347
00:11:49,600 --> 00:11:50,100
表示

348
00:11:50,100 --> 00:11:52,466
当前这个进程到底是一个内核态进程

349
00:11:52,466 --> 00:11:53,733
还是一个用户态进程

350
00:11:54,333 --> 00:11:55,799
那pirate process ID是什么

351
00:11:55,800 --> 00:11:58,133
就是它的附进程的IG ID

352
00:11:58,166 --> 00:11:59,899
我们刚才说了啊

353
00:11:59,900 --> 00:12:02,300
所有进程啊都会形成

354
00:12:02,300 --> 00:12:04,100
所有进程都组成了组

355
00:12:04,100 --> 00:12:04,866
组织成了什么

356
00:12:04,866 --> 00:12:05,933
一棵树的形式

357
00:12:06,366 --> 00:12:08,166
那么在烂桃s中一共有两棵树

358
00:12:08,166 --> 00:12:10,499
一棵是内核是内核进程构成的树

359
00:12:10,500 --> 00:12:11,733
一棵是什么呢

360
00:12:11,766 --> 00:12:13,133
用户进程构成的数

361
00:12:13,200 --> 00:12:14,500
所以这个parent ID呢

362
00:12:14,500 --> 00:12:16,566
就是子进程要找复进程

363
00:12:16,566 --> 00:12:18,166
它怎么找process ID啊

364
00:12:18,166 --> 00:12:19,899
通过parent process ID来找

365
00:12:20,500 --> 00:12:22,200
那么这个exit code是什么意思呢

366
00:12:22,200 --> 00:12:24,800
当紫禁城退出的时候它有一个退出码

367
00:12:25,000 --> 00:12:26,133
啊附近城

368
00:12:26,133 --> 00:12:28,766
可以根据这个exit code的值来表示

369
00:12:28,766 --> 00:12:29,599
它到底是

370
00:12:29,800 --> 00:12:32,166
啊成功退出了还是没有成功退出

371
00:12:32,766 --> 00:12:34,133
那么这个pandelist是什么呢

372
00:12:34,133 --> 00:12:36,699
这个pandelist是一个非常重要的指针啊

373
00:12:36,700 --> 00:12:38,200
我们比如说这个进程

374
00:12:38,200 --> 00:12:39,166
我们说这个进程

375
00:12:39,166 --> 00:12:40,866
我们说他有什么就绪态

376
00:12:40,933 --> 00:12:41,866
有阻塞态

377
00:12:42,100 --> 00:12:43,533
当如果他是就绪态的时候

378
00:12:43,533 --> 00:12:45,099
他就通过这个pandelister

379
00:12:45,366 --> 00:12:46,899
把自己挂在什么呀

380
00:12:46,900 --> 00:12:47,766
就是那个

381
00:12:48,466 --> 00:12:49,166
就绪队列中

382
00:12:49,166 --> 00:12:49,599
就是

383
00:12:49,600 --> 00:12:52,133
就是那个优先级对优先级priority q啊

384
00:12:52,133 --> 00:12:53,333
优先级列表中

385
00:12:53,800 --> 00:12:55,266
如果他要是出于主色态

386
00:12:55,266 --> 00:12:56,399
他就用这个Pad list

387
00:12:56,400 --> 00:12:58,166
把自己挂在那某一个锁上啊

388
00:12:58,166 --> 00:12:59,166
某一个资源上

389
00:13:00,100 --> 00:13:01,766
啊那如果呢

390
00:13:01,766 --> 00:13:04,133
他要是处于啊等待态的话

391
00:13:04,133 --> 00:13:05,466
就是weight态的话

392
00:13:05,733 --> 00:13:08,099
就是那么他就把自己呢

393
00:13:08,166 --> 00:13:09,899
当然weight也是一种阻塞了啊

394
00:13:09,900 --> 00:13:11,200
当然那个就是

395
00:13:11,466 --> 00:13:12,499
就是这个就是

396
00:13:12,500 --> 00:13:15,266
我们后面会讲weight PID啊weight系统调用

397
00:13:15,566 --> 00:13:16,566
那么他就会把

398
00:13:16,566 --> 00:13:18,733
用这个panda list把自己挂在什么呢

399
00:13:18,733 --> 00:13:20,399
挂在这个waiting list的列表了

400
00:13:20,400 --> 00:13:22,000
这个这个wait list

401
00:13:22,000 --> 00:13:22,966
的这个列表上

402
00:13:23,100 --> 00:13:24,333
所以这个panda list呢

403
00:13:24,333 --> 00:13:26,366
就是是万能的万能指针啊

404
00:13:26,366 --> 00:13:27,166
万能指针

405
00:13:27,300 --> 00:13:29,666
当PCB想要把自己挂在哪时候

406
00:13:29,666 --> 00:13:31,933
它就把自己挂哪好吧

407
00:13:32,066 --> 00:13:32,866
好

408
00:13:33,066 --> 00:13:34,299
那么这是pandelites

409
00:13:34,300 --> 00:13:35,900
这个children lease是什么意思啊

410
00:13:35,900 --> 00:13:38,166
因为你看我们前面这个是什么呢

411
00:13:38,166 --> 00:13:40,066
这个是当前进程

412
00:13:40,100 --> 00:13:42,366
它指向的附进程的这个指针

413
00:13:42,566 --> 00:13:44,866
那那那一个进程有多个子进程

414
00:13:44,866 --> 00:13:45,966
所以这个children lease的

415
00:13:45,966 --> 00:13:47,733
就是这个进程的孩子的

416
00:13:47,733 --> 00:13:49,166
指针啊

417
00:13:49,166 --> 00:13:49,999
那这个是什么呢

418
00:13:50,000 --> 00:13:51,133
这个就是这些孩子

419
00:13:51,133 --> 00:13:52,699
有的可能已经退出了啊

420
00:13:52,700 --> 00:13:54,366
对吧那么这个就是说

421
00:13:54,366 --> 00:13:56,533
这些退出的孩子的指针啊

422
00:13:56,533 --> 00:13:57,733
退出的孩子的指针

423
00:13:58,533 --> 00:14:00,066
退出的紫禁城的指针

424
00:14:00,166 --> 00:14:02,299
那这个呢是兄弟指针啊

425
00:14:02,300 --> 00:14:03,700
兄弟指针就是这个进城啊

426
00:14:03,700 --> 00:14:04,866
他可能有一些兄弟

427
00:14:05,000 --> 00:14:07,300
所以所有兄弟指针都挂在这个

428
00:14:07,366 --> 00:14:08,466
Slive list里

429
00:14:08,733 --> 00:14:09,566
group是什么呢

430
00:14:09,566 --> 00:14:11,899
group是进城组啊进城组

431
00:14:12,000 --> 00:14:13,333
那这些进城组呢

432
00:14:13,933 --> 00:14:14,533
进程组呢

433
00:14:14,533 --> 00:14:16,799
有可能是兄弟也有可能不是兄弟

434
00:14:16,900 --> 00:14:19,333
也就是说啊完成同一个目标啊

435
00:14:19,333 --> 00:14:20,666
在这里有个进程组的概念

436
00:14:20,666 --> 00:14:22,299
那么都在这个地方

437
00:14:22,300 --> 00:14:24,466
他挂着sabordinate

438
00:14:24,933 --> 00:14:26,266
subordinate group

439
00:14:26,266 --> 00:14:26,999
list是什么呢

440
00:14:27,000 --> 00:14:27,933
就是在系统中啊

441
00:14:27,933 --> 00:14:30,499
他把所有的进程组都构成一个列表

442
00:14:30,733 --> 00:14:33,933
那这个呢就是啊他兄弟进程组的列表

443
00:14:34,000 --> 00:14:35,200
兄弟进程组的列表

444
00:14:35,566 --> 00:14:37,799
那这个呢就是关于这个

445
00:14:38,800 --> 00:14:41,600
这些东西的这个这个解释

446
00:14:41,766 --> 00:14:44,366
那好我们看一下这个是进程的状态

447
00:14:44,566 --> 00:14:46,299
那进程主要包括哪些状态呢

448
00:14:46,300 --> 00:14:46,333
包

449
00:14:46,333 --> 00:14:49,199
包括你看这个进程是属于一逆的状态

450
00:14:49,766 --> 00:14:51,333
啊起始态看到了吧

451
00:14:52,100 --> 00:14:53,700
啊创建态啊骑士态

452
00:14:53,866 --> 00:14:54,933
还有尊卑啊

453
00:14:54,933 --> 00:14:55,599
尊卑是什么呢

454
00:14:55,600 --> 00:14:57,966
僵尸态就是说他已经我正

455
00:14:57,966 --> 00:14:58,999
在创建一个进程的时候

456
00:14:59,000 --> 00:15:00,366
他就处于隐匿的状态

457
00:15:00,533 --> 00:15:02,533
那如果要是这个进程呢

458
00:15:03,066 --> 00:15:04,499
已经释放了所有资源

459
00:15:04,533 --> 00:15:05,599
除了PCB以外

460
00:15:05,600 --> 00:15:08,466
那么我们说这个状态处于僵尸态啊

461
00:15:08,600 --> 00:15:10,566
那use的状态这个进程什么呀

462
00:15:10,566 --> 00:15:13,499
还没有被使用它处于什么freelease中

463
00:15:13,766 --> 00:15:15,166
那是为什么叫Fleece呢

464
00:15:15,166 --> 00:15:18,099
等我们后边会讲这个进程初始化

465
00:15:18,200 --> 00:15:19,966
那么这时候那时候我们就会接触啊

466
00:15:19,966 --> 00:15:20,933
就是说一个进程

467
00:15:20,933 --> 00:15:22,166
PCB还没有被使用的时候

468
00:15:22,166 --> 00:15:23,699
它就处于on use的状态

469
00:15:24,266 --> 00:15:25,933
那么如果一个进程呢

470
00:15:26,000 --> 00:15:26,700
啊这是什么呢

471
00:15:26,700 --> 00:15:27,866
进程退出标签

472
00:15:28,133 --> 00:15:29,599
那么退出的进程呢

473
00:15:29,733 --> 00:15:32,199
啊进入这个回收链表等待回收啊

474
00:15:32,200 --> 00:15:34,400
那么他就处于这个exceed状态

475
00:15:35,966 --> 00:15:38,533
那如果这个进程呢是一个进程组

476
00:15:38,533 --> 00:15:40,199
我们前面不说有个进程组啊

477
00:15:40,266 --> 00:15:42,199
那如果他是一个进程组的组长

478
00:15:42,200 --> 00:15:44,066
也就是这个进程组的第一个进程

479
00:15:44,100 --> 00:15:45,333
那么一般来讲

480
00:15:45,333 --> 00:15:46,733
都是这个进程组的第一个进程

481
00:15:46,733 --> 00:15:48,066
叫做grew leader啊

482
00:15:48,066 --> 00:15:50,533
grew leader那下一个是什么呢

483
00:15:50,533 --> 00:15:52,899
如果一个进程呢是通过啊

484
00:15:53,200 --> 00:15:56,666
啊exe系统调用来运行来执行起来的

485
00:15:56,666 --> 00:16:00,399
那么啊看进程已经执行了exe操作啊

486
00:16:00,400 --> 00:16:01,900
load了e ELF

487
00:16:01,933 --> 00:16:03,266
这个ELF是什么呢

488
00:16:03,266 --> 00:16:05,666
就是说我们知道在Windows系统中

489
00:16:05,966 --> 00:16:08,066
可执行文件是点exe文件

490
00:16:08,400 --> 00:16:09,966
那么在类用那个操作系统中

491
00:16:09,966 --> 00:16:11,266
可制性文件是什么呢

492
00:16:11,266 --> 00:16:13,099
就是ELF文件啊

493
00:16:13,200 --> 00:16:16,200
那么那么当这个一个进程呢

494
00:16:16,200 --> 00:16:19,166
已经执行了这个EXC系统调用之后

495
00:16:19,166 --> 00:16:21,066
它就会进入这个EXC

496
00:16:21,400 --> 00:16:22,200
这个状态

497
00:16:22,466 --> 00:16:23,933
那么下面是什么呢

498
00:16:23,933 --> 00:16:25,199
如果一个进程啊

499
00:16:26,600 --> 00:16:28,866
怎么样如果是出于什么你

500
00:16:28,866 --> 00:16:29,599
看这这个名字

501
00:16:29,600 --> 00:16:31,333
你看如果他处于退出态

502
00:16:31,333 --> 00:16:34,566
或者是他是这个啊僵尸态的话啊

503
00:16:34,800 --> 00:16:37,466
那么我们就给他身上贴个标签

504
00:16:37,466 --> 00:16:39,699
说他是非活跃的进程啊

505
00:16:39,700 --> 00:16:40,733
非活跃的进程

506
00:16:43,200 --> 00:16:43,933
好

507
00:16:43,933 --> 00:16:45,333
那么这个是什么呢

508
00:16:45,333 --> 00:16:46,599
前面说的就是说

509
00:16:46,600 --> 00:16:48,166
一些进程基本信息

510
00:16:48,166 --> 00:16:49,966
和关于县城的一些信息

511
00:16:50,366 --> 00:16:51,566
那我们看一下啊

512
00:16:51,566 --> 00:16:52,366
进程

513
00:16:52,466 --> 00:16:55,399
PCB结构体中还有一些和内存相关的

514
00:16:55,800 --> 00:16:56,866
结构体啊

515
00:16:56,966 --> 00:17:00,799
那好那么进程与内存相关的就是啊

516
00:17:00,800 --> 00:17:01,766
就只有谁啊

517
00:17:01,766 --> 00:17:04,299
lost VM space一个程序变量

518
00:17:04,466 --> 00:17:06,133
那么我们管这个程序变量叫做什么

519
00:17:06,133 --> 00:17:08,733
叫做进程的啊进程空间

520
00:17:08,900 --> 00:17:11,166
或者说说更说啊

521
00:17:11,166 --> 00:17:12,966
更详细点就是进程的地址空间啊

522
00:17:12,966 --> 00:17:14,666
或者进程的虚拟地址空间

523
00:17:15,400 --> 00:17:16,866
那么每一个用户进程

524
00:17:17,100 --> 00:17:19,900
均拥有自己独立的进程空间

525
00:17:20,333 --> 00:17:21,666
相互之间不可见

526
00:17:21,866 --> 00:17:24,333
那么实现进程间隔离

527
00:17:25,066 --> 00:17:28,333
独立进程空间意味着每个进程都要将

528
00:17:28,566 --> 00:17:31,199
自己的虚拟内存和物理内存进行影射

529
00:17:31,766 --> 00:17:35,166
并将影射区保存在自己的进程空间

530
00:17:35,933 --> 00:17:37,266
另外进程

531
00:17:37,866 --> 00:17:39,766
另外进程的代码段

532
00:17:40,100 --> 00:17:41,966
数据段对战段

533
00:17:42,500 --> 00:17:45,500
影射段都保存在自己的这个空间中

534
00:17:45,900 --> 00:17:46,733
啊也就是说

535
00:17:46,733 --> 00:17:48,533
后面我们讲这个虚拟地址空间的时候

536
00:17:48,533 --> 00:17:49,499
我们就会看到

537
00:17:49,533 --> 00:17:51,366
那么这个实际上就是一个红黑竖结构

538
00:17:51,366 --> 00:17:52,899
啊这是个红黑竖结构

539
00:17:52,900 --> 00:17:55,466
每一个节点是一个VM region

540
00:17:55,766 --> 00:17:57,366
VM region啊VM region

541
00:17:57,466 --> 00:17:59,699
那么比如说他在这说的有代码段

542
00:17:59,700 --> 00:18:02,133
数据段对战段影射影射段

543
00:18:02,333 --> 00:18:03,533
那么这个

544
00:18:03,966 --> 00:18:06,299
这个v各个VM region就是什么

545
00:18:06,300 --> 00:18:09,266
就就就就是比如说某一个VM region是

546
00:18:09,400 --> 00:18:10,900
这个代码段有个

547
00:18:10,900 --> 00:18:12,733
某一个VM region是数据段

548
00:18:12,733 --> 00:18:13,199
某一个VM

549
00:18:13,200 --> 00:18:14,866
region是对战段啊

550
00:18:14,866 --> 00:18:17,499
有一个VM region是这个影射区啊

551
00:18:17,500 --> 00:18:18,333
都在这里头

552
00:18:18,333 --> 00:18:19,133
都在这里头

553
00:18:19,200 --> 00:18:20,533
那为什么要用红黑竖呢

554
00:18:20,533 --> 00:18:21,733
就是因为红黑竖怎么样

555
00:18:21,733 --> 00:18:24,766
它的这个就是进行搜索和便利的

556
00:18:24,766 --> 00:18:26,199
这个算法复杂度是比较低的

557
00:18:26,200 --> 00:18:27,366
而没有用列表

558
00:18:28,866 --> 00:18:29,666
那么

559
00:18:31,000 --> 00:18:34,066
但呢内核态进程啊你看用户态呢

560
00:18:34,200 --> 00:18:36,966
用户态进程这个VM reason啊VM space

561
00:18:36,966 --> 00:18:37,999
这个数据结构呢

562
00:18:38,000 --> 00:18:38,800
怎么样

563
00:18:39,166 --> 00:18:39,999
在用户空间中

564
00:18:40,000 --> 00:18:40,766
每一个进程

565
00:18:40,766 --> 00:18:42,733
他们都有自己独立的进程空间

566
00:18:42,866 --> 00:18:44,799
但是对于内核态进程来讲

567
00:18:44,800 --> 00:18:47,866
他们都共用内核的内核地质空间啊

568
00:18:47,933 --> 00:18:49,533
因此呢只影射一次

569
00:18:50,166 --> 00:18:52,333
那么这里头呢这个VM space

570
00:18:52,466 --> 00:18:53,566
这个数据结构非常复杂

571
00:18:53,566 --> 00:18:55,599
我们在讲虚拟基础空间的时候将会

572
00:18:56,166 --> 00:18:56,999
引入这些概念

573
00:18:57,000 --> 00:18:58,333
因为它涉及到虚拟内存

574
00:18:58,333 --> 00:19:00,533
物理内存线性地址影射关系

575
00:19:00,900 --> 00:19:02,766
共享内存分配回收啊

576
00:19:02,766 --> 00:19:04,366
页面置换等概念啊

577
00:19:04,566 --> 00:19:06,166
是非常复杂的一个数据结构

578
00:19:07,366 --> 00:19:11,199
好那我们刚才讲的是和内存的关系啊

579
00:19:11,300 --> 00:19:14,400
那现在我们来讲什么和文件的关系啊

580
00:19:15,066 --> 00:19:17,066
那么进程与文件系统有关的

581
00:19:17,066 --> 00:19:17,933
就指有谁啊

582
00:19:17,933 --> 00:19:20,166
filestract的结构体啊

583
00:19:20,166 --> 00:19:21,499
filestract

584
00:19:21,900 --> 00:19:22,566
这有个指针

585
00:19:22,566 --> 00:19:23,466
FILES指针

586
00:19:23,733 --> 00:19:25,066
文件呢也是一个

587
00:19:25,066 --> 00:19:26,933
也是什么很复杂的一大块

588
00:19:26,933 --> 00:19:27,733
那么后续呢

589
00:19:27,733 --> 00:19:30,499
我们在讲解文件系统实现的时候呢

590
00:19:30,500 --> 00:19:32,900
主要是该讲解这个结构体啊

591
00:19:32,900 --> 00:19:33,666
这个结构体

592
00:19:33,666 --> 00:19:34,766
那我们待会后面看

593
00:19:34,766 --> 00:19:37,266
创建进程的也会稍微涉及到这些结构

594
00:19:37,500 --> 00:19:39,300
涉及到一些这些结构体的内容

595
00:19:39,766 --> 00:19:41,166
一个真实的物理文件

596
00:19:41,166 --> 00:19:43,066
那么在类优那个操作系统中

597
00:19:43,066 --> 00:19:44,099
一个真实的物理文件

598
00:19:44,100 --> 00:19:45,966
实际上就是一个i know的结构体

599
00:19:46,200 --> 00:19:46,766
那么可以

600
00:19:46,766 --> 00:19:48,766
同时被多个进程打开

601
00:19:48,766 --> 00:19:50,166
后面我们会说啊

602
00:19:50,533 --> 00:19:53,933
那么并有进程独立的文件描述符

603
00:19:54,166 --> 00:19:55,966
就是file ID啊

604
00:19:56,066 --> 00:19:57,499
i f ID啊就是

605
00:19:57,600 --> 00:19:58,800
就是这个是呃

606
00:19:58,800 --> 00:20:00,400
每一个文件的文件描述符

607
00:20:00,900 --> 00:20:05,900
进程文件描述符就是process file descriptor

608
00:20:05,966 --> 00:20:08,699
那么后边会影射到系统文件描述符

609
00:20:08,800 --> 00:20:10,900
就是system file descriptor

610
00:20:11,000 --> 00:20:13,333
那么我们后面会给大家举例子来说啊

611
00:20:13,333 --> 00:20:16,666
说一下这个process FD和system FD它俩俩

612
00:20:16,666 --> 00:20:17,966
它两个是什么关系

613
00:20:18,166 --> 00:20:19,699
为什么有了一个system FD

614
00:20:19,700 --> 00:20:21,133
又有一个process FD

615
00:20:21,900 --> 00:20:23,200
系统文件描述符呢

616
00:20:23,200 --> 00:20:25,300
有三个特色特殊的系统文件描述

617
00:20:25,300 --> 00:20:26,466
分别是012啊

618
00:20:26,466 --> 00:20:28,733
012 分别代表的是谁呢

619
00:20:28,733 --> 00:20:29,533
代表的是0

620
00:20:29,533 --> 00:20:31,666
代表的是这个0号文件描述符

621
00:20:31,666 --> 00:20:32,933
代表的是什么呢

622
00:20:33,100 --> 00:20:35,800
代表的是标准书就是STD in啊

623
00:20:35,900 --> 00:20:36,733
standard in

624
00:20:36,800 --> 00:20:39,366
1号文件描述符代表的是标准输出

625
00:20:39,366 --> 00:20:42,299
STD out 2号描述符代表的是标准错误

626
00:20:42,300 --> 00:20:43,966
就是STD error啊

627
00:20:43,966 --> 00:20:45,999
他们是默认被系统占用

628
00:20:46,266 --> 00:20:47,499
被内核占用

629
00:20:47,533 --> 00:20:49,599
那么任何进程的文件描述符

630
00:20:49,600 --> 00:20:53,966
前三个啊都是这三个文件描述符

631
00:20:54,466 --> 00:20:55,299
那么默认呢

632
00:20:55,300 --> 00:20:58,600
已经打开可以直接往里面读写数据

633
00:20:59,166 --> 00:21:01,133
文件影像跟内存影射一样啊

634
00:21:01,133 --> 00:21:02,099
每个进程

635
00:21:02,466 --> 00:21:05,766
都需要单独对同一个文件进行影射

636
00:21:05,900 --> 00:21:08,333
那么配置myping记录了这种影射关系

637
00:21:08,400 --> 00:21:11,166
而夜高速缓存就是page catch

638
00:21:11,166 --> 00:21:14,866
提供了文件实际内存存放的位置啊

639
00:21:14,866 --> 00:21:18,299
那这也是虚拟内存要讲的一些内内容

640
00:21:18,800 --> 00:21:22,266
那么文内存文件的置换啊

641
00:21:22,266 --> 00:21:23,599
你看这不有双向箭头吗

642
00:21:23,600 --> 00:21:25,333
就是内存和文件的置换

643
00:21:25,466 --> 00:21:28,299
内存在在什么内存空间文件在什么

644
00:21:28,366 --> 00:21:29,766
在硬盘上对吧

645
00:21:29,866 --> 00:21:32,733
那么它的置换是以啊ear为单位

646
00:21:32,733 --> 00:21:33,366
ear多大呢

647
00:21:33,366 --> 00:21:37,333
是4K那进程并不能对文件直接啊

648
00:21:37,333 --> 00:21:38,699
对硬盘文件直接操作

649
00:21:38,700 --> 00:21:41,966
必须通过页高速缓存啊page cash来完成

650
00:21:42,266 --> 00:21:45,099
那么其中会涉及到一些经典的概念

651
00:21:45,100 --> 00:21:46,933
比如说写示拷贝等技术

652
00:21:46,966 --> 00:21:48,866
那么这个我们在be catch里会

653
00:21:48,966 --> 00:21:50,733
会会讨论这个问题啊

654
00:21:50,733 --> 00:21:52,299
be catch啊be catch

655
00:21:53,600 --> 00:21:55,500
那么其他还有一些什么呢

656
00:21:55,500 --> 00:21:56,466
还有一些啊

657
00:21:56,466 --> 00:21:58,199
在PCB中还有一些其他的这些

658
00:21:58,200 --> 00:22:00,933
比如说啊跟用户相关的啊用户啊

659
00:22:00,966 --> 00:22:02,566
这个进程是谁创建的

660
00:22:02,666 --> 00:22:04,999
那么还有一些就是他的这个能

661
00:22:05,100 --> 00:22:06,133
他的这个安全

662
00:22:06,266 --> 00:22:08,299
安全权限是这样啥样的

663
00:22:08,466 --> 00:22:09,566
比如说还有这个是啥呢

664
00:22:09,566 --> 00:22:11,999
这个是如果这个进程要执行文件的话

665
00:22:12,000 --> 00:22:13,766
那这个他所执行的这个文件

666
00:22:13,900 --> 00:22:14,566
看到了吧

667
00:22:14,566 --> 00:22:15,599
我们刚才说状态

668
00:22:15,600 --> 00:22:17,066
是不是有一个EXC状态

669
00:22:17,066 --> 00:22:19,199
对吧那么如果他要执行文件的话

670
00:22:19,200 --> 00:22:21,300
那这个可执行文件啊

671
00:22:21,533 --> 00:22:24,366
也也是有一个file指针来指向的

672
00:22:24,400 --> 00:22:25,200
啊

673
00:22:25,866 --> 00:22:26,566
那么以上呢

674
00:22:26,566 --> 00:22:28,133
我们大概就把这个

675
00:22:28,300 --> 00:22:30,566
PCB的一些重要的数据结构成员

676
00:22:30,566 --> 00:22:32,066
给大家做了一个简要介绍

677
00:22:32,266 --> 00:22:34,599
后面我们就要看啊进程创建的时候

678
00:22:34,733 --> 00:22:35,733
那么这些数据成员

679
00:22:35,733 --> 00:22:37,499
到底是怎么样进行初始化的

680
00:22:38,266 --> 00:22:39,299
啊好

681
00:22:39,800 --> 00:22:40,600
那么

682
00:22:41,066 --> 00:22:43,766
这这部分内容呢我们就先讲到这儿

