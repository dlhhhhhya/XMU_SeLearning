1
00:00:01,566 --> 00:00:03,166
各位同学大家好

2
00:00:03,400 --> 00:00:03,866
这一讲

3
00:00:03,866 --> 00:00:06,899
我们给大家介绍鸿蒙赖刀s任务调度

4
00:00:07,100 --> 00:00:08,533
与软石中处理

5
00:00:11,466 --> 00:00:12,266
首先

6
00:00:12,466 --> 00:00:14,699
本章主要介绍两方面内容

7
00:00:14,700 --> 00:00:15,400
第一内容

8
00:00:15,400 --> 00:00:19,300
第一方面内容是任务调度的数据结构

9
00:00:19,500 --> 00:00:22,166
第二部分内容是任务调度的具体实践

10
00:00:22,166 --> 00:00:22,966
函数

11
00:00:23,733 --> 00:00:26,199
首先我们来看一下任务调度的

12
00:00:26,533 --> 00:00:27,699
核心数据结构

13
00:00:27,900 --> 00:00:30,000
它主要是schedule run q

14
00:00:30,533 --> 00:00:31,333
那么

15
00:00:31,966 --> 00:00:35,066
在schedule run q中包含了这样一些数据项

16
00:00:35,400 --> 00:00:37,133
第一项time out q

17
00:00:37,966 --> 00:00:40,299
链接与时钟相关的任务

18
00:00:40,566 --> 00:00:41,366
如

19
00:00:41,466 --> 00:00:42,899
软件定时器任务

20
00:00:43,100 --> 00:00:45,400
software TIMER task

21
00:00:45,866 --> 00:00:46,599
因

22
00:00:46,600 --> 00:00:49,166
执行带时钟阻塞的任务

23
00:00:50,766 --> 00:00:54,299
HPF run q是任务的就绪队列

24
00:00:54,766 --> 00:00:55,799
response time

25
00:00:56,400 --> 00:01:00,200
CPU需要进行响应的最近时间点

26
00:01:00,366 --> 00:01:02,799
主要用于处理time out q中的任务

27
00:01:03,000 --> 00:01:06,266
以防其过期得不到及时的处理

28
00:01:06,866 --> 00:01:10,099
那么更准确地说response time是什么呢是

29
00:01:10,366 --> 00:01:11,166
啊

30
00:01:11,466 --> 00:01:15,099
time out q和run q这两个队列中啊

31
00:01:15,100 --> 00:01:17,533
最早的最早到期的那个时间

32
00:01:18,166 --> 00:01:19,199
response ID

33
00:01:19,400 --> 00:01:21,333
需要CPU响应的进程ID

34
00:01:21,600 --> 00:01:25,066
如果它是一个数啊是一个就是是一个

35
00:01:25,066 --> 00:01:25,733
是一个什么呢

36
00:01:25,733 --> 00:01:26,733
是一个合法的数

37
00:01:27,100 --> 00:01:28,366
那么则表示就绪

38
00:01:28,366 --> 00:01:30,333
这是一个就绪队列中的进程

39
00:01:30,466 --> 00:01:32,133
如果是OS e validate

40
00:01:32,266 --> 00:01:33,966
那么也就是说它是一个无效数

41
00:01:33,966 --> 00:01:36,399
那么则表示当前啊

42
00:01:36,566 --> 00:01:37,999
当前啊最

43
00:01:38,400 --> 00:01:40,300
最先过期的是这个任务

44
00:01:40,300 --> 00:01:41,733
处于这个time out q中

45
00:01:42,566 --> 00:01:44,566
idle task空闲任务ID

46
00:01:44,566 --> 00:01:47,499
CPU无任务运行时就运行这个task

47
00:01:47,800 --> 00:01:51,466
task law count就绪队列中任务的持所数

48
00:01:51,933 --> 00:01:52,999
schedule flag

49
00:01:53,000 --> 00:01:55,700
与调度和时间处理相关的标志

50
00:01:56,166 --> 00:01:56,966
那么

51
00:01:57,866 --> 00:02:00,066
如果是int pandek

52
00:02:00,200 --> 00:02:02,366
这就是这个schedule flag啊

53
00:02:02,533 --> 00:02:03,766
那主要有两个

54
00:02:03,766 --> 00:02:07,733
一个是independ reschedule一个是inde pandek

55
00:02:08,000 --> 00:02:11,900
那么因int pandek表示有未处理的

56
00:02:12,166 --> 00:02:13,999
影响response time的事件

57
00:02:14,333 --> 00:02:17,066
而intend schedule表示有被处理的

58
00:02:17,300 --> 00:02:19,100
需要进程调度的事件

59
00:02:23,000 --> 00:02:27,666
那么另第二个是HPF run q这个数据结构

60
00:02:27,700 --> 00:02:29,500
那么这个q list

61
00:02:29,500 --> 00:02:31,500
是32个优先级的就绪队列

62
00:02:32,133 --> 00:02:34,099
q beat map是32位图

63
00:02:34,100 --> 00:02:35,166
32位图

64
00:02:36,100 --> 00:02:37,366
用于快速计算

65
00:02:37,533 --> 00:02:40,199
系统当前具有最高优先级的就绪任务

66
00:02:41,266 --> 00:02:42,066
那么

67
00:02:43,200 --> 00:02:46,300
这个q list是一个HPFQ的数据结构

68
00:02:46,600 --> 00:02:49,500
那么这个HPFQ呢包含三个数据项

69
00:02:49,500 --> 00:02:52,166
分别是priority q list

70
00:02:52,533 --> 00:02:54,599
32个优先级的就绪队列

71
00:02:54,900 --> 00:02:57,966
red task每个就绪队列中的任务数

72
00:02:58,300 --> 00:03:00,100
QBID map 32位图

73
00:03:00,333 --> 00:03:02,066
用于快速计算

74
00:03:02,100 --> 00:03:04,900
系统当前具有最高优先级的就绪任务

75
00:03:05,333 --> 00:03:06,599
那么需要说明的是

76
00:03:06,700 --> 00:03:09,500
HPFQ设置了32个优先级队列

77
00:03:09,766 --> 00:03:11,866
和q beat map的原因

78
00:03:12,400 --> 00:03:15,133
是任务的优先级会在运行时

79
00:03:15,366 --> 00:03:17,133
被临时调整即

80
00:03:17,566 --> 00:03:20,066
任务包含base priority priority

81
00:03:20,333 --> 00:03:23,666
那么在优先级反转中啊会对

82
00:03:23,900 --> 00:03:25,166
对这个进行论述

83
00:03:26,500 --> 00:03:28,400
那么介绍完了任务调度的

84
00:03:28,500 --> 00:03:29,600
核心数据结构之后呢

85
00:03:29,600 --> 00:03:31,866
我们就来看一下任务调度相关的

86
00:03:32,000 --> 00:03:32,866
实线函数

87
00:03:33,733 --> 00:03:36,566
那么我们从时钟中段开始讲起啊

88
00:03:36,566 --> 00:03:38,599
时钟中段开始讲起因为我们知道啊

89
00:03:38,666 --> 00:03:41,199
如果我们采用的这个调度方式是

90
00:03:41,200 --> 00:03:42,200
round the Robin啊

91
00:03:42,200 --> 00:03:43,800
就是是时间片轮转的话

92
00:03:43,800 --> 00:03:47,466
那么每一个任务被分配了一个

93
00:03:48,933 --> 00:03:50,466
一个时间片来运行

94
00:03:50,466 --> 00:03:51,533
那么每一个

95
00:03:51,600 --> 00:03:55,066
生中段都会对这个时间片进行处理

96
00:03:56,366 --> 00:03:58,533
当一个任务的时间片到达的时候

97
00:03:58,533 --> 00:04:00,866
就是当一个任务的时间片耗尽的时候

98
00:04:00,866 --> 00:04:03,866
那么就会引引发这个进行调度

99
00:04:03,933 --> 00:04:08,699
那么在Letos中OS guidetik这个函数就是啊

100
00:04:08,700 --> 00:04:10,533
我们中段一张中讲

101
00:04:10,533 --> 00:04:11,766
中段的一张也讲了这个

102
00:04:11,766 --> 00:04:14,066
OS guidetik这个函数就是

103
00:04:14,166 --> 00:04:14,733
就是什么

104
00:04:14,733 --> 00:04:16,733
就是Letos中的这个时钟中段

105
00:04:17,200 --> 00:04:18,100
那好我们来看一下

106
00:04:18,100 --> 00:04:20,266
这个试用中段主要做了几件事情

107
00:04:20,566 --> 00:04:21,566
那么第一件事情

108
00:04:21,566 --> 00:04:24,699
就是获取当前CPU的RANQ运

109
00:04:24,700 --> 00:04:25,866
就是就绪队列

110
00:04:27,266 --> 00:04:29,966
那么如果啊run kill的response ID

111
00:04:29,966 --> 00:04:31,999
它的值为OS evaluate value

112
00:04:32,066 --> 00:04:32,999
也就是说啊

113
00:04:33,000 --> 00:04:34,900
你看这个response ID在前面说了啊

114
00:04:34,900 --> 00:04:38,066
如果这个response ID呢是evaluate value表示

115
00:04:38,666 --> 00:04:40,466
下一个到期时间是time out

116
00:04:40,733 --> 00:04:42,999
time out队列就是time out时钟啊

117
00:04:43,000 --> 00:04:44,066
时钟到期了

118
00:04:44,200 --> 00:04:46,266
所以这个就表示时钟到期了

119
00:04:46,266 --> 00:04:48,666
那怎么样呢就schedule time out q scan

120
00:04:48,733 --> 00:04:50,899
那我就要怎么样我就要扫描什么呢

121
00:04:50,900 --> 00:04:53,733
那么我告诉大家这个也是这个啊

122
00:04:53,733 --> 00:04:54,733
这个是一个什么呢

123
00:04:54,733 --> 00:04:58,399
这个这是一个salt link list啊salt link a tribute

124
00:04:58,500 --> 00:04:58,966
它是一个啥呀

125
00:04:58,966 --> 00:05:00,399
它是一个排序队列啊

126
00:05:00,400 --> 00:05:01,200
排序队列

127
00:05:01,200 --> 00:05:03,700
我们在讲的时候讲过这排序队列对吧

128
00:05:05,133 --> 00:05:07,666
那它显然也是一个Pro CPU的一个

129
00:05:07,666 --> 00:05:08,466
数据结构

130
00:05:08,600 --> 00:05:09,766
那它怎么样呢

131
00:05:09,866 --> 00:05:12,466
它叫扫描这个type out对列啊

132
00:05:12,466 --> 00:05:14,299
扫描run queue的time out队列

133
00:05:14,366 --> 00:05:16,933
看是否有任务的处理时间到期

134
00:05:16,933 --> 00:05:17,733
如果有

135
00:05:18,733 --> 00:05:19,533
则啊

136
00:05:19,866 --> 00:05:21,999
如果有则调用这个啊

137
00:05:22,000 --> 00:05:24,466
则这个schedule time out scan

138
00:05:24,666 --> 00:05:25,333
q scan

139
00:05:25,333 --> 00:05:26,199
返回处啊

140
00:05:26,200 --> 00:05:29,300
那么返回处如果没有它就返回false那

141
00:05:29,300 --> 00:05:32,333
那如果有有的话就返回处那有返

142
00:05:32,333 --> 00:05:33,333
回处了怎么办呢

143
00:05:33,333 --> 00:05:34,866
你看他就把这个什么呢

144
00:05:35,133 --> 00:05:36,133
它就在这一步怎么样

145
00:05:36,133 --> 00:05:39,299
如果run q的time out队列中有任务到期

146
00:05:39,300 --> 00:05:40,866
那我们就要设置什么呢

147
00:05:40,933 --> 00:05:43,366
设置这个run q的schedule flag

148
00:05:43,400 --> 00:05:44,466
把它设置成什么呢

149
00:05:44,466 --> 00:05:47,066
就Intel pand reschedule标记

150
00:05:47,300 --> 00:05:48,000
那么表示什么呢

151
00:05:48,000 --> 00:05:50,400
表示表示因为他有有任务到期了

152
00:05:50,400 --> 00:05:52,933
所以我就怎么样我就要设置任务调度

153
00:05:52,966 --> 00:05:54,466
我要进行任务调度啊

154
00:05:54,466 --> 00:05:55,099
任务调度

155
00:05:55,100 --> 00:05:57,333
那任务调度的时候就会调度什么呢

156
00:05:57,333 --> 00:05:57,599
会

157
00:05:57,600 --> 00:06:00,066
待会我们看时钟的时候就调度这个

158
00:06:00,300 --> 00:06:01,500
时钟处理的任务

159
00:06:01,766 --> 00:06:02,866
时钟处理的任务

160
00:06:02,866 --> 00:06:03,866
然后时钟处理的任务

161
00:06:03,866 --> 00:06:05,933
就会扫描这个time out的队列

162
00:06:05,933 --> 00:06:08,266
然后把这些过期的时钟都处理完毕

163
00:06:08,500 --> 00:06:09,300
啊

164
00:06:10,866 --> 00:06:14,666
然后呢第五是执行OS sky do Tik表示

165
00:06:14,800 --> 00:06:17,200
当执行o s sky do Tik的时候呢

166
00:06:17,200 --> 00:06:18,966
就表示使用中断并执行

167
00:06:19,100 --> 00:06:21,666
那因此无论怎么样我都要设置这个

168
00:06:21,966 --> 00:06:23,866
都要给run killed sky do flag

169
00:06:23,866 --> 00:06:25,266
设置这个intepend Tik

170
00:06:25,266 --> 00:06:26,066
这个标记

171
00:06:26,200 --> 00:06:27,533
从而引发什么呢

172
00:06:27,533 --> 00:06:28,799
引发啊

173
00:06:28,800 --> 00:06:29,866
引发什么呢

174
00:06:29,966 --> 00:06:33,533
引发这个schedule next expare time set

175
00:06:33,933 --> 00:06:34,699
这个这个

176
00:06:34,700 --> 00:06:35,400
这个函数就要

177
00:06:35,400 --> 00:06:36,866
这是我们后面要讲的一个非常

178
00:06:36,866 --> 00:06:37,499
重要的函数

179
00:06:37,500 --> 00:06:39,966
就是这个schedule next expare time set

180
00:06:40,300 --> 00:06:41,466
那么这个函数来干嘛呢

181
00:06:41,466 --> 00:06:42,399
用来更新

182
00:06:42,600 --> 00:06:43,966
run queue的response time

183
00:06:43,966 --> 00:06:45,933
和run queue的response ID啊

184
00:06:45,933 --> 00:06:48,733
它是主要干这这么两件事情啊

185
00:06:48,766 --> 00:06:50,166
引发这个调调用

186
00:06:51,000 --> 00:06:52,066
那我们看一下啊

187
00:06:52,066 --> 00:06:52,866
我们看一下

188
00:06:52,900 --> 00:06:54,100
在这里头呢

189
00:06:54,366 --> 00:06:55,533
在这里头啊

190
00:06:55,533 --> 00:06:56,166
在这里头呢

191
00:06:56,166 --> 00:06:57,166
他他是什么

192
00:06:57,166 --> 00:06:58,566
首先是扫描了一下对吧

193
00:06:58,566 --> 00:06:59,499
扫描了一下

194
00:06:59,866 --> 00:07:00,766
然后呢

195
00:07:00,866 --> 00:07:02,933
设置了一个标记设置一下标记

196
00:07:02,933 --> 00:07:03,733
看到了吧

197
00:07:03,766 --> 00:07:04,699
设置一下标记

198
00:07:04,766 --> 00:07:06,566
好那我们接着往下看啊

199
00:07:07,466 --> 00:07:09,533
好我们看一下这个schedule time out

200
00:07:09,533 --> 00:07:10,799
q scan这个函数

201
00:07:10,866 --> 00:07:12,866
那我们刚才说了这个函数是干嘛呢

202
00:07:12,866 --> 00:07:14,666
实际上就是扫描什么呢

203
00:07:14,766 --> 00:07:16,566
扫描这个run q的啥呢

204
00:07:16,566 --> 00:07:18,766
扫描run q的time out q队列

205
00:07:18,866 --> 00:07:21,866
来查看是否有过期的这个失踪啊

206
00:07:21,866 --> 00:07:23,966
过期的失踪好我们沿着这个来看

207
00:07:24,200 --> 00:07:25,533
首先第一件事情就是说

208
00:07:25,533 --> 00:07:26,466
第这步就是什么

209
00:07:26,466 --> 00:07:29,199
获取run q的time out队列的手节点

210
00:07:29,600 --> 00:07:33,666
然后呢把它存储在这个list object里

211
00:07:33,666 --> 00:07:37,499
list object然后判断这个list object这个run q

212
00:07:38,200 --> 00:07:40,900
这个这个胎帽对列是否为空啊

213
00:07:40,900 --> 00:07:43,700
如果是空的话那就直接返回啊

214
00:07:43,700 --> 00:07:44,533
直接返回

215
00:07:44,733 --> 00:07:47,133
那么这个你看这个need restire等于false

216
00:07:47,133 --> 00:07:49,266
也就表示它不需要进行任务调度

217
00:07:49,700 --> 00:07:51,600
那否则的话就继续往下执行

218
00:07:51,700 --> 00:07:53,400
那继续往下执行干嘛呢

219
00:07:53,566 --> 00:07:55,399
那么获取当前的

220
00:07:55,400 --> 00:07:56,366
你看啊在他在这

221
00:07:56,366 --> 00:07:58,699
你看他在这就获取了当前的时间

222
00:07:58,700 --> 00:08:00,166
为什么要获取当前时间呢

223
00:08:00,166 --> 00:08:01,133
因为他要扫描

224
00:08:01,700 --> 00:08:03,566
那个任务超时队列里啊

225
00:08:03,566 --> 00:08:05,599
你看他你看他就扫描什么呢

226
00:08:05,600 --> 00:08:07,700
任务超时队列中的每一个

227
00:08:07,700 --> 00:08:10,200
每一个超时时间是不是小于

228
00:08:10,333 --> 00:08:11,299
当前的时间

229
00:08:11,366 --> 00:08:12,733
如果小于的话表示什么意思

230
00:08:12,733 --> 00:08:14,333
就表示这个时钟已经过期了

231
00:08:14,333 --> 00:08:15,133
是不是这样啊

232
00:08:15,166 --> 00:08:16,266
如果小于你看

233
00:08:16,400 --> 00:08:19,000
所以在第4就是什么便利Timot队列

234
00:08:19,000 --> 00:08:21,300
判断Timod队列的当前节点是否

235
00:08:21,866 --> 00:08:22,899
把过期时间

236
00:08:22,900 --> 00:08:25,766
也就是response time是否小于当前时间

237
00:08:25,766 --> 00:08:28,133
如果成成立就表示当前这个节点已经

238
00:08:28,133 --> 00:08:30,399
过期了那过期了怎么办呢

239
00:08:30,500 --> 00:08:31,766
过期了就要怎么样呢

240
00:08:31,766 --> 00:08:34,066
就要获得过期任务的TCB

241
00:08:34,533 --> 00:08:37,299
并从探报队列中删除过期任务的TCB

242
00:08:37,300 --> 00:08:38,000
看到了吧

243
00:08:38,000 --> 00:08:39,333
你看就是我要

244
00:08:39,366 --> 00:08:41,333
我要把这个过期任务的TCB拿到

245
00:08:41,333 --> 00:08:41,933
然后呢

246
00:08:41,933 --> 00:08:45,066
把这个TCB从这个探报队列里删除掉

247
00:08:45,366 --> 00:08:46,466
看到了吧删除掉

248
00:08:46,900 --> 00:08:50,000
然后呢第六步唤醒过期任务

249
00:08:50,100 --> 00:08:51,300
那么唤醒过期任务

250
00:08:51,300 --> 00:08:53,700
你看调用schedule time out task week

251
00:08:53,933 --> 00:08:55,666
把这个唤醒唤醒

252
00:08:55,733 --> 00:08:57,899
然后呢设置这个啊

253
00:08:58,000 --> 00:08:59,500
那么唤醒过期任务

254
00:08:59,500 --> 00:09:00,900
注意该函数中need need

255
00:09:01,866 --> 00:09:03,133
need need schedule

256
00:09:03,400 --> 00:09:04,766
那么如果成功唤醒

257
00:09:04,766 --> 00:09:07,299
则要将这个need schedule指指为处

258
00:09:07,300 --> 00:09:07,666
为什么呢

259
00:09:07,666 --> 00:09:08,733
因为我唤醒了一个任务

260
00:09:08,733 --> 00:09:11,133
那就有可能会引起这个竞争调度

261
00:09:11,400 --> 00:09:13,466
所以我要把这个need的reschedule给

262
00:09:13,866 --> 00:09:14,766
给指成处

263
00:09:14,900 --> 00:09:18,566
那么然后呢让time out指向下一个节点

264
00:09:18,566 --> 00:09:19,599
下一个节点然后继续

265
00:09:19,600 --> 00:09:21,100
这么便利啊这么便利

266
00:09:21,133 --> 00:09:21,966
那最后呢

267
00:09:21,966 --> 00:09:25,399
就返回这个need的schedule来表示是否有

268
00:09:25,766 --> 00:09:26,699
过期任务

269
00:09:26,733 --> 00:09:27,799
是否有过期任务

270
00:09:27,866 --> 00:09:28,933
如果要有过期任务呢

271
00:09:28,933 --> 00:09:31,866
这个need RES need schedule标记就被指为处了

272
00:09:31,866 --> 00:09:32,666
啊

273
00:09:33,600 --> 00:09:33,966
好

274
00:09:33,966 --> 00:09:37,733
下面我来看一下这个schedule time autosquake

275
00:09:37,733 --> 00:09:38,299
这是什么意思

276
00:09:38,300 --> 00:09:39,600
就是刚才在这说的

277
00:09:39,733 --> 00:09:42,533
就是说它便利了发现有有任务

278
00:09:42,533 --> 00:09:44,366
任务的到期时间已经到期了

279
00:09:44,366 --> 00:09:45,266
那它就怎么样

280
00:09:45,266 --> 00:09:46,599
它就要把这个任务唤醒

281
00:09:46,933 --> 00:09:47,933
那么我们看一下它

282
00:09:47,933 --> 00:09:49,199
它唤醒是什么意思呢

283
00:09:49,200 --> 00:09:51,100
就是显然就是要把这个任务

284
00:09:51,166 --> 00:09:52,133
变成什么呢

285
00:09:52,133 --> 00:09:54,133
由其他状态转换成就绪态

286
00:09:54,133 --> 00:09:55,599
把它插入到就绪队列里

287
00:09:55,866 --> 00:09:56,666
是不是这样啊

288
00:09:57,566 --> 00:10:01,366
所以首先呢就是那么注意HPF INQ

289
00:10:01,500 --> 00:10:02,766
啊到

290
00:10:02,900 --> 00:10:05,133
调用这个priority q insert中

291
00:10:05,333 --> 00:10:07,966
会被唤醒的状态设置为red

292
00:10:08,000 --> 00:10:08,766
那么也就是说

293
00:10:08,766 --> 00:10:11,133
这个这个地方并不用把这个指为red

294
00:10:11,133 --> 00:10:12,299
因为在这个in q里

295
00:10:12,300 --> 00:10:14,333
就会把这个任务的状态指成red

296
00:10:14,733 --> 00:10:15,799
所以我们看一下他干嘛呢

297
00:10:15,800 --> 00:10:18,800
他第一步就是将time out任务的状态

298
00:10:18,966 --> 00:10:21,166
保存在time status中啊

299
00:10:21,166 --> 00:10:22,599
这是一个临时状态中

300
00:10:22,766 --> 00:10:25,499
因为后面呢要对原始状

301
00:10:25,600 --> 00:10:27,466
原始状态进行修改啊

302
00:10:27,933 --> 00:10:28,866
第二步是干嘛呢

303
00:10:28,866 --> 00:10:31,566
第二步在这修改过期任务的状态

304
00:10:31,566 --> 00:10:32,933
清除其中的

305
00:10:33,000 --> 00:10:36,200
比如说OS task status spending spend time

306
00:10:36,600 --> 00:10:38,533
status delay等等这些状态

307
00:10:38,666 --> 00:10:39,166
第三呢

308
00:10:39,166 --> 00:10:43,099
就是如果任务处于OS task status判定状态

309
00:10:43,100 --> 00:10:44,733
也就是说如果是阻塞态

310
00:10:44,800 --> 00:10:48,400
还要将其从阻塞阻塞队列中移除啊

311
00:10:48,466 --> 00:10:49,266
如果

312
00:10:49,566 --> 00:10:50,266
任务

313
00:10:50,266 --> 00:10:51,399
没有被挂起

314
00:10:51,400 --> 00:10:52,766
如果任务没有被挂起

315
00:10:52,766 --> 00:10:54,466
看如果任务没有被挂起

316
00:10:54,866 --> 00:10:55,899
那这是表示没有

317
00:10:55,933 --> 00:10:56,699
这表示挂起

318
00:10:56,700 --> 00:10:58,500
如果没有被挂起则怎么样呢

319
00:10:58,500 --> 00:11:00,266
则将任务插入就绪队列

320
00:11:00,333 --> 00:11:03,299
将need resguide you设置成处然后返回

321
00:11:03,300 --> 00:11:03,933
看到了吧

322
00:11:03,933 --> 00:11:05,966
那在这个地方加一个注意是什么意思

323
00:11:05,966 --> 00:11:08,333
他并你看他把原来的状态清除掉了

324
00:11:08,333 --> 00:11:10,466
并没有设置他的Reddit啊

325
00:11:10,466 --> 00:11:11,699
为什么没有设置Redtit

326
00:11:11,700 --> 00:11:14,066
因为在in q inq这个函数里

327
00:11:14,100 --> 00:11:16,300
把这个任务的task的status

328
00:11:16,300 --> 00:11:17,666
设置成Redtit了啊

329
00:11:20,466 --> 00:11:22,099
好那么

330
00:11:22,866 --> 00:11:23,799
当啊

331
00:11:24,133 --> 00:11:25,333
大家看这个是什么呢

332
00:11:25,333 --> 00:11:28,699
OS schedule RQ and check need reschedule

333
00:11:28,700 --> 00:11:29,400
那这是什么意思呢

334
00:11:29,400 --> 00:11:30,400
这个是这个意思

335
00:11:30,900 --> 00:11:32,533
大家想一想我们刚才啊

336
00:11:32,533 --> 00:11:34,366
我们刚才执行这个函数是什么呢

337
00:11:34,366 --> 00:11:36,966
这个函数是一个时钟中断的响应函数

338
00:11:37,100 --> 00:11:37,500
也就是

339
00:11:37,500 --> 00:11:40,266
说当时钟发生的时候就会产生中断

340
00:11:40,266 --> 00:11:41,066
时钟中断

341
00:11:41,166 --> 00:11:42,766
那么生物中断就会调用这个函数

342
00:11:42,766 --> 00:11:43,799
那调用这个函数

343
00:11:43,800 --> 00:11:45,733
这个函数执行完毕之后就由什么呢

344
00:11:45,733 --> 00:11:47,866
中断返回到用户态是不是

345
00:11:47,900 --> 00:11:49,533
那在这个返回的过程中啊

346
00:11:49,533 --> 00:11:53,366
这个OS schedule IRQ and check need reschedule是什么

347
00:11:53,366 --> 00:11:55,799
你看就是说哎这个表示中断

348
00:11:55,900 --> 00:11:57,466
中断结束的时候

349
00:11:57,500 --> 00:11:59,100
也就是说在中断返回啊

350
00:11:59,100 --> 00:12:00,000
由内核太强

351
00:12:00,000 --> 00:12:00,766
用户在返回的时候

352
00:12:00,766 --> 00:12:02,533
这个函数就会自动被调用啊

353
00:12:02,533 --> 00:12:03,699
就会自动被调用

354
00:12:03,700 --> 00:12:05,333
那么感兴趣的同学可以看一下

355
00:12:05,333 --> 00:12:06,499
他是怎么被调用的啊

356
00:12:06,500 --> 00:12:07,600
他是怎么被调用的

357
00:12:07,600 --> 00:12:08,933
实际上是走那个

358
00:12:08,933 --> 00:12:10,599
实际上是在汇编语言进行

359
00:12:11,066 --> 00:12:12,533
对这个函数进行调用的啊

360
00:12:12,533 --> 00:12:13,566
你看系统呢

361
00:12:13,566 --> 00:12:15,899
从中段返回前会执行这个函数

362
00:12:16,066 --> 00:12:19,199
检查是否存在挂起的调度

363
00:12:19,200 --> 00:12:20,700
也就是也就是什么呢

364
00:12:20,700 --> 00:12:24,300
是否存在int pand riskydio标记skydio标记

365
00:12:24,566 --> 00:12:27,499
那么大家想一想啊如果我要是啊

366
00:12:27,500 --> 00:12:30,000
我要是执行了这个skyditmouse的时候

367
00:12:30,000 --> 00:12:32,700
你看啊你看我看一下啊

368
00:12:32,933 --> 00:12:34,699
你看在这啊在这

369
00:12:34,700 --> 00:12:36,533
如果这个地方返回是处的话

370
00:12:36,533 --> 00:12:37,533
那么他就会怎么样

371
00:12:37,533 --> 00:12:39,533
他会把run q的这个schedule flag

372
00:12:39,533 --> 00:12:40,699
指成independent

373
00:12:41,266 --> 00:12:42,266
risk guide you对吧

374
00:12:42,266 --> 00:12:42,966
risk guide you

375
00:12:42,966 --> 00:12:45,199
所以在中断返回的时候怎么样

376
00:12:45,200 --> 00:12:46,100
他就会判断啊

377
00:12:46,100 --> 00:12:47,066
他就会执行这个

378
00:12:47,066 --> 00:12:48,266
那执行这个干嘛呢

379
00:12:48,266 --> 00:12:49,799
你看啊他首先是什么呢

380
00:12:49,800 --> 00:12:51,366
首先是获得了

381
00:12:51,766 --> 00:12:54,333
当前的运正正在运行的这个任务

382
00:12:54,333 --> 00:12:55,399
看run task

383
00:12:55,566 --> 00:12:56,766
广东run task然后呢

384
00:12:56,766 --> 00:12:57,533
干嘛呢

385
00:12:57,533 --> 00:13:00,166
然后是更新这个run task的时间片

386
00:13:00,166 --> 00:13:00,866
看到了吧

387
00:13:00,866 --> 00:13:01,366
为什么呢

388
00:13:01,366 --> 00:13:03,466
大家看我刚才在时钟中断里其实

389
00:13:03,466 --> 00:13:04,466
并没有更新

390
00:13:04,500 --> 00:13:05,366
因为大家想一想

391
00:13:05,366 --> 00:13:08,333
如果我要是发生时钟中中中断的话

392
00:13:08,666 --> 00:13:08,999
那么

393
00:13:09,000 --> 00:13:11,533
就表示当前任务所运行的这个时间片

394
00:13:11,533 --> 00:13:12,566
减少了是不是

395
00:13:12,600 --> 00:13:13,900
所以他并没有在那个

396
00:13:13,900 --> 00:13:15,566
他是在这个地方进行更新的

397
00:13:15,566 --> 00:13:16,366
看到了吧

398
00:13:16,700 --> 00:13:18,066
它是在这进行更新的

399
00:13:18,133 --> 00:13:19,466
也就是每次中断的时候

400
00:13:19,466 --> 00:13:21,466
都会对当前任务所进行的实践片

401
00:13:21,466 --> 00:13:22,966
进行更新啊

402
00:13:22,966 --> 00:13:24,299
然后呢去判断啊

403
00:13:24,300 --> 00:13:26,866
你看拿着这个run queue的schedule flag

404
00:13:26,866 --> 00:13:28,866
和这个independent schedule去比

405
00:13:28,933 --> 00:13:31,266
如果是处的话那么就表示什么呢

406
00:13:31,266 --> 00:13:32,066
就表示有

407
00:13:32,500 --> 00:13:34,566
有需要进行任务调度的时候

408
00:13:34,566 --> 00:13:36,099
他就把这个标志指空

409
00:13:36,100 --> 00:13:36,600
看到了吧

410
00:13:36,600 --> 00:13:37,600
清除这个标志

411
00:13:37,733 --> 00:13:39,666
然后呢把当前任务入队

412
00:13:39,666 --> 00:13:41,866
看到了进入让让当前任务怎么样

413
00:13:42,200 --> 00:13:43,466
进入这个就绪队列

414
00:13:43,533 --> 00:13:44,366
然后呢

415
00:13:44,500 --> 00:13:47,566
通过top task get这个函数获得什么呢

416
00:13:47,600 --> 00:13:48,566
获得就绪队列里

417
00:13:48,566 --> 00:13:50,333
优先级最高的那个任务

418
00:13:50,333 --> 00:13:51,699
大家想一想啊如果

419
00:13:51,700 --> 00:13:52,766
然后在这判断

420
00:13:52,766 --> 00:13:54,766
如果当前任务和火

421
00:13:54,866 --> 00:13:57,699
当前就是正在CPU运行的这个任务

422
00:13:57,900 --> 00:13:58,366
和这个

423
00:13:58,366 --> 00:14:00,733
获得的这个优先级最高的任务不相等

424
00:14:00,733 --> 00:14:01,533
那这是什么意思啊

425
00:14:01,533 --> 00:14:02,066
大家想一想

426
00:14:02,066 --> 00:14:02,699
我得把这个我

427
00:14:02,700 --> 00:14:04,933
我已经把这个当前这个任务

428
00:14:04,933 --> 00:14:05,899
正在运行的这个任务

429
00:14:05,900 --> 00:14:07,100
插到继续队列里了

430
00:14:07,166 --> 00:14:09,133
所以我获得的这个最高任务

431
00:14:09,133 --> 00:14:11,166
就有可能是当前正在运行的任务

432
00:14:11,166 --> 00:14:13,599
对吧所以如果要是相等的话

433
00:14:13,600 --> 00:14:14,733
那我就什么也不用干了啊

434
00:14:14,733 --> 00:14:16,066
我就直接执行这个操

435
00:14:16,066 --> 00:14:18,099
这步操作需要怎么样呢

436
00:14:18,100 --> 00:14:19,566
就是来更新这个

437
00:14:19,800 --> 00:14:21,466
来更新这个response time

438
00:14:21,500 --> 00:14:23,600
这个OS guide you expare time update

439
00:14:23,600 --> 00:14:25,733
实际上就是更新run q的这个

440
00:14:26,300 --> 00:14:27,100
更新run q

441
00:14:27,100 --> 00:14:29,733
的这个这个这个response time啊

442
00:14:29,733 --> 00:14:31,699
更新这个啊更新这个

443
00:14:32,700 --> 00:14:34,366
我就只需要更新就可以了

444
00:14:34,366 --> 00:14:35,999
那反之啊反之

445
00:14:36,533 --> 00:14:39,366
如果要是我选出来的这个新任务

446
00:14:39,733 --> 00:14:41,766
和我正在运行这个任务不等

447
00:14:41,766 --> 00:14:42,566
那怎么办呢

448
00:14:42,566 --> 00:14:46,266
那我就要调用schedule task switch啊switch

449
00:14:46,266 --> 00:14:46,933
那这是什么

450
00:14:46,933 --> 00:14:48,666
通通过这个名字你就可以知道这什么

451
00:14:48,666 --> 00:14:50,699
用新的任务来代替旧的任务

452
00:14:50,733 --> 00:14:51,133
这时候

453
00:14:51,133 --> 00:14:53,733
正在运行这个run task就进入旧序态

454
00:14:53,733 --> 00:14:54,699
而这个re

455
00:14:54,700 --> 00:14:57,166
new task就由旧序态转换成什么呢

456
00:14:57,166 --> 00:14:58,099
运行态了

457
00:14:59,266 --> 00:15:00,066
好

458
00:15:00,400 --> 00:15:02,300
那么我们来看一下这个函数啊

459
00:15:02,300 --> 00:15:03,966
首先看一下这个函数这个函数

460
00:15:04,066 --> 00:15:05,999
这个函数调用最终调用的是什么呢

461
00:15:06,000 --> 00:15:07,500
就是更新当前任务的时间

462
00:15:07,500 --> 00:15:08,533
运行的时间片

463
00:15:08,733 --> 00:15:10,766
它调用它这个函数啊

464
00:15:10,766 --> 00:15:12,366
它这个函数实际上调用的

465
00:15:12,366 --> 00:15:13,099
最后调用的是

466
00:15:13,100 --> 00:15:14,866
HPF time slice update

467
00:15:15,166 --> 00:15:16,466
啊times less update

468
00:15:16,466 --> 00:15:18,499
那我们看一下它是怎么做的呢

469
00:15:18,533 --> 00:15:20,466
carry time就是当前的时间

470
00:15:20,500 --> 00:15:22,500
那当前的时间减去什么呢

471
00:15:22,566 --> 00:15:23,299
这个是什么呢

472
00:15:23,300 --> 00:15:25,466
这个就是这个这个这个

473
00:15:25,866 --> 00:15:26,399
这个

474
00:15:26,400 --> 00:15:29,333
呃这个任务啊开始占用CPU的时候

475
00:15:29,333 --> 00:15:30,133
就是这个任务

476
00:15:30,133 --> 00:15:32,766
一旦由就绪态变成运行态的时候

477
00:15:32,800 --> 00:15:34,966
它这个star time就表示就有一个时间

478
00:15:34,966 --> 00:15:36,399
表示它已经开始运行了

479
00:15:36,400 --> 00:15:38,700
所以current time减去star time是什么呢

480
00:15:38,700 --> 00:15:41,866
就是这个进程从现代到它开始运行

481
00:15:41,866 --> 00:15:43,399
从它开始运行到目前为止

482
00:15:43,400 --> 00:15:44,666
总运行的总时间

483
00:15:44,800 --> 00:15:45,666
再减去什么呢

484
00:15:45,666 --> 00:15:47,466
这是IRQ use的time

485
00:15:47,600 --> 00:15:49,800
那么也就是说中断所占用的时间

486
00:15:49,800 --> 00:15:49,933
那

487
00:15:49,933 --> 00:15:52,399
因为中断这个不一定是这个进程所所

488
00:15:52,500 --> 00:15:53,166
进程的时间

489
00:15:53,166 --> 00:15:54,133
所花费的时间所

490
00:15:54,133 --> 00:15:54,933
以要跑掉

491
00:15:54,966 --> 00:15:56,766
那就是说这个这个任务啊

492
00:15:56,766 --> 00:15:58,899
这个任务跑的干干跑的时间

493
00:15:59,166 --> 00:16:02,066
干跑的时间那这是这个day time day time

494
00:16:02,266 --> 00:16:02,966
然后呢

495
00:16:02,966 --> 00:16:05,266
就判断这个任务它采用的调度策略是

496
00:16:05,266 --> 00:16:06,899
是不是这个啊

497
00:16:06,900 --> 00:16:09,100
是不是这个round招聘就是时间片的

498
00:16:09,100 --> 00:16:09,900
如果是的话

499
00:16:09,900 --> 00:16:10,733
我就把这个

500
00:16:10,733 --> 00:16:13,099
我就把这个任务所运行的这个时间

501
00:16:13,100 --> 00:16:15,266
从这个他运行的时间片里剪掉

502
00:16:15,333 --> 00:16:16,066
看到了吧

503
00:16:16,066 --> 00:16:17,566
剪掉然后呢

504
00:16:17,566 --> 00:16:18,933
啊清再怎么样呢

505
00:16:18,933 --> 00:16:19,899
把这个呃

506
00:16:19,900 --> 00:16:22,366
这个这个表这个任务在RQ的运行室

507
00:16:22,800 --> 00:16:23,800
所耗的时间

508
00:16:23,900 --> 00:16:24,600
然后怎么样呢

509
00:16:24,600 --> 00:16:27,133
再start time再再把current time复给start time

510
00:16:27,133 --> 00:16:27,933
看到了吧

511
00:16:27,933 --> 00:16:29,899
然后判断一下哎判断在这判断

512
00:16:29,900 --> 00:16:30,600
判断什么呢

513
00:16:30,600 --> 00:16:32,266
如果你看在这剪完之后

514
00:16:32,266 --> 00:16:35,099
如果time slice小于这个slice me

515
00:16:35,366 --> 00:16:36,133
这怎么说明什么

516
00:16:36,133 --> 00:16:38,466
说明这个进程的实践片要耗尽了

517
00:16:38,466 --> 00:16:41,133
所以你看要实践片耗尽了要怎么样

518
00:16:41,133 --> 00:16:43,466
是不是就要就要进行进程调度了

519
00:16:43,466 --> 00:16:45,899
所以他再次把这个run q的这个intepend

520
00:16:46,000 --> 00:16:47,933
rescuide you设置成什么

521
00:16:48,266 --> 00:16:48,999
设置了对不对

522
00:16:49,000 --> 00:16:50,700
那在下一次时钟中段的时

523
00:16:50,700 --> 00:16:52,333
不在下一次中段的时候

524
00:16:52,333 --> 00:16:53,366
无论什么中段啊

525
00:16:53,366 --> 00:16:55,166
那都会怎么样进行竞争调度

526
00:16:55,166 --> 00:16:55,966
看到了吧

527
00:16:55,966 --> 00:16:57,266
好这就是你看

528
00:16:57,266 --> 00:16:59,499
当任务剩余时间片长度很小时

529
00:16:59,666 --> 00:17:02,899
则设置independent reschedule也就是说啊

530
00:17:03,066 --> 00:17:04,799
嗯就是时间片耗尽了啊

531
00:17:05,333 --> 00:17:07,133
那表示需要进行进行调度

532
00:17:07,133 --> 00:17:08,533
即任务的时间片耗尽

533
00:17:08,533 --> 00:17:09,966
需要进行任务切换

534
00:17:11,600 --> 00:17:12,800
那么这个是什么呢

535
00:17:12,800 --> 00:17:14,733
这个这个这两个我们就不说了啊

536
00:17:14,733 --> 00:17:16,866
因为我们在前面已经重复很多遍了啊

537
00:17:16,866 --> 00:17:18,266
再讲这个啊

538
00:17:18,266 --> 00:17:19,566
无论是讲任务的时候还是

539
00:17:19,566 --> 00:17:22,533
在讲那个就是优先级队列的时候

540
00:17:22,533 --> 00:17:24,933
这个就是根据优先啊根据什么呢

541
00:17:24,933 --> 00:17:27,966
根据位图来计算出当前这个啊

542
00:17:27,966 --> 00:17:29,266
当前旧区队列中

543
00:17:29,266 --> 00:17:30,933
优先级最高的那个任务

544
00:17:31,533 --> 00:17:32,333
好那么现在呢

545
00:17:32,333 --> 00:17:33,999
我们已经把这个任务

546
00:17:34,166 --> 00:17:36,333
优先级任务最高的这个任务取来了

547
00:17:36,333 --> 00:17:37,166
我们假设

548
00:17:37,333 --> 00:17:39,699
当前的任务和那个新选出来的任务

549
00:17:39,700 --> 00:17:40,533
是不一样的

550
00:17:40,533 --> 00:17:43,166
那就会调用这个schedule task switch

551
00:17:43,166 --> 00:17:44,666
啊在这

552
00:17:45,333 --> 00:17:46,399
啊你看

553
00:17:48,333 --> 00:17:49,466
我们看一下啊

554
00:17:49,700 --> 00:17:50,700
嗯

555
00:17:55,600 --> 00:17:57,100
啊在这如果

556
00:17:57,166 --> 00:17:57,399
新

557
00:17:57,400 --> 00:17:59,366
选出来的任务和当前任务是不同的话

558
00:17:59,366 --> 00:18:01,766
那我就调用这个任务切换啊

559
00:18:01,766 --> 00:18:04,366
用新的任务来代替原来的任务啊

560
00:18:04,366 --> 00:18:06,733
那这这个就是这个sky to task switch

561
00:18:06,866 --> 00:18:08,066
那我们看一下啊

562
00:18:08,066 --> 00:18:09,733
我们看一下它干嘛了呢

563
00:18:09,733 --> 00:18:10,333
它干嘛了

564
00:18:10,333 --> 00:18:11,533
那它首先是什么

565
00:18:11,533 --> 00:18:13,533
把当前正在运行的这个任务的

566
00:18:13,533 --> 00:18:14,666
运行态给改变

567
00:18:14,733 --> 00:18:16,866
而把新选出来这个任务状态

568
00:18:17,100 --> 00:18:18,266
设置成运行态

569
00:18:18,700 --> 00:18:19,300
看到了吧

570
00:18:19,300 --> 00:18:21,900
好然后呢把当前这个任务

571
00:18:21,900 --> 00:18:23,266
把这个新选的任务

572
00:18:23,266 --> 00:18:24,733
设置到这个寄存器里

573
00:18:24,800 --> 00:18:25,666
让这个TCB

574
00:18:25,666 --> 00:18:27,999
的CPU指针指向这个新任务的TCB

575
00:18:28,366 --> 00:18:29,299
啊这这个

576
00:18:29,300 --> 00:18:32,166
然后呢判断一下新任务和旧任务

577
00:18:32,166 --> 00:18:34,399
是不是属于同一个进程啊

578
00:18:34,400 --> 00:18:36,000
如果不属于同一个进程的话

579
00:18:36,000 --> 00:18:36,866
调这个函数

580
00:18:36,866 --> 00:18:38,899
后面我们讲虚拟内存的时候

581
00:18:38,900 --> 00:18:40,533
虚实影射的时候会介绍它

582
00:18:40,533 --> 00:18:42,066
就会切换什么呢

583
00:18:42,066 --> 00:18:42,866
切换页表

584
00:18:42,966 --> 00:18:45,099
所以这个地方是进行页表切换啊

585
00:18:45,333 --> 00:18:46,299
我们知道啊

586
00:18:46,366 --> 00:18:47,999
这个new tax和run tax

587
00:18:48,000 --> 00:18:49,400
有可能属于同一个进程

588
00:18:49,400 --> 00:18:50,800
也可能属于不同进程

589
00:18:50,933 --> 00:18:52,266
如果它属于同一个进程的话

590
00:18:52,266 --> 00:18:53,999
我们就不需要进行页表切换

591
00:18:54,100 --> 00:18:57,200
因为啊县城或者任务都是在同一个

592
00:18:57,200 --> 00:18:58,466
进程地质空间里

593
00:18:58,466 --> 00:19:00,799
但是如果新任务和旧任务啊

594
00:19:00,800 --> 00:19:02,566
新新的任务和这个

595
00:19:02,933 --> 00:19:03,733
当前任务

596
00:19:03,733 --> 00:19:05,733
它如果不属于同一个进程的话

597
00:19:05,733 --> 00:19:07,966
那么我们就需要用新任务的列表啊

598
00:19:07,966 --> 00:19:10,066
就需要进行进程空间的切换

599
00:19:10,566 --> 00:19:13,766
然后呢就判断当前任务退出

600
00:19:13,766 --> 00:19:14,966
让出CPU的原因

601
00:19:15,166 --> 00:19:16,733
那么这个这个是什么呢

602
00:19:16,733 --> 00:19:18,299
这个表示如果呀

603
00:19:18,500 --> 00:19:21,266
当前任务是因为时间片到期啊

604
00:19:21,266 --> 00:19:23,199
时间为到期让出了CPU

605
00:19:23,200 --> 00:19:26,266
则用当前的这个任务的start time

606
00:19:26,266 --> 00:19:27,799
设置新任务的star time

607
00:19:28,000 --> 00:19:30,466
因为呢在更新当前任务时间片时

608
00:19:30,466 --> 00:19:32,566
会将当前任务的star time

609
00:19:32,566 --> 00:19:34,566
也一并更新为当前时间啊

610
00:19:34,566 --> 00:19:35,599
当然在这我认为

611
00:19:35,600 --> 00:19:37,966
我认为也可以用current time来设置啊

612
00:19:38,266 --> 00:19:39,866
但是他在这就直接用Ranstar

613
00:19:39,866 --> 00:19:41,333
Rantask和star time来

614
00:19:41,333 --> 00:19:43,966
其实Rantask和star time就是car run time啊

615
00:19:44,166 --> 00:19:45,666
你你自己研究一下啊

616
00:19:45,666 --> 00:19:47,666
你看一下代码就知道这就是car run time

617
00:19:47,900 --> 00:19:49,300
因为新任务马上要运行了

618
00:19:49,300 --> 00:19:50,333
所以就用当前

619
00:19:50,333 --> 00:19:52,933
时间来设置新任务开始运行的时间

620
00:19:53,300 --> 00:19:54,066
iOS是什么呢

621
00:19:54,066 --> 00:19:55,333
iOS就是说

622
00:19:55,500 --> 00:19:58,933
否则是因为当前任务就是这个run task

623
00:19:59,100 --> 00:20:01,466
需要睡眠或阻塞才释放的CPU

624
00:20:01,466 --> 00:20:02,366
那怎么办呢

625
00:20:02,400 --> 00:20:03,333
那怎么办呢

626
00:20:03,333 --> 00:20:05,999
那首先是将新任务的这个start time

627
00:20:06,000 --> 00:20:06,700
设置成什么

628
00:20:06,700 --> 00:20:07,566
当前时间

629
00:20:08,066 --> 00:20:09,799
然后呢用什么呢

630
00:20:09,800 --> 00:20:12,666
调用这个啊因为你看他这个是什么呢

631
00:20:12,666 --> 00:20:13,599
然后更新啊

632
00:20:13,600 --> 00:20:16,500
调用这个time slice update来更新啊

633
00:20:16,566 --> 00:20:19,266
这个run task当前任务剩余的时间片

634
00:20:19,400 --> 00:20:20,333
剩余的时间片

635
00:20:20,500 --> 00:20:21,400
然后呢

636
00:20:22,166 --> 00:20:25,099
来判断来判断当前这个

637
00:20:25,200 --> 00:20:27,533
要睡眠的任务有没有设置时间

638
00:20:27,700 --> 00:20:29,933
就是说我们在讲锁的时候我们知道

639
00:20:30,100 --> 00:20:31,400
当如果一个进程

640
00:20:31,400 --> 00:20:33,100
如果当当前进程

641
00:20:33,466 --> 00:20:35,299
或想需要获得锁

642
00:20:35,333 --> 00:20:36,133
需要获得锁

643
00:20:37,133 --> 00:20:37,266
嗯

644
00:20:37,266 --> 00:20:39,799
同时呢还有一个设置一个等锁时间啊

645
00:20:39,800 --> 00:20:41,133
如果超过这个时间

646
00:20:41,266 --> 00:20:42,699
如果超过这个时间的话

647
00:20:42,700 --> 00:20:44,766
我没有获得锁我也会照样唤醒

648
00:20:44,866 --> 00:20:46,399
所以说支持这个状态

649
00:20:46,400 --> 00:20:47,733
然后怎么样把它要加入

650
00:20:47,733 --> 00:20:48,966
把当前这个任务也要

651
00:20:48,966 --> 00:20:50,466
加入到time out队列里

652
00:20:50,600 --> 00:20:51,133
看到了吧

653
00:20:51,133 --> 00:20:53,266
这是OS sky的time out q ad

654
00:20:53,266 --> 00:20:54,866
就是把这个当前这个任务

655
00:20:54,933 --> 00:20:56,799
除了要加到等待锁那个队列里

656
00:20:56,800 --> 00:20:58,300
还要加把这个TCB

657
00:20:58,400 --> 00:20:58,966
TCB

658
00:20:58,966 --> 00:21:00,599
除了加的这个锁的队列里

659
00:21:00,600 --> 00:21:01,733
还要加到这个

660
00:21:01,800 --> 00:21:03,600
run run q的time out队列里啊

661
00:21:03,600 --> 00:21:05,000
run q的time out队列里

662
00:21:05,133 --> 00:21:07,199
然后怎么样呢然后呢

663
00:21:08,000 --> 00:21:08,766
那么大家看

664
00:21:08,766 --> 00:21:10,999
我现在要换一个新的任务来运行

665
00:21:11,000 --> 00:21:11,800
那怎么样呢

666
00:21:11,800 --> 00:21:14,066
那个这个新的任务也有实践片对不对

667
00:21:14,066 --> 00:21:15,299
所以deadline get

668
00:21:15,300 --> 00:21:17,800
就是获得这个新的任务的实践片啊

669
00:21:17,800 --> 00:21:19,300
实践片啊时间片

670
00:21:19,300 --> 00:21:20,400
为什么要获得时间片呢

671
00:21:20,400 --> 00:21:21,466
主要是通过

672
00:21:21,766 --> 00:21:24,399
调用什么schedule next expare time set

673
00:21:24,400 --> 00:21:25,966
来设置这个run q的

674
00:21:25,966 --> 00:21:27,399
什么response time啊

675
00:21:27,400 --> 00:21:29,333
response time表示什么意思呢

676
00:21:29,333 --> 00:21:30,099
大家想一想啊

677
00:21:30,100 --> 00:21:31,333
我现在啊

678
00:21:31,333 --> 00:21:33,866
我现在每一个run q都有一个response time

679
00:21:34,000 --> 00:21:35,300
这个response time是什么呢

680
00:21:35,300 --> 00:21:37,566
这个response time是run q啊

681
00:21:37,700 --> 00:21:38,733
就是说是什么呢

682
00:21:38,733 --> 00:21:39,699
是这个啊

683
00:21:39,700 --> 00:21:41,866
是这个当前任务啊

684
00:21:41,866 --> 00:21:44,133
当前正在CP上运行它的时间片

685
00:21:44,333 --> 00:21:44,699
啊

686
00:21:44,700 --> 00:21:45,933
还有就是什么呢

687
00:21:45,933 --> 00:21:47,266
还有就是这个

688
00:21:47,666 --> 00:21:48,533
还有就是这个

689
00:21:48,533 --> 00:21:51,299
这个time out那个那个时间那个队列

690
00:21:51,400 --> 00:21:54,000
这两个的最小值啊这两个的最小值

691
00:21:54,166 --> 00:21:56,466
所以说你看我现在呢换一个新的任务

692
00:21:56,466 --> 00:21:57,966
所以这个deadline发生了更新

693
00:21:57,966 --> 00:21:59,666
所以我要用这两个的最小值

694
00:22:00,066 --> 00:22:01,866
来设置这个time out啊

695
00:22:01,866 --> 00:22:03,333
那个来设置这个response time

696
00:22:03,333 --> 00:22:04,666
run code response time

697
00:22:04,866 --> 00:22:05,266
好

698
00:22:05,266 --> 00:22:07,099
那完成这个response time之后呢

699
00:22:07,100 --> 00:22:08,333
我们就要怎么样呢

700
00:22:08,366 --> 00:22:11,099
要调用这个OS task guide

701
00:22:11,133 --> 00:22:13,733
那这是一个汇编语言编写的程序

702
00:22:13,766 --> 00:22:16,799
它完成了新旧任务的上下文的切换

703
00:22:16,800 --> 00:22:17,800
Ctrl的切换

704
00:22:17,866 --> 00:22:21,066
实实际上就是说把老的任务的啊

705
00:22:21,066 --> 00:22:22,266
把老任务的寄存器

706
00:22:22,266 --> 00:22:24,266
保存在老任务的内核战中

707
00:22:24,300 --> 00:22:27,300
然后恢复新任务的内核战中的数据

708
00:22:28,700 --> 00:22:28,933
好

709
00:22:28,933 --> 00:22:30,799
那我们继续来看一下这个

710
00:22:30,800 --> 00:22:31,800
这个非常重要的函数

711
00:22:31,800 --> 00:22:34,200
就是schedule next expare time set

712
00:22:34,333 --> 00:22:35,733
那么这个是什么意思呢

713
00:22:35,733 --> 00:22:38,266
用于设置run killed response time的值

714
00:22:38,666 --> 00:22:41,866
该值呢用于处理run q的time out队列

715
00:22:41,866 --> 00:22:44,399
保证到期事件得到及时处理

716
00:22:44,500 --> 00:22:48,000
那主要通过设置run q response ID为OS

717
00:22:48,000 --> 00:22:49,400
以VALID value实现

718
00:22:49,666 --> 00:22:53,466
将run q response time设置为task and time

719
00:22:53,900 --> 00:22:54,166
啊

720
00:22:54,166 --> 00:22:55,866
最早的time out的时间

721
00:22:55,966 --> 00:22:59,166
当前的runq response time三者中的最小值

722
00:22:59,366 --> 00:23:00,099
这表示什么呢

723
00:23:00,100 --> 00:23:01,933
这个表示的实际上就是当前

724
00:23:01,933 --> 00:23:03,699
在CPU上运行的任务的时间

725
00:23:03,700 --> 00:23:05,933
片的时间片的终止时间

726
00:23:05,966 --> 00:23:08,133
这个就是time out对列的终止时间

727
00:23:08,200 --> 00:23:09,933
这个就是当前response的

728
00:23:09,933 --> 00:23:13,499
这个就是说response time当前值当前值

729
00:23:13,533 --> 00:23:15,933
那在这三个设置这三个最小值啊

730
00:23:16,266 --> 00:23:17,866
好大家看一下是怎么做的啊

731
00:23:17,866 --> 00:23:20,466
首先你看这个这个函数get salt

732
00:23:20,466 --> 00:23:22,066
link connects expand time

733
00:23:22,166 --> 00:23:24,066
实际上就是获得run q的这个time

734
00:23:24,066 --> 00:23:25,099
帽子对列的

735
00:23:25,266 --> 00:23:26,166
那个最

736
00:23:26,800 --> 00:23:28,066
的那个第一个时钟

737
00:23:28,200 --> 00:23:29,766
第一个时间的截止时间

738
00:23:29,766 --> 00:23:31,899
他把这个设置成next x pair time了

739
00:23:31,900 --> 00:23:32,533
看到了吧

740
00:23:32,533 --> 00:23:34,766
然后清除这个标志清除这个标志

741
00:23:34,933 --> 00:23:35,933
然后呢

742
00:23:36,066 --> 00:23:40,399
那么如果当前啊run q response ID为OS

743
00:23:40,666 --> 00:23:41,799
evaluate value

744
00:23:43,300 --> 00:23:45,533
那么表示下一个要处理的任务呢

745
00:23:45,533 --> 00:23:46,366
来自time out

746
00:23:46,700 --> 00:23:47,866
来自time out队列

747
00:23:47,933 --> 00:23:51,166
而old response ID呢是个普通任务

748
00:23:51,566 --> 00:23:51,866
啊

749
00:23:51,866 --> 00:23:54,366
这个old response ID呢是个普通任务

750
00:23:54,366 --> 00:23:56,099
那这个普通任务的时间片

751
00:23:56,100 --> 00:23:57,533
比第一个time out的

752
00:23:57,733 --> 00:23:59,066
任务的时间片要长

753
00:23:59,200 --> 00:24:00,966
所以呢会造成啊

754
00:24:01,066 --> 00:24:03,999
会造成这个RES RQ response ID不等于

755
00:24:04,000 --> 00:24:05,200
old response ID

756
00:24:05,200 --> 00:24:09,000
于是RQ response time就不会被修改

757
00:24:09,400 --> 00:24:09,966
那么

758
00:24:09,966 --> 00:24:11,399
这个语句啊至于

759
00:24:11,466 --> 00:24:13,466
会执行下面这个if语句

760
00:24:13,533 --> 00:24:14,133
那么

761
00:24:14,133 --> 00:24:15,166
if什么呢

762
00:24:15,400 --> 00:24:19,200
r q response time小于next expare time语句

763
00:24:19,300 --> 00:24:20,666
从而直接reter

764
00:24:20,933 --> 00:24:24,566
反之如果r q response ID等于order response ID

765
00:24:24,566 --> 00:24:25,966
就是这个if条件成立

766
00:24:26,166 --> 00:24:27,066
则会将

767
00:24:27,500 --> 00:24:32,500
RQ response ID设设定为task and time和time out

768
00:24:33,400 --> 00:24:35,600
第一个过期时间的皎皎者

769
00:24:35,733 --> 00:24:36,799
那么因为呢

770
00:24:37,000 --> 00:24:40,000
RQ response ID被设置为了极大值啊

771
00:24:40,500 --> 00:24:40,966
啊

772
00:24:40,966 --> 00:24:43,466
RQ response ID被设置为了极大值啊

773
00:24:43,466 --> 00:24:44,566
看在这啊

774
00:24:44,566 --> 00:24:48,066
你看如果RQ response ID等于old response ID

775
00:24:48,066 --> 00:24:49,699
那这个时候表示什么意思呢

776
00:24:49,700 --> 00:24:53,266
表示这一次产生时钟中断啊

777
00:24:53,666 --> 00:24:56,566
这次产生这个old response ID是这个对吧

778
00:24:56,566 --> 00:24:59,933
那就表示呢这个呃表示什么

779
00:24:59,933 --> 00:25:01,366
呢那么我们

780
00:25:01,366 --> 00:25:02,899
我们就会把这个response time

781
00:25:02,900 --> 00:25:03,933
设置成一个最大值

782
00:25:03,933 --> 00:25:05,366
那这样如这样的话呢

783
00:25:05,366 --> 00:25:06,299
那它就会怎么样

784
00:25:06,300 --> 00:25:07,000
在and

785
00:25:07,000 --> 00:25:09,966
task time和time out中选择一个佼佼者

786
00:25:10,066 --> 00:25:11,333
那也就是说这个response

787
00:25:11,333 --> 00:25:13,466
旧的response ID就不会参与了啊

788
00:25:14,000 --> 00:25:14,766
好

789
00:25:14,766 --> 00:25:16,166
那好那现在是什么呢

790
00:25:16,166 --> 00:25:18,099
现在这个if语句是比较什么呢

791
00:25:18,100 --> 00:25:21,500
比较new task new task的到期时间

792
00:25:22,133 --> 00:25:22,333
啊

793
00:25:22,333 --> 00:25:24,566
倒计时间task on time与time out

794
00:25:24,933 --> 00:25:26,133
对列的倒计时间

795
00:25:26,133 --> 00:25:27,066
谁更早啊

796
00:25:27,066 --> 00:25:29,566
谁更早如果task on time更早

797
00:25:29,566 --> 00:25:32,699
则对next expare time进行更新啊

798
00:25:32,700 --> 00:25:34,666
你看在这儿比较谁更早

799
00:25:34,666 --> 00:25:38,566
谁更早那如果要是task on time更早的话

800
00:25:38,566 --> 00:25:39,799
那就用这个task on time

801
00:25:39,800 --> 00:25:41,900
对next is pair time进更新

802
00:25:42,200 --> 00:25:44,133
然后呢is time slice为处

803
00:25:44,266 --> 00:25:45,799
为什么is time slice为处呢

804
00:25:45,800 --> 00:25:46,666
大家想一想

805
00:25:46,800 --> 00:25:47,700
task按time

806
00:25:47,700 --> 00:25:48,333
是当前

807
00:25:48,333 --> 00:25:50,333
运行的这个任务的时间片的到期

808
00:25:50,333 --> 00:25:51,266
时间对吧

809
00:25:51,266 --> 00:25:53,066
所以时间片时间片嘛

810
00:25:53,066 --> 00:25:55,533
所以说这是由时间片以到期引起的

811
00:25:55,666 --> 00:25:57,766
引起的那个就是引起的

812
00:25:57,766 --> 00:26:00,366
所以说这个is time slice就为处

813
00:26:00,400 --> 00:26:01,666
啊就为处

814
00:26:01,800 --> 00:26:03,500
那么如果

815
00:26:04,166 --> 00:26:05,499
呃那么

816
00:26:07,133 --> 00:26:07,899
啊

817
00:26:07,900 --> 00:26:08,600
否则的话

818
00:26:08,600 --> 00:26:11,266
如果is time slice为false的话就是什么呢

819
00:26:11,266 --> 00:26:13,799
就是说是这个response time

820
00:26:13,800 --> 00:26:16,866
是由由于这个time out对列啊

821
00:26:16,866 --> 00:26:18,899
time out队列的第一个时钟到期比较早

822
00:26:18,900 --> 00:26:19,800
所引起的

823
00:26:19,933 --> 00:26:23,133
那么如果RQ当前的response time

824
00:26:23,366 --> 00:26:25,066
比next time还要早

825
00:26:25,133 --> 00:26:26,733
则不需要进行任何更新

826
00:26:26,733 --> 00:26:27,866
那么就直接返回

827
00:26:27,933 --> 00:26:29,666
好那现在这是重点了

828
00:26:30,066 --> 00:26:32,599
大家看在这is is time slice为

829
00:26:32,600 --> 00:26:34,133
处的时候表示啊

830
00:26:34,133 --> 00:26:36,333
这是由当前任务所引起的

831
00:26:36,400 --> 00:26:39,000
也所引起的这个啊时钟到期

832
00:26:39,000 --> 00:26:42,333
所以RQ response ID就是设置成正常的

833
00:26:42,500 --> 00:26:43,500
否则的话是什么呢

834
00:26:43,500 --> 00:26:46,366
就是由于time out队列的第一个时钟啊

835
00:26:46,466 --> 00:26:47,766
到期所引起的

836
00:26:47,766 --> 00:26:51,266
这个所引起的response response ID

837
00:26:51,866 --> 00:26:52,866
response ID是什么呢

838
00:26:52,866 --> 00:26:54,399
是time out的第一个什么呢

839
00:26:54,400 --> 00:26:55,200
第一个

840
00:26:55,366 --> 00:26:58,366
第一个时钟的周时时钟到期时间

841
00:26:58,500 --> 00:27:01,333
所以我就把这个RQ response ID设置成这个

842
00:27:01,333 --> 00:27:03,199
OS evaluate value大家看

843
00:27:03,333 --> 00:27:04,133
所以

844
00:27:04,266 --> 00:27:06,166
RQ response ID

845
00:27:06,166 --> 00:27:08,599
如果是OS以valid value表示什么意思

846
00:27:09,066 --> 00:27:10,166
就表示的是

847
00:27:10,200 --> 00:27:12,366
是由于timeout对列到期所引起的

848
00:27:12,366 --> 00:27:14,733
这个所引起的进程切换

849
00:27:14,900 --> 00:27:16,166
如果是response i

850
00:27:16,200 --> 00:27:17,900
普通的response ID就表示什么

851
00:27:17,900 --> 00:27:19,800
就表示是由进程调度

852
00:27:20,133 --> 00:27:21,699
是由时间片到期啊

853
00:27:21,700 --> 00:27:23,600
是由当前任务的时间片到期

854
00:27:23,700 --> 00:27:25,066
引起的这个调度啊

855
00:27:25,066 --> 00:27:26,133
所以这就是好

856
00:27:26,133 --> 00:27:27,066
既然我们已经知道了

857
00:27:27,066 --> 00:27:29,733
那好我们现在就把next extert time键CART time

858
00:27:29,733 --> 00:27:31,333
就是这个Dot dot

859
00:27:31,533 --> 00:27:33,299
然后用Ctrl time加上这个dot

860
00:27:33,333 --> 00:27:34,966
就得到了response time

861
00:27:34,966 --> 00:27:37,266
所以我们就这个来设置这个response time

862
00:27:37,266 --> 00:27:38,699
好大家看一下啊

863
00:27:38,700 --> 00:27:40,100
response time就表示什么呢

864
00:27:40,100 --> 00:27:41,466
就是下一次

865
00:27:41,600 --> 00:27:43,666
需要进程调度它的这个时间

866
00:27:43,666 --> 00:27:44,466
时间点

867
00:27:44,766 --> 00:27:46,933
时间点那到底是谁由由谁引起的呢

868
00:27:46,933 --> 00:27:48,333
就要看这个response

869
00:27:48,333 --> 00:27:50,133
RQ的response ID是什么了

870
00:27:50,133 --> 00:27:51,566
如果它是一个具体的值

871
00:27:51,666 --> 00:27:53,566
就是由时间片到期引起的

872
00:27:53,566 --> 00:27:54,499
如果它是

873
00:27:54,766 --> 00:27:55,699
OS e valid value

874
00:27:55,700 --> 00:27:57,766
就是由time out这个任务引起来的

875
00:27:58,400 --> 00:28:01,366
好那么这个就是OS task SCADU就

876
00:28:01,366 --> 00:28:03,299
是这个真正执行任务切换的

877
00:28:03,300 --> 00:28:04,400
这么一个汇编语言

878
00:28:04,400 --> 00:28:05,166
汇编语言

879
00:28:05,166 --> 00:28:07,099
那么这个汇编语言我们就

880
00:28:07,100 --> 00:28:07,466
嗯

881
00:28:07,466 --> 00:28:08,199
从略了啊

882
00:28:08,200 --> 00:28:09,666
感兴趣的同学可以自己去看

883
00:28:09,666 --> 00:28:11,466
那么他实际上完成的就是什么呢

884
00:28:11,466 --> 00:28:16,266
就是把啊把当前任务他的这个数啊

885
00:28:16,333 --> 00:28:17,133
那个上下文

886
00:28:17,133 --> 00:28:19,699
压入到他的当前任务的内核战中

887
00:28:19,766 --> 00:28:21,333
然后把新任务的

888
00:28:21,500 --> 00:28:24,766
上下文从内核战中啊恢复到计算器中

889
00:28:25,966 --> 00:28:26,566
好

890
00:28:26,566 --> 00:28:28,333
那么我们再看这个函数

891
00:28:28,366 --> 00:28:29,866
那么这个函数什么是

892
00:28:29,866 --> 00:28:30,499
我们再回一下

893
00:28:30,500 --> 00:28:32,166
这个函数什么时候是执行的呢

894
00:28:32,533 --> 00:28:33,666
是在这个时候执行的

895
00:28:33,666 --> 00:28:34,566
就是啊

896
00:28:34,566 --> 00:28:38,999
我们知道OS schedule LQ and check need reschedule

897
00:28:39,000 --> 00:28:39,600
这个函数

898
00:28:39,600 --> 00:28:42,133
如果要是没有发生进程切换的时候

899
00:28:42,133 --> 00:28:42,966
那它就会怎么样

900
00:28:42,966 --> 00:28:44,699
它会调用这个函数啊

901
00:28:44,700 --> 00:28:45,966
那为什么会掉上这个函数呢

902
00:28:45,966 --> 00:28:48,733
因为当时钟中断返回的时候

903
00:28:48,733 --> 00:28:50,366
那么没有发生进程切换

904
00:28:50,366 --> 00:28:52,266
那就表示我时间修改了

905
00:28:52,266 --> 00:28:53,499
那我需要怎么样呢

906
00:28:53,533 --> 00:28:55,999
因为时间变动了嘛所以我需要对时

907
00:28:56,700 --> 00:28:59,500
run q的response ID进行时间更新

908
00:28:59,600 --> 00:29:00,400
时间更新

909
00:29:00,900 --> 00:29:02,000
那么我们看一下这个

910
00:29:02,000 --> 00:29:04,133
实际上本质上也是调用这个

911
00:29:04,266 --> 00:29:06,399
schedule next expare time set啊

912
00:29:06,400 --> 00:29:08,000
time set它是怎么做的呢

913
00:29:08,000 --> 00:29:09,333
它实际上是这样的

914
00:29:09,333 --> 00:29:11,266
大家看因为我们现在没有进行

915
00:29:11,666 --> 00:29:13,933
进行这个没有进行任务切换

916
00:29:13,933 --> 00:29:14,733
任务切换

917
00:29:14,733 --> 00:29:16,133
那么所以我们怎么办呢

918
00:29:16,133 --> 00:29:17,133
所以你看一下啊

919
00:29:17,133 --> 00:29:19,533
所以我没有任务进行任务切换啊

920
00:29:19,533 --> 00:29:20,733
我们在这个地方

921
00:29:20,733 --> 00:29:21,566
我们在这个地方

922
00:29:21,566 --> 00:29:22,133
我们你看

923
00:29:22,133 --> 00:29:22,899
我们在这个地方

924
00:29:22,900 --> 00:29:24,900
把当前任务的时间片进行更

925
00:29:24,966 --> 00:29:25,899
进行了更新

926
00:29:26,266 --> 00:29:28,533
但是中间我们没有进成进行任务切换

927
00:29:28,600 --> 00:29:29,900
所以表示什么

928
00:29:29,900 --> 00:29:32,333
当前任务他的这个时间啊改

929
00:29:32,333 --> 00:29:33,266
时间发生改变

930
00:29:33,266 --> 00:29:34,566
到期时间发生改变

931
00:29:34,766 --> 00:29:37,466
所以大家看在这个地方啊在这个地方

932
00:29:39,500 --> 00:29:40,666
啊在这个地方啊

933
00:29:40,666 --> 00:29:41,466
在这个地方你看

934
00:29:41,466 --> 00:29:43,533
那我就怎么样获取当前时间的

935
00:29:43,533 --> 00:29:44,166
这个data line

936
00:29:44,166 --> 00:29:45,866
也就是剩余的时间片是多少

937
00:29:45,900 --> 00:29:48,600
然后用这个data line去更新run q的这个

938
00:29:48,600 --> 00:29:50,900
response ID看到了吧response ID

939
00:29:51,200 --> 00:29:53,200
所以这就是这个

940
00:29:54,066 --> 00:29:55,066
就是说你看啊

941
00:29:55,166 --> 00:29:55,566
在

942
00:29:55,566 --> 00:29:59,399
OS schedule RQ and check need reschedule函数的最后

943
00:29:59,400 --> 00:30:02,400
调用OS schedule expare time after函数

944
00:30:02,966 --> 00:30:04,399
当执行该函数时

945
00:30:04,400 --> 00:30:05,966
一定没有发生竞争切换

946
00:30:05,966 --> 00:30:09,399
所以调用schedule next expare time set函数

947
00:30:09,500 --> 00:30:11,766
比较当前任务剩余时间片长度

948
00:30:11,766 --> 00:30:14,199
也就是这个deadline和time out队列中

949
00:30:14,200 --> 00:30:15,966
最早到期任务时间

950
00:30:16,066 --> 00:30:18,499
那么依据这个看他俩谁谁小

951
00:30:18,800 --> 00:30:19,100
啊

952
00:30:19,100 --> 00:30:21,800
以此来更新RQ的response time

953
00:30:22,466 --> 00:30:22,733
好

954
00:30:22,733 --> 00:30:23,933
那么到目前为止呢

955
00:30:23,933 --> 00:30:26,499
我们就完成了这个任务调度

956
00:30:26,666 --> 00:30:28,666
任务调度这部分的介介绍

957
00:30:28,666 --> 00:30:29,999
那么下面我们介绍两个

958
00:30:30,000 --> 00:30:31,400
这个任务调度函数啊

959
00:30:31,700 --> 00:30:32,933
就是这个细节的介绍

960
00:30:32,933 --> 00:30:34,099
任务调度细节的介绍

961
00:30:34,100 --> 00:30:35,866
那我们看一下调度是怎么做的呢

962
00:30:35,966 --> 00:30:38,333
首先lost schedule啊lost schedule

963
00:30:38,366 --> 00:30:39,466
那么这个是什么呢

964
00:30:39,466 --> 00:30:41,866
这个这个就是说啊这个大家看一下

965
00:30:41,866 --> 00:30:42,733
首先获得

966
00:30:43,300 --> 00:30:43,866
这个是什么呢

967
00:30:43,866 --> 00:30:46,299
会将当前任务加入到就绪队列的

968
00:30:46,666 --> 00:30:47,466
调度函数

969
00:30:47,466 --> 00:30:49,933
那首先是获获得当前任务看到了吗

970
00:30:49,933 --> 00:30:52,133
获得当前任务然后呢

971
00:30:52,166 --> 00:30:52,933
啊

972
00:30:52,933 --> 00:30:54,999
对当前任务的时间片进行更新

973
00:30:55,000 --> 00:30:55,666
看到了吗

974
00:30:55,666 --> 00:30:57,499
对当前任务的时间片进行更新

975
00:30:57,666 --> 00:31:00,699
然后把当前这个任务入队啊入队

976
00:31:00,800 --> 00:31:02,966
然后呢调用啊

977
00:31:02,966 --> 00:31:04,966
调度调度函数啊调度函数

978
00:31:04,966 --> 00:31:06,799
真正的完成调度是这个函数

979
00:31:06,866 --> 00:31:07,566
那我们看一下

980
00:31:07,566 --> 00:31:08,933
真正完成调度的是这个函数

981
00:31:08,933 --> 00:31:11,766
叫做OS guide you schedule resguide you

982
00:31:11,966 --> 00:31:13,199
那它是干嘛呢

983
00:31:13,333 --> 00:31:14,666
它是首先是什么

984
00:31:14,666 --> 00:31:17,199
获得当前CPU上的这个run q

985
00:31:17,566 --> 00:31:18,533
然后呢

986
00:31:18,766 --> 00:31:22,799
然后呢把这个Intel pandrescadio这个标记啊

987
00:31:22,800 --> 00:31:24,766
表示我已经响应了所以要清空

988
00:31:25,100 --> 00:31:26,733
然后呢获得当前任务

989
00:31:26,800 --> 00:31:27,966
然后获得什么呢

990
00:31:27,966 --> 00:31:30,799
当前就是说优先级最高的这个任务

991
00:31:30,800 --> 00:31:31,900
如果相等直接返回

992
00:31:31,900 --> 00:31:32,733
不需要任务切换

993
00:31:32,733 --> 00:31:35,099
否则的话调用schedule task

994
00:31:35,333 --> 00:31:36,899
schedule switch啊

995
00:31:36,900 --> 00:31:37,300
那么

996
00:31:37,300 --> 00:31:39,366
schedule task switch就是我们刚才说的这个

997
00:31:39,366 --> 00:31:40,533
看到了就这个函数

998
00:31:40,533 --> 00:31:43,299
由这个函数来完成具体的任务切换

999
00:31:44,966 --> 00:31:46,199
任务切换好

1000
00:31:46,200 --> 00:31:48,766
我们在这再回过头来看一下什么呢

1001
00:31:48,966 --> 00:31:51,566
刚才漏了一个东西啊漏了一个东西

1002
00:31:52,066 --> 00:31:55,099
啊就是这个round绕笔啊round绕笔

1003
00:31:59,066 --> 00:31:59,866
run

1004
00:31:59,966 --> 00:32:00,499
招聘

1005
00:32:00,500 --> 00:32:01,266
啊

1006
00:32:01,266 --> 00:32:02,499
那么嗯

1007
00:32:02,700 --> 00:32:04,366
那么run招聘我在这补充一下啊

1008
00:32:04,366 --> 00:32:06,133
我我在这补充一下这个函数

1009
00:32:06,166 --> 00:32:07,499
那run招聘是什么意思呢

1010
00:32:07,500 --> 00:32:08,700
就是说嗯

1011
00:32:08,700 --> 00:32:09,600
就是说这个

1012
00:32:09,600 --> 00:32:12,066
就是我们再回忆一下上一节课的内容

1013
00:32:12,066 --> 00:32:13,466
就是in q那个操作

1014
00:32:13,700 --> 00:32:14,700
INQ那个操作

1015
00:32:14,800 --> 00:32:15,766
INQ操作的时候

1016
00:32:15,766 --> 00:32:16,733
就是把一个任务

1017
00:32:16,733 --> 00:32:18,299
加入到就绪队列的时候

1018
00:32:18,300 --> 00:32:20,933
他会检查这个任务的调度策略

1019
00:32:20,933 --> 00:32:21,966
如果他是什么

1020
00:32:21,966 --> 00:32:23,166
如果他是这个

1021
00:32:23,466 --> 00:32:25,566
啊他是这个就是啊

1022
00:32:25,566 --> 00:32:26,499
时间片轮转的话

1023
00:32:26,500 --> 00:32:27,933
他会检查当前这个

1024
00:32:27,966 --> 00:32:29,333
任务所剩余的时间片

1025
00:32:29,533 --> 00:32:31,333
那么如果时间片很少的话

1026
00:32:31,333 --> 00:32:33,299
很小的话就是小于这个命

1027
00:32:33,700 --> 00:32:34,466
那么就表示

1028
00:32:34,466 --> 00:32:36,266
当前任务是由于时间片到期

1029
00:32:36,266 --> 00:32:37,533
所以引发调度

1030
00:32:37,533 --> 00:32:38,466
那他就会把这个

1031
00:32:38,466 --> 00:32:40,599
任务插入到就绪队列的末尾

1032
00:32:41,066 --> 00:32:43,166
那么反之如果当前任务所

1033
00:32:43,333 --> 00:32:43,733
如果

1034
00:32:43,733 --> 00:32:46,099
当前任务所剩余的时间片还很大的话

1035
00:32:46,100 --> 00:32:49,200
那就表示这个任务是由于抢占而被

1036
00:32:49,333 --> 00:32:51,166
而由运行态变成就绪态的

1037
00:32:51,166 --> 00:32:51,966
那怎么样呢

1038
00:32:51,966 --> 00:32:53,933
就会把这个任务插入到这个对头

1039
00:32:53,933 --> 00:32:55,166
就绪队列的对头

1040
00:32:55,266 --> 00:32:56,666
所以啊在这一补充

1041
00:32:56,666 --> 00:32:58,133
我们就把整个这个

1042
00:32:58,466 --> 00:32:59,799
啊任务调度这个部分

1043
00:33:00,066 --> 00:33:02,966
来来啊补充完整了啊

1044
00:33:02,966 --> 00:33:04,533
好那么任务调度这部分呢

1045
00:33:04,533 --> 00:33:05,333
我们就讲这么多

1046
00:33:05,333 --> 00:33:06,133
谢谢各位

