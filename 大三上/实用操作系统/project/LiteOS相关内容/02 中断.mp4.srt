1
00:00:01,333 --> 00:00:02,699
各位同学大家好

2
00:00:02,866 --> 00:00:04,366
我们继续介绍

3
00:00:04,600 --> 00:00:07,100
本节课的第二个内容中断

4
00:00:07,400 --> 00:00:09,700
那么中断部分我们分两部分介绍

5
00:00:09,700 --> 00:00:11,100
首先是中断的概念

6
00:00:11,100 --> 00:00:13,200
然后是中断中断的管理

7
00:00:15,600 --> 00:00:17,733
首先我们来看一下中断的概念

8
00:00:18,766 --> 00:00:19,866
中断是指

9
00:00:20,100 --> 00:00:21,333
程序运行过程中

10
00:00:21,333 --> 00:00:24,533
出现了一个必须由CPU立即处理的事

11
00:00:24,533 --> 00:00:25,866
事务此时

12
00:00:26,366 --> 00:00:29,699
那么CPU暂时中止当前程序的执行

13
00:00:29,866 --> 00:00:31,333
转而处理这个事务

14
00:00:31,366 --> 00:00:33,299
那么这个过程就叫做中断

15
00:00:33,866 --> 00:00:36,799
中断模块的核心是中断控制器

16
00:00:40,066 --> 00:00:41,899
外设可以在没有CPU

17
00:00:41,900 --> 00:00:44,333
介入的情况下完成一定的工作

18
00:00:44,600 --> 00:00:45,366
但

19
00:00:45,366 --> 00:00:46,333
某些情况下

20
00:00:46,333 --> 00:00:49,133
也需要CPU为其执行一定的工作

21
00:00:49,800 --> 00:00:51,000
通过中断机制

22
00:00:51,066 --> 00:00:53,366
在外设不需要CPU介入时

23
00:00:53,366 --> 00:00:55,566
CPU可以执行其他任务

24
00:00:55,866 --> 00:00:58,099
而当外设需要CPU时

25
00:00:58,700 --> 00:01:00,800
将通过产生中断信号

26
00:01:00,800 --> 00:01:02,600
使CPU立即中断

27
00:01:02,600 --> 00:01:05,000
当前任务来响应中断请求

28
00:01:05,600 --> 00:01:09,066
这样可以使CPU避免把大量时间

29
00:01:09,066 --> 00:01:10,133
耗费在等待

30
00:01:10,133 --> 00:01:11,499
查询外设状态

31
00:01:11,666 --> 00:01:12,466
操作上

32
00:01:12,900 --> 00:01:16,100
大大提高系统实时性以及执行效率

33
00:01:18,066 --> 00:01:21,533
与中断相关的硬件可以划分为三类

34
00:01:21,733 --> 00:01:23,066
分别是设备

35
00:01:23,666 --> 00:01:25,533
中断控制器和CPU

36
00:01:26,066 --> 00:01:28,133
设备指发起中断的源

37
00:01:28,466 --> 00:01:30,599
当设备需要请求CPU时

38
00:01:30,600 --> 00:01:32,300
产生一个中断信号

39
00:01:32,500 --> 00:01:34,900
该信号连接至中断控制器

40
00:01:35,766 --> 00:01:36,799
中断控制器

41
00:01:37,266 --> 00:01:38,999
那么中断控制器是CPU

42
00:01:39,000 --> 00:01:40,500
众多外设中的一个

43
00:01:40,900 --> 00:01:42,066
管理外设的

44
00:01:42,066 --> 00:01:43,599
它是管理外设的外设

45
00:01:44,066 --> 00:01:46,299
外设是使用CPU

46
00:01:47,100 --> 00:01:49,200
外设要使用CPU

47
00:01:49,666 --> 00:01:52,599
得经过中断控制器的仲裁

48
00:01:53,066 --> 00:01:55,799
中断控制器一方面接收其他外设

49
00:01:55,800 --> 00:01:57,066
中断引角的输入

50
00:01:57,500 --> 00:02:01,133
另一方面它会发出中断信号给CPU

51
00:02:01,800 --> 00:02:03,200
所以可以通过

52
00:02:03,200 --> 00:02:05,866
对中断控制器编程来打开和关

53
00:02:05,866 --> 00:02:06,699
闭中断源

54
00:02:06,933 --> 00:02:09,866
设置中断源的优先级和处罚方式

55
00:02:10,666 --> 00:02:13,733
常用的终端控制器有v i c

56
00:02:14,166 --> 00:02:17,799
g i c在arm cotex m系列中

57
00:02:17,800 --> 00:02:20,666
使用的终端控制器是nvic

58
00:02:21,266 --> 00:02:22,966
在arm cotex a器中

59
00:02:22,966 --> 00:02:25,299
使用的终端控制器是g i c

60
00:02:26,300 --> 00:02:27,133
中断控制器

61
00:02:27,133 --> 00:02:30,499
分发中断源的请求给各个CPU

62
00:02:31,066 --> 00:02:33,399
CPU收到请求变中断

63
00:02:33,566 --> 00:02:35,199
当前正在执行的任务

64
00:02:35,366 --> 00:02:37,799
转而执行中断处理程序

65
00:02:38,300 --> 00:02:40,366
那么我们刚才所介绍的这些东西呢

66
00:02:40,366 --> 00:02:41,966
都是由硬件自动完成的

67
00:02:42,066 --> 00:02:43,133
只要你设置好

68
00:02:43,166 --> 00:02:45,199
就是说只要你在开机的时候

69
00:02:45,200 --> 00:02:46,300
就是内核把这些

70
00:02:46,300 --> 00:02:47,766
终端控制器的工作模式

71
00:02:47,933 --> 00:02:49,566
按照说明书设置好之后

72
00:02:49,666 --> 00:02:52,399
那么硬件就按照这个设置来配置

73
00:02:52,400 --> 00:02:53,066
来进行工作

74
00:02:53,066 --> 00:02:55,333
所以我现在说的所有这一切啊

75
00:02:55,333 --> 00:02:56,599
都是由硬件完成的

76
00:02:56,900 --> 00:02:58,466
就是说外设产生中断

77
00:02:58,700 --> 00:03:00,266
然后发送给中断控制器

78
00:03:00,266 --> 00:03:03,733
供中断控制器形成外设的这个编号啊

79
00:03:03,733 --> 00:03:04,699
形成中断号

80
00:03:04,900 --> 00:03:07,866
然后通知CPU啊这些东西都是

81
00:03:07,866 --> 00:03:10,133
然后呢跳转到CPU跳转到

82
00:03:10,666 --> 00:03:12,333
跳转到中断处理程序

83
00:03:12,333 --> 00:03:14,266
那这一切都是由硬件完成的

84
00:03:16,133 --> 00:03:17,733
那么这就是整个这个图

85
00:03:17,733 --> 00:03:19,766
那么这个图主要显示的是什么呢

86
00:03:19,766 --> 00:03:21,566
这个外设没有化啊

87
00:03:21,566 --> 00:03:23,733
外设没有化或者是你认为这是外设

88
00:03:23,900 --> 00:03:27,300
外设通过GPL连接这个充这是外设

89
00:03:27,400 --> 00:03:28,566
外设呢通过

90
00:03:28,966 --> 00:03:31,499
中啊GPL连接着中断控制器

91
00:03:31,533 --> 00:03:32,799
那么中断控制器你看

92
00:03:32,800 --> 00:03:35,200
这就是外设传来的这个中断信号

93
00:03:35,300 --> 00:03:36,200
那么中断信

94
00:03:36,366 --> 00:03:38,566
中端控制器呢把这个分发给谁呢

95
00:03:38,566 --> 00:03:39,799
分发给各个CPU

96
00:03:39,800 --> 00:03:40,200
看到了吧

97
00:03:40,200 --> 00:03:42,466
中端控制器把这个分发给各个CPU

98
00:03:42,600 --> 00:03:43,900
那么在这里头呢我们有

99
00:03:43,900 --> 00:03:45,766
一个非常重要的一个寄存器啊

100
00:03:45,766 --> 00:03:47,099
当然这些都是寄存器啊

101
00:03:47,100 --> 00:03:48,800
但是它有一个格外重要的寄存器

102
00:03:48,800 --> 00:03:50,066
就是这个IRA

103
00:03:50,166 --> 00:03:51,499
不iar寄存器

104
00:03:51,700 --> 00:03:52,966
IR计存器是什么意思呢

105
00:03:52,966 --> 00:03:54,399
比如说外部有一个比如键盘

106
00:03:54,400 --> 00:03:55,533
产生了一个中断

107
00:03:55,666 --> 00:03:56,299
那么

108
00:03:56,300 --> 00:03:59,066
在中断控制器里的这个IAR寄存器

109
00:03:59,066 --> 00:04:00,133
它就知道什么呢

110
00:04:00,133 --> 00:04:00,933
这个

111
00:04:01,566 --> 00:04:02,066
这个什么呢

112
00:04:02,066 --> 00:04:02,666
他就知道啊

113
00:04:02,666 --> 00:04:05,333
这个键盘所对应的就就类似于啥

114
00:04:05,333 --> 00:04:06,799
就类似我们刚才讲的系统调用

115
00:04:06,800 --> 00:04:08,200
每个系统调用有个系统调用号

116
00:04:08,200 --> 00:04:10,200
那么每个外设也有一个终端号

117
00:04:10,466 --> 00:04:11,266
它就它就会

118
00:04:11,266 --> 00:04:12,266
当一个外设

119
00:04:12,266 --> 00:04:13,266
某一个特定的外设

120
00:04:13,266 --> 00:04:14,933
产生一个中断的时候

121
00:04:14,933 --> 00:04:17,366
那么这个外设所对应的这个中中断号

122
00:04:17,366 --> 00:04:19,566
就会保存在这个IAR计算器里

123
00:04:19,566 --> 00:04:20,933
那么这样的话呢

124
00:04:20,933 --> 00:04:22,266
中断控制程序就跟

125
00:04:22,266 --> 00:04:24,099
根据保存在IAR这个

126
00:04:24,100 --> 00:04:25,566
计算器里的中断号

127
00:04:25,566 --> 00:04:27,399
来执行相应的中断处理程序

128
00:04:29,966 --> 00:04:30,966
所谓中断源呢

129
00:04:30,966 --> 00:04:33,499
即引起中断的事件或原因

130
00:04:33,600 --> 00:04:35,566
或发出中断申请的来源

131
00:04:35,566 --> 00:04:38,966
那么可分为外部中断源和内部中断源

132
00:04:39,166 --> 00:04:41,699
两大类那么外部中断源指

133
00:04:42,500 --> 00:04:45,200
由CPU的外部事件引发的中断

134
00:04:45,200 --> 00:04:46,000
主要包括

135
00:04:46,466 --> 00:04:48,299
啊一般中慢速外设

136
00:04:48,300 --> 00:04:50,466
比如说键盘打印机鼠标等

137
00:04:50,600 --> 00:04:51,866
那么数据通道

138
00:04:51,866 --> 00:04:55,499
比如说磁盘啊数据采集装置和网络等

139
00:04:56,300 --> 00:04:59,666
那么实时时钟啊如定时器定时已到

140
00:04:59,800 --> 00:05:00,600
啊

141
00:05:01,000 --> 00:05:01,700
故障源

142
00:05:01,700 --> 00:05:04,600
比如说电源掉电外设故障啊等等

143
00:05:04,666 --> 00:05:05,499
内部中断源

144
00:05:05,500 --> 00:05:06,200
指的是

145
00:05:06,200 --> 00:05:08,933
由CPU的内部事件或异常引发的中断

146
00:05:08,933 --> 00:05:10,399
主要包括由CPU

147
00:05:11,000 --> 00:05:14,566
执行中断指令int n引发的中断啊

148
00:05:14,566 --> 00:05:17,666
由CPU的某些运算错误引发的中断

149
00:05:17,666 --> 00:05:19,299
比如说除0啊溢出啊

150
00:05:19,333 --> 00:05:20,766
未调日程序设置中断

151
00:05:20,766 --> 00:05:23,733
比如说单不干单不跟踪啊断点等

152
00:05:23,966 --> 00:05:25,766
由于特殊操作引起的中断

153
00:05:25,966 --> 00:05:27,366
还有就是合间中断

154
00:05:27,866 --> 00:05:29,266
那么在Letox中

155
00:05:29,266 --> 00:05:31,566
就因为它是支持对称多处理器的

156
00:05:31,566 --> 00:05:32,699
所以说它就有

157
00:05:32,966 --> 00:05:34,933
经常会看到这个核间中断

158
00:05:36,166 --> 00:05:38,866
把中断源呢划分为三种中断类型

159
00:05:38,866 --> 00:05:40,533
第一种叫做PPI

160
00:05:40,566 --> 00:05:44,899
叫做私有外设中断private peripheral interrupt

161
00:05:45,666 --> 00:05:48,066
是每个CPU私有的中断

162
00:05:48,066 --> 00:05:50,366
最多支持16个私有中断

163
00:05:50,766 --> 00:05:54,299
那么硬件中断号从16到31

164
00:05:54,733 --> 00:05:57,933
PPI通常会送达到指定的CPU上

165
00:05:58,200 --> 00:06:00,500
应用场景有CPU本地失踪

166
00:06:00,766 --> 00:06:01,666
还有是什么呢

167
00:06:01,666 --> 00:06:06,699
就是SGI软件触发中断software generated indraft

168
00:06:06,900 --> 00:06:09,066
通常用于多核间通信

169
00:06:09,200 --> 00:06:11,400
最多支持16个SGI中断

170
00:06:11,666 --> 00:06:13,666
硬件中断号从0-15

171
00:06:13,800 --> 00:06:17,866
SGI呢通常在内核中被用作核间中断

172
00:06:18,500 --> 00:06:20,533
信号会送达到

173
00:06:21,200 --> 00:06:22,666
系统指定的CPU上

174
00:06:22,666 --> 00:06:25,766
那么主要用于多个CPU并存的情况

175
00:06:26,566 --> 00:06:27,666
那么SPI

176
00:06:28,133 --> 00:06:31,699
叫做公共外设中断shared peripheral Interrupt

177
00:06:31,766 --> 00:06:35,266
那么最多可以支持988个外设中断

178
00:06:35,466 --> 00:06:38,699
那么硬件中断号从32到1019

179
00:06:39,166 --> 00:06:39,966
那么

180
00:06:41,100 --> 00:06:41,966
这就是

181
00:06:42,000 --> 00:06:44,466
那个arm处理器的这个中断情况

182
00:06:45,200 --> 00:06:48,266
紧急事件需向CPU提出请求

183
00:06:48,400 --> 00:06:51,100
那么也就是发送一个电脉冲信号

184
00:06:51,300 --> 00:06:53,733
要求CPU暂停当前执行的任务

185
00:06:53,733 --> 00:06:55,699
转而处理该紧急事件

186
00:06:56,066 --> 00:06:58,799
这一申请过程呢称为中断请求

187
00:06:59,266 --> 00:07:02,333
这个申请必须经过中断控制器的仲裁

188
00:07:02,900 --> 00:07:06,100
中断源向中断控制器发送中断信号

189
00:07:06,533 --> 00:07:08,099
比如说可以用电瓶触发

190
00:07:08,100 --> 00:07:09,400
也可以用边沿触发

191
00:07:10,133 --> 00:07:12,466
中断控制器对中断进行仲裁

192
00:07:12,466 --> 00:07:13,499
确定优先级

193
00:07:13,900 --> 00:07:15,933
将中断信号送给CPU

194
00:07:16,400 --> 00:07:18,800
中断源产生中断信号的时候

195
00:07:19,200 --> 00:07:22,266
就会将中断触发器制一

196
00:07:22,500 --> 00:07:25,100
表明该中断源产生的中断

197
00:07:25,100 --> 00:07:27,733
那么这样的话CPU就去响应该中断

198
00:07:30,566 --> 00:07:31,533
为使系统能够

199
00:07:31,533 --> 00:07:33,566
及时响应并处理所有中断

200
00:07:33,900 --> 00:07:36,566
系统根据中断时间的重要性

201
00:07:36,600 --> 00:07:37,800
和紧迫程度

202
00:07:37,933 --> 00:07:40,399
将中断源分为若干个级别

203
00:07:40,400 --> 00:07:42,866
那么我们管这个叫做中断的优先级

204
00:07:43,666 --> 00:07:45,599
当外设产生中断请求后

205
00:07:45,600 --> 00:07:47,366
CPU暂停当前的任务

206
00:07:47,533 --> 00:07:49,099
转而响应中断请求

207
00:07:49,100 --> 00:07:50,866
即执行中断处理程序

208
00:07:51,366 --> 00:07:53,099
产生中断的每个设备

209
00:07:53,366 --> 00:07:55,499
都有相应的中断处理程序

210
00:07:55,500 --> 00:07:56,533
那么我们后面呢

211
00:07:56,533 --> 00:07:57,533
讲软件的时候就

212
00:07:57,533 --> 00:07:59,366
就会看这个过程是怎么做的

213
00:08:00,800 --> 00:08:03,566
中断号那就类似于系统调用号

214
00:08:03,733 --> 00:08:06,766
每个中断请求信号都会有特定的标志

215
00:08:07,400 --> 00:08:08,333
那么这个中断号

216
00:08:08,333 --> 00:08:10,266
就会保存在我们刚才说那个ILR

217
00:08:10,266 --> 00:08:11,066
计算器中

218
00:08:11,600 --> 00:08:12,800
使得计算机

219
00:08:12,800 --> 00:08:15,966
能够判断是哪个设备提出的中断请求

220
00:08:16,566 --> 00:08:18,799
这个标志就是中断号

221
00:08:19,366 --> 00:08:20,299
中段向量啊

222
00:08:20,300 --> 00:08:22,066
中段向量就像在那个数组啊

223
00:08:22,066 --> 00:08:23,099
我们再再讲那个

224
00:08:23,100 --> 00:08:24,933
前面在讲系统调里那个数组

225
00:08:25,400 --> 00:08:26,166
中段向量

226
00:08:26,166 --> 00:08:28,299
就是中段服务程序的入口地址

227
00:08:28,666 --> 00:08:31,999
中段向量表是存储中段向量的存储区

228
00:08:32,533 --> 00:08:34,733
中段向量与中段向量号对应

229
00:08:35,133 --> 00:08:37,399
中段向量在中段向量表中

230
00:08:37,533 --> 00:08:39,399
按照中段号顺序存储

231
00:08:39,866 --> 00:08:40,866
中段向量表

232
00:08:40,866 --> 00:08:43,066
是所有中段处理程序的入口

233
00:08:43,700 --> 00:08:45,133
那么如下图所示

234
00:08:45,533 --> 00:08:48,699
中断处理过程就是把一个函数

235
00:08:49,133 --> 00:08:50,699
同一个虚拟的

236
00:08:50,933 --> 00:08:53,566
中断向量表中的中断向量联系在一起

237
00:08:54,133 --> 00:08:56,766
当中断项量对应中断发生时

238
00:08:56,866 --> 00:08:58,766
被挂接在用户中断

239
00:08:58,933 --> 00:08:59,999
被挂接的用户

240
00:09:00,000 --> 00:09:02,400
中断服务程序就会被调用执行

241
00:09:02,466 --> 00:09:03,733
那么就是这样的一个情况

242
00:09:03,733 --> 00:09:05,966
那么外面是中断源啊中断源

243
00:09:06,500 --> 00:09:07,166
那么这是

244
00:09:07,166 --> 00:09:09,866
物理中断中断源然后呢经过什么呢

245
00:09:09,866 --> 00:09:12,133
经过中断控制器筛选送给CPU

246
00:09:12,133 --> 00:09:12,799
那CPU呢

247
00:09:12,800 --> 00:09:15,300
就会自动跳转到相应的中断处理程序

248
00:09:15,400 --> 00:09:16,733
这是一个公共中断处理程序

249
00:09:16,733 --> 00:09:18,799
公中各这个公公

250
00:09:18,800 --> 00:09:20,166
公共的中断处理程序呢

251
00:09:20,166 --> 00:09:23,199
就会根据IAR计存器中的保存内容

252
00:09:23,200 --> 00:09:24,333
到终端向量表中

253
00:09:24,333 --> 00:09:27,066
执行相应的用户中断服务程序

254
00:09:28,466 --> 00:09:30,366
那么也就是说所有中断

255
00:09:30,500 --> 00:09:33,166
都采用中断向量表的方式进行处理

256
00:09:33,500 --> 00:09:35,300
即当一个中断触发时

257
00:09:35,466 --> 00:09:38,733
处理器将直接判定是哪个中断源

258
00:09:38,733 --> 00:09:41,399
然后直接跳转到相应的

259
00:09:41,666 --> 00:09:43,099
固定位置进行处理

260
00:09:43,600 --> 00:09:46,866
每个中断服务程序必须排列在一起

261
00:09:46,966 --> 00:09:48,566
放在统一的地址上

262
00:09:48,966 --> 00:09:51,866
中断向量表一般由一个数组定义

263
00:09:51,900 --> 00:09:54,333
或在起始代码中给出

264
00:09:54,333 --> 00:09:56,366
那么在我们这个Leto s中

265
00:09:56,566 --> 00:09:58,866
中断向量表位于一开始啊

266
00:09:58,866 --> 00:09:59,733
位于开始

267
00:10:00,600 --> 00:10:01,900
内核的开始部分

268
00:10:03,100 --> 00:10:03,500
那么

269
00:10:03,500 --> 00:10:05,966
最后一部分就是用户中断服务程序

270
00:10:05,966 --> 00:10:08,566
叫做ISR interrupt service

271
00:10:09,333 --> 00:10:10,133
service

272
00:10:11,066 --> 00:10:15,133
routine啊在用户中断服务程序中

273
00:10:15,366 --> 00:10:16,499
那么分两种情况

274
00:10:16,500 --> 00:10:19,400
第一种情况是不进行任务切换

275
00:10:19,400 --> 00:10:20,866
那么在这种情况下呢

276
00:10:20,866 --> 00:10:23,199
会进行任务中断上下文

277
00:10:23,200 --> 00:10:24,000
叫做

278
00:10:24,600 --> 00:10:26,733
task LQ context的切换

279
00:10:29,533 --> 00:10:29,899
那么

280
00:10:29,900 --> 00:10:32,933
用户中断服务程序和中断后续程序

281
00:10:33,533 --> 00:10:34,533
运行完毕后

282
00:10:34,533 --> 00:10:37,399
退出中断模式返回被中断的线程

283
00:10:39,766 --> 00:10:41,699
那么第一种情况就是不进行任务

284
00:10:41,700 --> 00:10:43,100
切换啊这个不进任

285
00:10:43,333 --> 00:10:45,733
另一种情况是在中断处理过程中

286
00:10:45,733 --> 00:10:48,099
需要进行现成的切换啊

287
00:10:48,100 --> 00:10:50,366
这个我们在讲现成切进成调度的时候

288
00:10:50,366 --> 00:10:51,866
不任务调度的时候会说

289
00:10:52,166 --> 00:10:53,299
那么这种切换呢

290
00:10:53,300 --> 00:10:55,800
还会进行任务上的上下文切换

291
00:10:55,800 --> 00:10:57,666
就是task和contacts的切换

292
00:10:59,300 --> 00:11:01,466
在允许中断嵌套的情况下

293
00:11:01,733 --> 00:11:03,699
在执行中断服务处理的过程中

294
00:11:03,700 --> 00:11:05,666
如果出现高优先级的中断

295
00:11:05,900 --> 00:11:09,066
当前中断服务程序的执行将会被打断

296
00:11:09,200 --> 00:11:12,566
以执行高优先级中断的中断服务程序

297
00:11:12,800 --> 00:11:14,466
当高优先级中断的

298
00:11:15,300 --> 00:11:16,366
处理完成后

299
00:11:16,400 --> 00:11:18,466
被打断的中断服务程序才能

300
00:11:18,533 --> 00:11:19,766
得到继续执行

301
00:11:19,866 --> 00:11:22,299
如果需要执行县城调度

302
00:11:22,300 --> 00:11:24,000
那么县城的上下文切换

303
00:11:24,000 --> 00:11:26,700
将在所有中断处理程序都运行结束后

304
00:11:26,700 --> 00:11:27,500
才会发生

305
00:11:30,000 --> 00:11:32,600
那么这就涉及到这个任务的切换了啊

306
00:11:32,600 --> 00:11:34,166
那我们讲任务切换的时候会说

307
00:11:34,166 --> 00:11:37,099
那最后一点就是当外设比较少的时候

308
00:11:37,166 --> 00:11:40,166
可以实现一个外设对应一个终端号

309
00:11:40,466 --> 00:11:43,299
但为了支持更多的硬件设备

310
00:11:43,366 --> 00:11:46,566
可以让多个设备共享一个终端号

311
00:11:47,566 --> 00:11:49,566
共享同一个中断号的

312
00:11:49,900 --> 00:11:51,933
中断处理程序形成一个列表

313
00:11:52,333 --> 00:11:54,799
当外部设备产生中断请求时

314
00:11:54,900 --> 00:11:56,166
系统会便利

315
00:11:56,266 --> 00:11:59,399
执行中断号对应的中断处理程序列表

316
00:11:59,700 --> 00:12:00,766
直到找到

317
00:12:00,866 --> 00:12:03,599
对应程序对应设备的中断处理程序

318
00:12:04,266 --> 00:12:06,333
在便利执行过程中

319
00:12:06,566 --> 00:12:10,333
各中断处理程序可以通过检查设备ID

320
00:12:10,800 --> 00:12:11,600
判断

321
00:12:11,666 --> 00:12:14,099
是否是这个中断处理程序对应的

322
00:12:14,100 --> 00:12:15,166
设备产生的中断

323
00:12:15,166 --> 00:12:16,399
那这个很重要啊

324
00:12:17,600 --> 00:12:19,200
我们在线下课的时候

325
00:12:19,200 --> 00:12:20,366
在这个位置会暂停

326
00:12:20,366 --> 00:12:22,299
给大家介绍一下这个中段共享

327
00:12:22,300 --> 00:12:23,500
到底是一个怎么回事

328
00:12:25,400 --> 00:12:28,900
核间中断属于SGI中断系类型

329
00:12:29,200 --> 00:12:30,700
对于多核系统

330
00:12:31,166 --> 00:12:32,166
中断控制程序

331
00:12:32,166 --> 00:12:35,066
允许一个CPU上运行的线程去中断

332
00:12:35,066 --> 00:12:36,533
其他CPU上的线程

333
00:12:37,000 --> 00:12:38,933
这种方式被称为核间中断

334
00:12:39,533 --> 00:12:42,799
核间中断的实现基础是多CPU共享

335
00:12:42,900 --> 00:12:43,800
内存共享

336
00:12:44,166 --> 00:12:47,199
采用核间中断的可以减少某个CPU负

337
00:12:47,200 --> 00:12:49,766
荷过大有效提升系统效率

338
00:12:50,100 --> 00:12:51,100
那么我们看一下

339
00:12:51,100 --> 00:12:53,766
以下就是Letos支持的三个啊

340
00:12:53,766 --> 00:12:55,133
三种类型的这个核

341
00:12:55,133 --> 00:12:55,933
间中断

342
00:12:56,466 --> 00:12:57,799
那么可以看出

343
00:12:58,000 --> 00:13:00,533
CPU之间可以执行相互唤醒

344
00:13:00,533 --> 00:13:01,466
看微卡

345
00:13:02,266 --> 00:13:03,999
调度sky do相互调度

346
00:13:04,100 --> 00:13:05,400
还有hard停止

347
00:13:06,100 --> 00:13:09,733
那么和间中断有特殊有其特殊性

348
00:13:09,933 --> 00:13:12,199
那么出现于多个CPU的情况

349
00:13:12,400 --> 00:13:14,266
CPU之间可以相互唤醒

350
00:13:14,500 --> 00:13:15,366
停止工作

351
00:13:15,466 --> 00:13:20,466
比如CPUA通过GCI通知CPU b停止工作

352
00:13:21,566 --> 00:13:23,099
那么以下呢就是

353
00:13:23,700 --> 00:13:27,066
啊中段与中段相关的一些函数啊

354
00:13:27,900 --> 00:13:31,000
那么最重要的函数就是这个h i create啊

355
00:13:31,000 --> 00:13:31,800
h i create

356
00:13:32,866 --> 00:13:34,933
那从我们刚才的这个

357
00:13:35,133 --> 00:13:36,299
从我们刚才的这个描述

358
00:13:36,300 --> 00:13:37,300
我们可以知道啊

359
00:13:37,300 --> 00:13:39,600
大家看我们已经学过了系统调用

360
00:13:39,600 --> 00:13:40,866
系统调用实际上

361
00:13:41,300 --> 00:13:42,933
分成两部分一部分是初始化

362
00:13:42,933 --> 00:13:44,999
另外一部分是在程序运行的时候

363
00:13:45,000 --> 00:13:45,600
怎么处发

364
00:13:45,600 --> 00:13:46,533
这个系统调用

365
00:13:46,566 --> 00:13:47,799
那同样的道理啊

366
00:13:47,900 --> 00:13:48,966
中断也是这样

367
00:13:49,000 --> 00:13:50,000
那么中断呢

368
00:13:50,000 --> 00:13:52,566
最主要的就是这个就是初始化啊

369
00:13:52,566 --> 00:13:53,166
初始化

370
00:13:53,166 --> 00:13:56,099
那为什么说他的这个就是处发过程

371
00:13:56,100 --> 00:13:57,333
那处发过程

372
00:13:57,333 --> 00:13:59,499
相对于这个系统调要更简单一些

373
00:13:59,500 --> 00:13:59,966
为什么呢

374
00:13:59,966 --> 00:14:01,366
因为这个整个的处发过程

375
00:14:01,366 --> 00:14:03,566
基本上全是由硬件来完成啊

376
00:14:03,666 --> 00:14:04,799
硬件产生中断

377
00:14:04,933 --> 00:14:06,366
然后呢形成中断号

378
00:14:06,366 --> 00:14:07,799
然后跳转到相应的

379
00:14:07,800 --> 00:14:09,566
这个就是中断处理程序

380
00:14:10,133 --> 00:14:11,499
都是由硬件来完成的

381
00:14:11,500 --> 00:14:13,533
那好我们现在就介绍这两部分内容

382
00:14:13,533 --> 00:14:16,299
我们首先介绍的就是这个初始化啊

383
00:14:16,300 --> 00:14:17,100
初始化

384
00:14:17,466 --> 00:14:20,199
那首先是我们怎么样把这个中断呢

385
00:14:20,200 --> 00:14:21,666
就是中断控制器啊

386
00:14:21,666 --> 00:14:23,466
对中断控制器进行初始化

387
00:14:23,700 --> 00:14:25,966
假设呢我们的编译平台是这个

388
00:14:26,366 --> 00:14:27,333
HI这个平台

389
00:14:27,333 --> 00:14:28,733
那么预编译处理程序呢

390
00:14:28,733 --> 00:14:32,133
会自动的生成预编译的这个开关啊

391
00:14:32,133 --> 00:14:34,766
编译开关就是manuconfig点h

392
00:14:34,966 --> 00:14:36,499
供变异阶段来选择啊

393
00:14:36,500 --> 00:14:39,533
大家看因为我们这个平台呢是GCI啊

394
00:14:39,533 --> 00:14:41,099
GCI这个重断控制器

395
00:14:41,100 --> 00:14:42,333
所以你看把GCI

396
00:14:42,333 --> 00:14:43,899
重断控制器的这个位置一了

397
00:14:43,900 --> 00:14:45,000
标志位置一了

398
00:14:45,966 --> 00:14:47,566
那么这个平台呢

399
00:14:47,566 --> 00:14:50,799
中断控制器选择了这个GCI VR版本

400
00:14:50,966 --> 00:14:52,766
那么这个就是它的一个初始化函数

401
00:14:52,766 --> 00:14:53,999
你看它主要是对这个

402
00:14:54,000 --> 00:14:55,666
相应的这个计存器进行

403
00:14:55,766 --> 00:14:56,799
设置看到了吗

404
00:14:56,800 --> 00:14:57,700
它对这个

405
00:14:57,700 --> 00:15:00,066
中断控制器的相应计存器进行设置

406
00:15:00,266 --> 00:15:02,133
那么具体是设置什么情况啊

407
00:15:02,133 --> 00:15:03,199
大家可以看一下

408
00:15:03,200 --> 00:15:05,066
这个相应的这个GCI的手册

409
00:15:06,866 --> 00:15:09,266
那么GCR VR啊支持什么呢

410
00:15:09,266 --> 00:15:13,266
支持SGI也就是软软件终端出发啊

411
00:15:13,266 --> 00:15:14,199
软件终端出发

412
00:15:15,166 --> 00:15:17,733
那么硬件终端触发以及IPI啊

413
00:15:17,733 --> 00:15:19,299
它都支持啊

414
00:15:19,366 --> 00:15:20,499
那么我们看一下啊

415
00:15:20,500 --> 00:15:21,800
这个就是大家看啊

416
00:15:21,800 --> 00:15:24,666
它通过这个loss hwikera的函数呢

417
00:15:24,666 --> 00:15:26,333
来因为它支持这个SGI

418
00:15:26,333 --> 00:15:28,099
所以你看它把这SGI

419
00:15:28,100 --> 00:15:30,133
这是SGI的这个中断号啊

420
00:15:30,133 --> 00:15:32,566
中断号那这个就是相应的处理程序

421
00:15:32,566 --> 00:15:33,366
看到了吧

422
00:15:33,666 --> 00:15:34,299
处理程序

423
00:15:34,300 --> 00:15:35,566
那也就是说当啊

424
00:15:35,566 --> 00:15:37,666
某一个CPU产生这个微微cap

425
00:15:37,666 --> 00:15:39,566
想唤醒另外一个CPU的时候

426
00:15:39,600 --> 00:15:41,166
它就会产生一个核间中断

427
00:15:41,166 --> 00:15:43,099
那么这样的话呢就会触发这个

428
00:15:43,400 --> 00:15:45,966
就会触发这个函数它的运行啊

429
00:15:45,966 --> 00:15:46,699
那这个函数

430
00:15:46,700 --> 00:15:49,200
显然就是会需要唤醒另外一个CPU

431
00:15:51,000 --> 00:15:51,866
好我们来看一下

432
00:15:51,866 --> 00:15:53,966
这几个关键的数据结构啊

433
00:15:54,133 --> 00:15:55,133
跟中断相关的

434
00:15:55,133 --> 00:15:56,666
非常关键的这个数据结构

435
00:15:56,900 --> 00:15:57,666
第一个数据结

436
00:15:57,666 --> 00:15:59,266
构叫做global in the count

437
00:15:59,300 --> 00:16:00,600
in the count表示什么呢

438
00:16:00,600 --> 00:16:02,700
表示用于记录每个CPU

439
00:16:02,966 --> 00:16:04,199
产生中断的数量

440
00:16:04,800 --> 00:16:06,766
第二个是最重要的就是中段向列表啊

441
00:16:06,766 --> 00:16:07,899
它就是中段向列表

442
00:16:08,266 --> 00:16:10,466
那这个呢是记录每一个中段的名称

443
00:16:10,600 --> 00:16:12,066
那这个是记录什么呢

444
00:16:12,066 --> 00:16:15,533
这个就是interrupt form count啊form count

445
00:16:17,766 --> 00:16:19,366
好我们看一下这个

446
00:16:19,366 --> 00:16:20,999
我们就看一下这个终端向量表

447
00:16:21,000 --> 00:16:21,900
它的结构是什么

448
00:16:21,900 --> 00:16:23,566
我们知道它既然中端向量表的话

449
00:16:23,566 --> 00:16:24,733
它肯定是一个函数

450
00:16:24,733 --> 00:16:25,466
有个函数指针

451
00:16:25,466 --> 00:16:26,966
那显然这个就是函数指针

452
00:16:27,133 --> 00:16:29,166
那这个呢就是这个函数的参数

453
00:16:29,266 --> 00:16:30,766
这个是那个函数的参数

454
00:16:30,866 --> 00:16:31,766
那这个是什么呢

455
00:16:31,766 --> 00:16:34,066
这个就是我们知道在刚才介绍共享

456
00:16:34,466 --> 00:16:35,066
中断

457
00:16:35,066 --> 00:16:37,333
在共享的时候比如一个中断号啊

458
00:16:37,400 --> 00:16:39,666
被多个硬件设备共享

459
00:16:39,700 --> 00:16:40,866
那么这个就是

460
00:16:40,900 --> 00:16:42,366
所有共享这个中断号的设备

461
00:16:42,366 --> 00:16:44,199
要组成一个列表啊

462
00:16:44,333 --> 00:16:45,133
那这个是什么呢

463
00:16:45,133 --> 00:16:46,966
这个也是为共享服务的啊

464
00:16:46,966 --> 00:16:49,366
这也这也是为共享服务的

465
00:16:49,500 --> 00:16:51,366
或者说它它起两个作用啊

466
00:16:51,366 --> 00:16:53,333
一个是作为函数的参数

467
00:16:53,333 --> 00:16:55,566
就是这个终端处理服务程序的参数

468
00:16:55,733 --> 00:16:57,299
另外一个是为共享服务的

469
00:16:57,300 --> 00:16:59,166
那你看这地方有个pdys ID

470
00:16:59,166 --> 00:17:02,133
pdys ID那我怎么知道这个函数

471
00:17:02,133 --> 00:17:03,733
因为比如说一个终端号

472
00:17:03,733 --> 00:17:04,899
被多个设备共享

473
00:17:04,900 --> 00:17:06,566
那我怎么知道这个函数

474
00:17:06,566 --> 00:17:07,966
处理的是哪一个设备呢

475
00:17:07,966 --> 00:17:10,666
那我就拿着这个PID啊和这个

476
00:17:11,066 --> 00:17:12,066
每一个设备去读

477
00:17:12,133 --> 00:17:12,966
读每一个设备的我

478
00:17:12,966 --> 00:17:14,666
我首先这个中断处理函数

479
00:17:14,666 --> 00:17:15,766
要去读每一个设备

480
00:17:15,766 --> 00:17:16,966
他的ID

481
00:17:17,133 --> 00:17:17,699
然后呢

482
00:17:17,700 --> 00:17:20,333
拿着这个ID和这个PID device ID去比

483
00:17:20,333 --> 00:17:22,099
如果相等的话才表示什么

484
00:17:22,100 --> 00:17:24,066
呢才表示啊我这个处理函数

485
00:17:24,533 --> 00:17:26,899
我这个中断服务程序就是为那个

486
00:17:27,133 --> 00:17:28,299
设备来服务的

487
00:17:30,000 --> 00:17:30,166
好

488
00:17:30,166 --> 00:17:33,333
我们来具体看一下这个HWI create函数

489
00:17:33,333 --> 00:17:34,166
它的这个

490
00:17:34,466 --> 00:17:36,966
作用我们看一下这个函数总共有5个

491
00:17:36,966 --> 00:17:37,766
5个这个

492
00:17:38,133 --> 00:17:39,999
5个入口参数啊入口参数

493
00:17:40,166 --> 00:17:41,566
首先第一个参数是什么呢

494
00:17:41,566 --> 00:17:45,533
就是这个硬件中段啊硬硬中段的聚丙

495
00:17:46,000 --> 00:17:48,333
硬中段的聚丙也就是中段号啊中段号

496
00:17:48,733 --> 00:17:50,299
那么第二个就是它的优先级

497
00:17:50,466 --> 00:17:52,199
第三个就是说它到底是共享的

498
00:17:52,200 --> 00:17:53,533
这个中断号到底是共享的

499
00:17:53,533 --> 00:17:54,499
还是非共享的

500
00:17:54,533 --> 00:17:56,533
第四个就是函数中断处理函数

501
00:17:56,533 --> 00:17:56,899
第五个

502
00:17:56,900 --> 00:17:59,166
就是这个中断处理函数所对应的参数

503
00:17:59,533 --> 00:18:00,666
参数那我们看一下

504
00:18:00,666 --> 00:18:02,499
首先看一下啊首先是判断

505
00:18:02,566 --> 00:18:04,999
如果中断处理历程啊中断

506
00:18:05,166 --> 00:18:07,566
中断服务程序是空的话返回错误对吧

507
00:18:07,766 --> 00:18:09,866
那法否然后再判断是这个

508
00:18:09,866 --> 00:18:11,866
这个中断号在不在这个

509
00:18:12,566 --> 00:18:13,866
最大最小中断号之间

510
00:18:13,866 --> 00:18:15,866
如果不在的话也反而错误对吧

511
00:18:15,933 --> 00:18:17,299
然后呢来判断

512
00:18:17,300 --> 00:18:19,500
是不是支持这个中断共享

513
00:18:19,933 --> 00:18:20,866
中端号共享

514
00:18:20,900 --> 00:18:23,900
那如果啊支持啊不支持中端号共享

515
00:18:23,900 --> 00:18:26,200
那我就是调用这个create no share

516
00:18:26,466 --> 00:18:27,799
如果要是支持中端号共享

517
00:18:27,800 --> 00:18:29,866
我就调用这个中端号共享啊

518
00:18:29,866 --> 00:18:32,999
那我们为了这个就是讲的更复杂一点

519
00:18:33,000 --> 00:18:35,400
我们去假设它支持这个中端号扩展

520
00:18:35,733 --> 00:18:39,099
所以我们就来讲一下这个OSHWI create share

521
00:18:39,200 --> 00:18:40,000
share的啊

522
00:18:40,300 --> 00:18:42,166
那这个函数呢大家看啊

523
00:18:42,266 --> 00:18:44,799
你你你你从这个名字上你就可以知道

524
00:18:44,866 --> 00:18:45,933
那也就是说

525
00:18:45,933 --> 00:18:47,733
我传递过来一个中断号对吧

526
00:18:47,733 --> 00:18:49,266
然后它肯定是支持共享的

527
00:18:49,266 --> 00:18:50,766
这是中断号的这个

528
00:18:51,333 --> 00:18:53,266
中断处理函中断服务程序的

529
00:18:53,266 --> 00:18:54,299
这个函数指针

530
00:18:54,300 --> 00:18:56,466
这个是中断服务程序的这个参数

531
00:18:56,800 --> 00:18:57,466
那怎么样呢

532
00:18:57,466 --> 00:18:58,466
我们就用这个

533
00:18:59,066 --> 00:19:00,599
我们就用这个指针

534
00:19:00,600 --> 00:19:02,733
这个函数指针再加上这个函数参数

535
00:19:02,866 --> 00:19:04,299
形成一个链表啊

536
00:19:04,300 --> 00:19:05,666
形成生成这么一个

537
00:19:05,800 --> 00:19:07,333
生成这么一个结构体对吧

538
00:19:07,333 --> 00:19:08,566
生成这么一个结构体

539
00:19:08,600 --> 00:19:10,300
然后呢把它把它插到哪呢

540
00:19:10,300 --> 00:19:11,466
把它插到这个

541
00:19:11,966 --> 00:19:13,299
把它插到这个g啊

542
00:19:13,300 --> 00:19:15,566
global HWI form这个

543
00:19:15,766 --> 00:19:17,866
相应的终端号的那个双向列表里啊

544
00:19:17,866 --> 00:19:18,466
就形成了

545
00:19:18,466 --> 00:19:20,099
所以它整个流程就是这样的

546
00:19:20,200 --> 00:19:21,333
首先我根据终端号

547
00:19:21,333 --> 00:19:22,299
到终端向列表中

548
00:19:22,300 --> 00:19:24,266
取出相应的这个终端向量

549
00:19:24,266 --> 00:19:25,066
它的位置

550
00:19:25,333 --> 00:19:26,333
然后呢

551
00:19:27,533 --> 00:19:28,799
然后呢来判断啊

552
00:19:28,800 --> 00:19:30,866
来判断判断合不合理啊

553
00:19:30,866 --> 00:19:33,499
如果你看他要是不不是share的对不对

554
00:19:33,500 --> 00:19:35,100
如果他的mode等于0等等等等

555
00:19:35,800 --> 00:19:37,566
啊那么我不不合法

556
00:19:37,566 --> 00:19:40,099
不合法我就返回啊不我就返回

557
00:19:40,166 --> 00:19:42,266
我就返回他就不是share的

558
00:19:42,333 --> 00:19:44,566
那如果合法的话我就一个外循环

559
00:19:45,066 --> 00:19:45,899
来辩利什么呢

560
00:19:45,900 --> 00:19:47,600
来辩利那个中断向量

561
00:19:47,600 --> 00:19:49,800
我们就怎么样辩利到那个中断向量

562
00:19:49,800 --> 00:19:52,266
所中断向量号所对应的那个设备

563
00:19:52,266 --> 00:19:53,333
链本的最后一个

564
00:19:53,400 --> 00:19:55,600
然后怎么样生成这个form啊

565
00:19:55,600 --> 00:19:56,733
看到生成这个form

566
00:19:56,733 --> 00:19:58,299
然后把这个form判断一下

567
00:19:58,600 --> 00:19:59,366
判断一下啊

568
00:19:59,366 --> 00:20:00,699
在在辩利的过程中啊

569
00:20:00,700 --> 00:20:02,933
把在辩利的过程中看一下就是说

570
00:20:03,533 --> 00:20:05,199
我这个我这个设备

571
00:20:05,333 --> 00:20:07,766
我这个设备我要先新新添加这个设备

572
00:20:07,766 --> 00:20:08,666
是不是已经出现了

573
00:20:08,666 --> 00:20:09,299
如果已经出

574
00:20:09,300 --> 00:20:10,866
已经出现在在那个列表里

575
00:20:10,866 --> 00:20:12,066
我就返回错误

576
00:20:12,133 --> 00:20:13,899
如果没有出现在那个列表里我怎么样

577
00:20:13,900 --> 00:20:15,300
我就生成一个节点

578
00:20:15,566 --> 00:20:17,299
然后呢把它插到这个

579
00:20:17,800 --> 00:20:19,300
生成这个节点啊

580
00:20:19,300 --> 00:20:20,900
然后对这个节点进行负值

581
00:20:20,933 --> 00:20:22,766
看对这个节点的参数进行负值

582
00:20:23,100 --> 00:20:26,366
然后呢把这个handle和这个

583
00:20:26,566 --> 00:20:29,133
把这个handle还有这个参数都复好值啊

584
00:20:29,133 --> 00:20:30,999
然后呢把这个新的节点呢

585
00:20:31,000 --> 00:20:32,100
插到这个里头

586
00:20:32,300 --> 00:20:33,800
看到了插到这个列表里头

587
00:20:33,966 --> 00:20:35,366
那就完成了这个

588
00:20:36,100 --> 00:20:38,533
完成了这个整个的这个操作啊

589
00:20:43,666 --> 00:20:45,099
好那么这个是什么呢

590
00:20:45,100 --> 00:20:47,700
这个就实际上是对parameter的一个负值

591
00:20:47,766 --> 00:20:49,099
啊就是这个地方

592
00:20:49,100 --> 00:20:49,900
这个地方

593
00:20:50,266 --> 00:20:51,499
这个入口参数是什么呢

594
00:20:51,500 --> 00:20:54,200
这个HR IRQ parameter就是入口参数

595
00:20:54,200 --> 00:20:56,900
就是说我现在要生成一个新的设备的

596
00:20:56,900 --> 00:20:59,533
这个新的设备的中端项量表

597
00:21:00,100 --> 00:21:02,333
的节点那这是他的这个入口参

598
00:21:02,333 --> 00:21:03,533
他是这个这个

599
00:21:03,866 --> 00:21:05,566
中断服务程序的入口参数

600
00:21:05,566 --> 00:21:08,133
那我把这个入口参数拷贝到这个

601
00:21:08,333 --> 00:21:10,166
这个设备节点的驱动里啊

602
00:21:10,166 --> 00:21:11,499
这个设备节点的那个

603
00:21:11,500 --> 00:21:13,866
就是中断处理程序的这个parameter

604
00:21:13,866 --> 00:21:14,466
这个地方

605
00:21:14,466 --> 00:21:17,266
所以你看它就是一个memories memory copy啊

606
00:21:17,266 --> 00:21:18,166
进行一个拷贝

607
00:21:19,600 --> 00:21:21,166
那么这个是什么呢

608
00:21:21,166 --> 00:21:22,299
就大给大家看一下

609
00:21:22,300 --> 00:21:23,266
这是中段项量

610
00:21:23,333 --> 00:21:25,133
中段项量这个中段元所对应的

611
00:21:25,133 --> 00:21:27,933
你看不同的中段元所对应的中段号

612
00:21:28,400 --> 00:21:29,066
看到了吧

613
00:21:29,066 --> 00:21:30,099
那么这什么意思呢

614
00:21:30,100 --> 00:21:33,266
比如说这个interrupt timer 0就保存在哪是33

615
00:21:33,300 --> 00:21:34,600
它就保存在这个form

616
00:21:34,600 --> 00:21:36,466
看它保存到哪呢

617
00:21:36,466 --> 00:21:39,166
它就保存到这个form的33的这个位置

618
00:21:39,200 --> 00:21:40,000
啊

619
00:21:40,900 --> 00:21:42,266
好那么举个例子啊

620
00:21:42,266 --> 00:21:42,766
举个例子

621
00:21:42,766 --> 00:21:43,499
刚才我们在

622
00:21:43,500 --> 00:21:44,766
你看我们刚才是不是讲完了

623
00:21:44,766 --> 00:21:45,866
这个Crede函数

624
00:21:45,866 --> 00:21:47,866
这个Crede函数这个Crede函数在哪用呢

625
00:21:47,866 --> 00:21:48,099
你看

626
00:21:48,100 --> 00:21:50,300
在这个地方和弦中段注册的时候用了

627
00:21:50,600 --> 00:21:52,066
他更多的是在哪用呢

628
00:21:52,066 --> 00:21:54,099
比如说我现在系统初始化的时候

629
00:21:54,266 --> 00:21:56,199
比如说我们系统最关键的一个硬件

630
00:21:56,200 --> 00:21:56,800
就是时钟

631
00:21:56,800 --> 00:21:57,600
硬件时钟

632
00:21:57,600 --> 00:21:58,000
那你看

633
00:21:58,000 --> 00:22:00,066
这个就是对硬件时钟进行初始化

634
00:22:00,066 --> 00:22:00,699
看到了吧

635
00:22:00,700 --> 00:22:01,300
那在这里头

636
00:22:01,300 --> 00:22:03,300
你看就调用了这个crate函数

637
00:22:03,300 --> 00:22:04,900
那它这个就是终端号

638
00:22:05,266 --> 00:22:07,399
终端号他的终端向量级优先级

639
00:22:07,466 --> 00:22:08,899
那这个就是终端处理程序

640
00:22:08,900 --> 00:22:10,800
看通过调用这个就在

641
00:22:10,933 --> 00:22:13,099
就在什么那个form数度global form数

642
00:22:13,100 --> 00:22:15,133
form数这个终端号所对应的位置

643
00:22:15,133 --> 00:22:16,666
怎么样把这个处理函数

644
00:22:16,900 --> 00:22:18,533
它的指针添加到哪了

645
00:22:18,533 --> 00:22:19,566
添加到那里了

646
00:22:22,533 --> 00:22:23,166
好

647
00:22:23,166 --> 00:22:24,766
那么我们现在讲完了初始化

648
00:22:24,766 --> 00:22:25,766
现在我们就讲一下

649
00:22:25,766 --> 00:22:27,366
这个中断是如何处发的

650
00:22:27,466 --> 00:22:28,699
那么主要是通过啊

651
00:22:28,700 --> 00:22:31,100
中断主要是通过硬件处发比如说按键

652
00:22:31,366 --> 00:22:33,533
那么USB的插拔这些中断源呢

653
00:22:33,533 --> 00:22:36,799
向中断控制器发送电电信号啊

654
00:22:36,900 --> 00:22:37,966
那么中断控制器呢

655
00:22:37,966 --> 00:22:41,099
经过过滤后将信号传送给相应的CPU

656
00:22:41,300 --> 00:22:42,166
通过改变

657
00:22:42,733 --> 00:22:46,066
PC硬件的PC和c CPSR值

658
00:22:46,066 --> 00:22:47,399
直接跳转到什么呢

659
00:22:47,400 --> 00:22:48,066
中断向量

660
00:22:48,066 --> 00:22:50,599
中断向量那你注意它这是第一次跳转

661
00:22:50,900 --> 00:22:51,600
依次跳转的时候

662
00:22:51,600 --> 00:22:53,300
都跳转到一个公共程序

663
00:22:53,333 --> 00:22:55,566
大家记不记得我们软中段跳转的时候

664
00:22:55,566 --> 00:22:57,066
是跳转到这个程序

665
00:22:57,100 --> 00:22:58,900
然后这个程序再跳转到那个

666
00:22:59,066 --> 00:23:01,933
呃呃M a三二a 32那个程序

667
00:23:01,933 --> 00:23:02,733
由那个程序呢

668
00:23:02,733 --> 00:23:05,566
再取什么RR 7寄存器的位置

669
00:23:05,733 --> 00:23:07,866
R7计存器的值然后再进行跳转

670
00:23:07,866 --> 00:23:09,599
那这个硬中段也是一样

671
00:23:09,666 --> 00:23:10,366
硬中段呢

672
00:23:10,366 --> 00:23:12,199
当这个CPU接触到中段的时候

673
00:23:12,200 --> 00:23:15,066
它马上跳转到这个RQOS RQ handle

674
00:23:15,133 --> 00:23:17,299
那这是一个相当于总的程序啊

675
00:23:17,300 --> 00:23:18,100
总的程序

676
00:23:18,166 --> 00:23:18,566
那这是

677
00:23:18,566 --> 00:23:20,999
硬中断还有一个叫做核间中断啊

678
00:23:21,000 --> 00:23:22,000
是不是核间中断

679
00:23:22,066 --> 00:23:22,966
那么核间中断呢

680
00:23:22,966 --> 00:23:26,399
通过软件触发常见于核间中断的情况

681
00:23:26,566 --> 00:23:28,533
那么核间中断指的是

682
00:23:28,600 --> 00:23:31,533
几个CPU之间相互通讯的过程

683
00:23:31,666 --> 00:23:33,366
那么以下呢就是

684
00:23:33,866 --> 00:23:36,533
以下呢为某一CPU向其他CPU发送

685
00:23:36,800 --> 00:23:38,466
让这些CPU重新调度

686
00:23:38,933 --> 00:23:41,199
那么这样的一个中断请求信号

687
00:23:41,600 --> 00:23:43,066
那么它是怎么做的呢

688
00:23:43,066 --> 00:23:44,666
你看啊它是怎么做的呢

689
00:23:44,666 --> 00:23:45,199
就是说

690
00:23:45,200 --> 00:23:48,900
它通过这个函数看到了RQ散的IPI那

691
00:23:49,300 --> 00:23:51,566
那你看这就是核间中断的中断号

692
00:23:51,566 --> 00:23:52,999
那这个就是目标CPU

693
00:23:53,266 --> 00:23:55,699
目标CPU的ID你看比如说我现在想

694
00:23:56,200 --> 00:23:58,533
怎么样让这个CPU进行调度

695
00:23:59,166 --> 00:24:00,299
让这个CPU进行调度

696
00:24:00,300 --> 00:24:01,500
那这个就是这个函数

697
00:24:01,500 --> 00:24:03,266
它调用了这个red SGI

698
00:24:03,400 --> 00:24:05,766
那我们看一下red SGI实际上就是什么

699
00:24:05,766 --> 00:24:07,199
把这个value我

700
00:24:07,200 --> 00:24:08,333
你看我向

701
00:24:08,333 --> 00:24:09,199
我向这个

702
00:24:09,200 --> 00:24:11,466
它给它发送一个什么样类型的中断

703
00:24:11,500 --> 00:24:14,000
那我组成一个value看在这进行未运算

704
00:24:14,066 --> 00:24:16,199
组成个value把这个value写到计算器里

705
00:24:16,200 --> 00:24:18,533
那实际上就是处罚另外一个CPU的

706
00:24:19,366 --> 00:24:20,166
中断

707
00:24:20,766 --> 00:24:22,666
那么无论怎么怎么做啊

708
00:24:22,666 --> 00:24:24,133
无论怎么做都是这样的啊

709
00:24:24,133 --> 00:24:25,399
那么我们现在说到哪了

710
00:24:25,400 --> 00:24:27,933
我们现在就要说这个OSLQ handle

711
00:24:27,933 --> 00:24:28,999
该做做什么了

712
00:24:29,500 --> 00:24:30,900
我们通过核间中断

713
00:24:30,900 --> 00:24:32,800
或者是就是核间这种

714
00:24:32,800 --> 00:24:34,133
写计算器还是怎么样

715
00:24:34,133 --> 00:24:36,066
反正我们都怎么样会触发这个

716
00:24:36,300 --> 00:24:37,200
这个这个函数

717
00:24:37,200 --> 00:24:39,200
OS r q handol这个函数的运行

718
00:24:39,266 --> 00:24:42,766
那o s r q handol主要进行4步第一步取号

719
00:24:43,266 --> 00:24:45,466
啊这个号呢就是由中断控制器

720
00:24:45,466 --> 00:24:46,766
就是IIAR计

721
00:24:46,766 --> 00:24:47,733
算器提供的

722
00:24:47,766 --> 00:24:49,199
那么它是一个专门的保存

723
00:24:49,200 --> 00:24:50,500
当前中断号的计算器

724
00:24:50,500 --> 00:24:51,133
那第二步呢

725
00:24:51,133 --> 00:24:52,566
就是我们很显然就是从

726
00:24:52,866 --> 00:24:56,366
global HWI form这个数度中查找

727
00:24:56,866 --> 00:24:57,666
注册的函数

728
00:24:57,733 --> 00:25:00,133
根据这个IAR计算机保存内容

729
00:25:00,133 --> 00:25:03,133
从这个从这个数组中把这个函数

730
00:25:03,166 --> 00:25:04,699
就把这个结构体取出来

731
00:25:04,733 --> 00:25:06,299
而这个结构体包含什么呢

732
00:25:06,300 --> 00:25:08,000
包含着就是第三步执行函数

733
00:25:08,000 --> 00:25:09,500
结构体中包含着这个注册

734
00:25:09,500 --> 00:25:10,800
就是create那个函数

735
00:25:11,200 --> 00:25:13,500
create函数注册的这个注册函数

736
00:25:13,566 --> 00:25:14,366
那么这时候呢

737
00:25:14,366 --> 00:25:16,533
就是分有参数和无参数情况

738
00:25:16,533 --> 00:25:17,866
还有就是共享

739
00:25:18,100 --> 00:25:19,700
这个指这个这个中断

740
00:25:19,700 --> 00:25:22,066
这个中断号是不是共享的等等啊

741
00:25:22,566 --> 00:25:24,766
然后就相应了结执执行这个函数

742
00:25:24,766 --> 00:25:25,466
最后一步呢

743
00:25:25,466 --> 00:25:28,199
就是向中断结束计算器进行写操作

744
00:25:28,300 --> 00:25:29,733
从而结束本本个

745
00:25:29,866 --> 00:25:32,533
就硬件炒硬件这个中断的执行

746
00:25:33,500 --> 00:25:36,500
好大家看一下这就是呃LQ

747
00:25:37,333 --> 00:25:40,299
HA LLQ憨豆儿这个函数好第一步是什么

748
00:25:40,300 --> 00:25:42,000
你看第一步你看它是什么

749
00:25:42,000 --> 00:25:42,800
从

750
00:25:43,333 --> 00:25:46,066
中断控制器的IR计存器中取值

751
00:25:46,066 --> 00:25:47,766
把它放到这个IR局部变量里

752
00:25:47,766 --> 00:25:48,299
我们知道啊

753
00:25:48,300 --> 00:25:49,133
我再重复一遍

754
00:25:49,133 --> 00:25:50,866
你看这个计存器保存什么

755
00:25:50,866 --> 00:25:52,299
就属于硬件形成的那个

756
00:25:52,300 --> 00:25:53,733
硬件源的这个中断号

757
00:25:53,733 --> 00:25:54,533
看到了吗

758
00:25:54,533 --> 00:25:55,466
形成中断号

759
00:25:56,100 --> 00:25:58,900
然后呢判断一下这个中断号怎么样

760
00:25:58,966 --> 00:25:59,866
是不是有效的

761
00:25:59,866 --> 00:26:01,566
如果是无效的就返回对吧

762
00:26:01,700 --> 00:26:04,000
然后呢把这个中断号保存起来

763
00:26:04,266 --> 00:26:06,333
然后调用这个OS interrop的号

764
00:26:06,533 --> 00:26:09,266
OS interrop这个OS interrop就相当于这个

765
00:26:09,266 --> 00:26:11,766
就相当于是刚才那个呃相当于什么呢

766
00:26:11,766 --> 00:26:12,733
相当于是这个

767
00:26:13,133 --> 00:26:13,966
相当于这个

768
00:26:14,133 --> 00:26:17,799
OS except software interrupt handler这个是

769
00:26:17,800 --> 00:26:19,333
这个这个函数

770
00:26:19,333 --> 00:26:21,999
而这个函数OS interrupt相当于啥呢

771
00:26:22,000 --> 00:26:23,766
这个OS interrupt就相当于是这个

772
00:26:23,766 --> 00:26:25,466
刚才这个am A32那个

773
00:26:25,466 --> 00:26:26,266
那个函数

774
00:26:26,600 --> 00:26:27,666
RMA32的函数

775
00:26:28,066 --> 00:26:29,733
好大家看这个保存的是什么

776
00:26:29,733 --> 00:26:32,166
这个保存的就是这个中断号啊中断元

777
00:26:32,200 --> 00:26:33,566
中断元所对应的中断号

778
00:26:33,566 --> 00:26:34,533
那这个就是什么呢

779
00:26:34,533 --> 00:26:37,199
当我当从这个OS interrupt返回的时候

780
00:26:37,200 --> 00:26:39,100
就表示中断处理程序已经结束了

781
00:26:39,100 --> 00:26:39,700
那怎么样呢

782
00:26:39,700 --> 00:26:41,800
我就向这个中断结束计算机写入值

783
00:26:41,800 --> 00:26:43,566
表示整个中断处理程序结束

784
00:26:44,466 --> 00:26:46,399
好我们现在来看一下这个OS Interrupt

785
00:26:46,400 --> 00:26:48,133
这个是中断元的这个中断号

786
00:26:48,133 --> 00:26:48,699
那干嘛呢

787
00:26:48,700 --> 00:26:49,900
你看它干嘛

788
00:26:49,900 --> 00:26:50,966
它首先就是说

789
00:26:50,966 --> 00:26:53,533
把对应CPU所处理的中断的次数加一

790
00:26:53,533 --> 00:26:55,766
啊这是进行一些统计工作看到了吧

791
00:26:55,933 --> 00:26:57,799
然后呢你看根据这个中断号

792
00:26:58,100 --> 00:27:00,100
从这个form数组中把这个中断

793
00:27:00,133 --> 00:27:01,566
把这个结构题取出来了

794
00:27:01,566 --> 00:27:03,066
那我们知道它是一个什么呀

795
00:27:03,066 --> 00:27:04,266
它可能是一个双向链表

796
00:27:04,266 --> 00:27:05,266
因为我们现在讲求

797
00:27:05,266 --> 00:27:07,133
一个中断号是支持多个设备的

798
00:27:07,133 --> 00:27:07,699
对吧

799
00:27:07,700 --> 00:27:09,666
可能有多个设备共享这个中断号

800
00:27:10,000 --> 00:27:11,600
所以说就是一个外循环

801
00:27:11,766 --> 00:27:12,699
外循环干嘛呢

802
00:27:12,700 --> 00:27:15,266
外循环就执行这个中断源所

803
00:27:15,466 --> 00:27:16,533
这个中断号所

804
00:27:16,533 --> 00:27:18,933
对应的所有中断源的中断处理程序

805
00:27:19,200 --> 00:27:20,666
每一次你看针对一个

806
00:27:20,666 --> 00:27:22,166
大家看啊这就是一个便利吗

807
00:27:22,166 --> 00:27:22,399
对吧

808
00:27:22,400 --> 00:27:25,500
便利这个便利这个这个这个列表

809
00:27:25,733 --> 00:27:27,699
每一次都从这个里取出这个

810
00:27:27,700 --> 00:27:29,000
从这个form里取出这个

811
00:27:29,000 --> 00:27:30,366
回到函数看到了吧

812
00:27:30,500 --> 00:27:32,100
然后又分成有餐和无餐

813
00:27:32,100 --> 00:27:34,333
如果无餐的话就直接运行

814
00:27:35,300 --> 00:27:36,566
啊如果我看一下啊

815
00:27:36,566 --> 00:27:38,999
如果方程不等于空的话看到了吧

816
00:27:39,333 --> 00:27:41,766
如果方程不等于空啊

817
00:27:41,766 --> 00:27:43,266
如果方程不等于空

818
00:27:43,566 --> 00:27:45,933
那么就然后怎么样就开始

819
00:27:46,400 --> 00:27:47,500
把这个参数调用过来啊

820
00:27:47,500 --> 00:27:49,600
啊这个地方如果有参啊

821
00:27:49,600 --> 00:27:52,066
如果这个foxin有参的话

822
00:27:52,066 --> 00:27:53,599
那怎么样我就取来foxin

823
00:27:53,600 --> 00:27:56,100
然后把参数传递给他进行函数调用

824
00:27:56,266 --> 00:27:57,466
否则的话表示无参

825
00:27:57,466 --> 00:27:58,933
那我就直接调用foxin

826
00:27:58,933 --> 00:28:00,666
看到了直接调入foxin

827
00:28:00,900 --> 00:28:02,400
那么言外之意是什么意思

828
00:28:02,400 --> 00:28:03,066
言外之意是

829
00:28:03,066 --> 00:28:05,666
比如说一个中断号对应着两个中断

830
00:28:05,700 --> 00:28:06,266
处理程序

831
00:28:06,266 --> 00:28:08,133
那怎么样他就会执行这两个

832
00:28:08,133 --> 00:28:10,399
同时执行这两个中断处理程序

833
00:28:10,600 --> 00:28:12,066
但是啊但是

834
00:28:12,333 --> 00:28:13,666
尽管是两个中断处理程序

835
00:28:13,666 --> 00:28:15,866
在这个中断处理程序内部就会用什么

836
00:28:15,866 --> 00:28:18,499
就会判断是不是我这个中断源产生的

837
00:28:18,500 --> 00:28:20,900
这个是不是我这个中断号

838
00:28:20,900 --> 00:28:21,600
这个中断

839
00:28:21,600 --> 00:28:23,400
这个中断是不是我这个中能源产生的

840
00:28:23,400 --> 00:28:25,066
只有是我这个中能源产生的时候

841
00:28:25,066 --> 00:28:26,066
他才会继续执行

842
00:28:26,066 --> 00:28:28,533
否则的话他就会在这中途退出

843
00:28:28,533 --> 00:28:29,999
然后执行下一次循环

844
00:28:30,500 --> 00:28:31,700
是这么一个过程

845
00:28:32,300 --> 00:28:33,933
那么我们可以举一个例子啊

846
00:28:33,933 --> 00:28:35,199
就是两个键盘啊

847
00:28:35,200 --> 00:28:36,966
两个键盘同时连在一个

848
00:28:37,133 --> 00:28:39,566
连在一个这个计算机上啊

849
00:28:39,566 --> 00:28:42,066
我们在线下课程中给大家举这例子

850
00:28:42,766 --> 00:28:43,666
好以上呢

851
00:28:43,666 --> 00:28:46,099
就是这个中断处理过程的一个

852
00:28:46,100 --> 00:28:46,933
完整介绍

853
00:28:47,600 --> 00:28:48,400
谢谢大家

