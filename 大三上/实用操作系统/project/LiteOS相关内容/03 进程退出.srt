1
00:00:01,400 --> 00:00:02,533
各位同学大家好

2
00:00:02,533 --> 00:00:03,566
那我们现在呢

3
00:00:03,566 --> 00:00:05,366
介绍本章最后一个问题

4
00:00:05,366 --> 00:00:06,733
就是进程的回收

5
00:00:10,866 --> 00:00:13,466
那么如果要想回收一个进程的话

6
00:00:13,466 --> 00:00:15,899
首先我们要看一下进程的关系链

7
00:00:16,566 --> 00:00:18,499
进城是家族式管理的

8
00:00:18,500 --> 00:00:19,733
父子关系

9
00:00:19,733 --> 00:00:21,599
兄弟关系朋友关系子女关系

10
00:00:21,600 --> 00:00:22,933
甚至陌生人关系

11
00:00:23,600 --> 00:00:26,000
在一个进程的生命周期中呢

12
00:00:26,000 --> 00:00:27,133
都会记录下来

13
00:00:27,133 --> 00:00:28,333
用什么记录呢

14
00:00:28,366 --> 00:00:29,566
主要是依靠

15
00:00:29,933 --> 00:00:31,399
内核中重要的

16
00:00:31,566 --> 00:00:34,666
这个胶水结构体就是lost DL list

17
00:00:35,133 --> 00:00:36,333
进程控制块呢

18
00:00:36,500 --> 00:00:39,200
用了7个啊在这不是8个是7个啊

19
00:00:39,200 --> 00:00:40,466
双向列表来记录

20
00:00:40,666 --> 00:00:44,066
嗯进程家族的基因关系和运行关系

21
00:00:44,533 --> 00:00:46,899
那么为什么说起因为这个已经被

22
00:00:47,466 --> 00:00:49,566
已经已经被去掉了这个

23
00:00:49,900 --> 00:00:51,866
因为这个内核版本比较老所以

24
00:00:52,400 --> 00:00:54,700
那么我们分别看一下啊这7个关系

25
00:00:54,700 --> 00:00:55,900
首先是Panda list

26
00:00:55,900 --> 00:00:57,200
Panda list Panda list

27
00:00:57,200 --> 00:00:59,866
是鸿蒙内核中功能最多的一个列表

28
00:01:00,166 --> 00:01:01,966
它呢远不止字面上

29
00:01:02,766 --> 00:01:04,666
字面意思的主色列表那么简单

30
00:01:04,666 --> 00:01:06,866
因为我们把它挂到这个就绪列表中

31
00:01:06,866 --> 00:01:08,466
也也用这个panda list

32
00:01:08,766 --> 00:01:10,799
children list是孩子列表

33
00:01:11,133 --> 00:01:12,733
那么所有由

34
00:01:13,166 --> 00:01:14,999
他falk出来的进程呢

35
00:01:15,000 --> 00:01:16,466
都挂在这个列表上

36
00:01:16,700 --> 00:01:19,300
那么上面的孩子进程在死亡前

37
00:01:19,566 --> 00:01:20,999
会将自己从这个

38
00:01:21,600 --> 00:01:23,000
啊这个孩子进城呢

39
00:01:23,000 --> 00:01:23,733
在死亡前呢

40
00:01:23,733 --> 00:01:26,733
会将自己从这个children list中摘出去

41
00:01:26,733 --> 00:01:29,299
转而挂到exist child list上

42
00:01:30,066 --> 00:01:32,533
exist child list是退出海的列表

43
00:01:32,533 --> 00:01:35,299
进入死亡程序的这个进程

44
00:01:35,533 --> 00:01:36,866
要挂在这个列表上

45
00:01:36,866 --> 00:01:39,499
一个进程的死亡是件挺麻烦的事

46
00:01:39,733 --> 00:01:41,766
进程池的数量是有限的

47
00:01:41,800 --> 00:01:43,666
需要及时回收进程资源

48
00:01:43,666 --> 00:01:45,399
但家族管理关系复杂

49
00:01:46,000 --> 00:01:48,466
要去很多地方消除痕迹尤

50
00:01:48,466 --> 00:01:50,666
其呢还有其他进程啊

51
00:01:50,866 --> 00:01:52,266
还有其他进程等待

52
00:01:52,266 --> 00:01:53,966
等待这个紫禁城的消亡

53
00:01:53,966 --> 00:01:55,999
就是后面这张我们重这

54
00:01:56,066 --> 00:01:57,399
这节我们重要讲的就是这个

55
00:01:57,400 --> 00:01:58,866
wet和wet PID

56
00:01:59,200 --> 00:02:02,166
那么还要通知啊通知其他人一声啊

57
00:02:03,400 --> 00:02:05,666
那么sliving list是兄弟列表

58
00:02:05,866 --> 00:02:06,733
那么和你

59
00:02:06,733 --> 00:02:09,199
同一个父亲的进程都挂在这个列表上

60
00:02:09,266 --> 00:02:11,766
subordinate group list是朋友圈列表

61
00:02:11,766 --> 00:02:13,066
就是进程组列表

62
00:02:13,500 --> 00:02:14,500
那么里面呢

63
00:02:14,533 --> 00:02:16,566
是因为兴趣爱好啊

64
00:02:16,566 --> 00:02:18,466
相同而挂在一起的进程

65
00:02:18,666 --> 00:02:20,566
他们呢可以不是一个父亲

66
00:02:20,566 --> 00:02:21,933
也可以不是一个祖父

67
00:02:21,933 --> 00:02:23,799
但一定有一个老祖宗

68
00:02:23,800 --> 00:02:26,266
就是这个根或者啊内核态

69
00:02:26,266 --> 00:02:28,999
或者用用户态或内核态的这个根进程

70
00:02:29,366 --> 00:02:31,499
spread sliping list是线程列表

71
00:02:31,500 --> 00:02:33,366
上面挂的是进程ID

72
00:02:33,933 --> 00:02:36,299
都是这个进程的线程

73
00:02:36,300 --> 00:02:37,533
也就是说具有同

74
00:02:37,533 --> 00:02:39,466
因为一个进程下辖多个线程嘛

75
00:02:39,466 --> 00:02:40,466
所以说这个

76
00:02:40,600 --> 00:02:43,166
这些多线程都具有相同的任务ID啊

77
00:02:43,166 --> 00:02:45,666
进程ID那么这个列表挂的是进城

78
00:02:45,666 --> 00:02:46,599
和县城的关系

79
00:02:46,600 --> 00:02:48,800
是一比N1对多的关系

80
00:02:48,933 --> 00:02:50,933
一个县城只能属于一个进城

81
00:02:50,933 --> 00:02:52,199
那么这里呢要注意

82
00:02:52,200 --> 00:02:55,000
任务在其生命周期中是不能改变

83
00:02:55,500 --> 00:02:56,666
所属进城的

84
00:02:57,066 --> 00:02:59,199
那么第七是没有的已经被取消了啊

85
00:02:59,200 --> 00:03:01,766
wetlist这个是本本节讲的重点

86
00:03:01,766 --> 00:03:02,699
wetlist是什么呢

87
00:03:02,700 --> 00:03:03,966
是等待消亡

88
00:03:04,666 --> 00:03:06,766
啊是等待紫禁城消亡的任务列表

89
00:03:06,766 --> 00:03:09,466
就是说附近城生成了一个紫禁城

90
00:03:09,466 --> 00:03:10,366
然后调上weight

91
00:03:10,566 --> 00:03:12,666
那么就会等待紫禁城消亡

92
00:03:12,666 --> 00:03:14,166
他为什么等待紫禁城消亡呢

93
00:03:14,166 --> 00:03:16,266
就是因为紫禁城在退出的时候

94
00:03:16,266 --> 00:03:18,466
会首先释放自己所占有的所有资源

95
00:03:18,800 --> 00:03:20,766
啊比如说内存资源文件资源啊

96
00:03:20,766 --> 00:03:22,266
还有就是锁资源然

97
00:03:22,266 --> 00:03:24,699
后呢会把自己死亡的消息啊告

98
00:03:24,700 --> 00:03:25,733
那他现在是怎么样

99
00:03:25,733 --> 00:03:28,099
只除了PCB之外就没有其他资源

100
00:03:28,333 --> 00:03:29,966
没有资其不掌握其他资源

101
00:03:29,966 --> 00:03:32,699
我们管处于这种状态的进程叫做尊比

102
00:03:32,700 --> 00:03:34,700
就是说这个僵尸进程

103
00:03:34,966 --> 00:03:37,766
那么这时候呢这个这个他会怎么样呢

104
00:03:37,766 --> 00:03:39,866
这个处于尊卑状态的这个紫禁城

105
00:03:39,866 --> 00:03:41,399
会通知附近城说哎

106
00:03:41,400 --> 00:03:42,533
我我我现在

107
00:03:42,600 --> 00:03:43,666
我现在死亡了

108
00:03:43,666 --> 00:03:44,666
那你要怎么样呢

109
00:03:44,666 --> 00:03:48,099
你要给我把PCB啊PCB回收我的PCB

110
00:03:48,366 --> 00:03:50,466
所以那么他就会唤醒

111
00:03:50,566 --> 00:03:52,599
调用这个位特的附进程

112
00:03:53,266 --> 00:03:54,299
那么怎么唤醒呢

113
00:03:54,300 --> 00:03:55,266
我们后面会看到

114
00:03:55,266 --> 00:03:57,866
实质上附近城会被挂在什么呢

115
00:03:57,866 --> 00:03:59,399
就是附近城的主线城

116
00:03:59,466 --> 00:03:59,899
因为什么呢

117
00:03:59,900 --> 00:04:01,700
因为是附近城主线城调用这个位置

118
00:04:01,700 --> 00:04:02,566
系统调用的

119
00:04:02,666 --> 00:04:04,333
他会把自己这个TCB结构

120
00:04:04,333 --> 00:04:05,766
挂到这个附近城的

121
00:04:06,100 --> 00:04:07,400
这个wetlist指认里

122
00:04:07,466 --> 00:04:08,899
那么当紫禁城退出的时候

123
00:04:08,900 --> 00:04:09,733
他就会到

124
00:04:09,766 --> 00:04:12,066
这个附近程的wetlist里找

125
00:04:12,066 --> 00:04:13,099
有没有这样的task

126
00:04:13,100 --> 00:04:15,500
等待自己PID的这个TA task

127
00:04:15,600 --> 00:04:17,566
如果有那我就怎么样让

128
00:04:18,000 --> 00:04:18,900
让这个附近

129
00:04:18,900 --> 00:04:20,333
让这个这个主线城

130
00:04:20,333 --> 00:04:22,466
附近城的主线城开始运行

131
00:04:22,700 --> 00:04:25,100
然后这个附近城主线城就会怎么样呢

132
00:04:25,100 --> 00:04:27,500
继续执行然后回收紫金城的PCB

133
00:04:27,600 --> 00:04:28,933
它是这么样的一个过程

134
00:04:29,466 --> 00:04:30,266
那么

135
00:04:31,000 --> 00:04:32,133
这个喂他啊

136
00:04:32,133 --> 00:04:33,666
我们用户可以使用这个喂他

137
00:04:33,666 --> 00:04:34,699
一共有这么两种

138
00:04:34,866 --> 00:04:35,966
第一个就是这个喂他

139
00:04:35,966 --> 00:04:36,933
这个喂他表示什么意思呢

140
00:04:36,933 --> 00:04:38,966
这个喂他表示就是我等待啊

141
00:04:39,533 --> 00:04:41,899
任何一个紫禁城推出啊这是位的

142
00:04:41,900 --> 00:04:43,133
那这个位的Pad呢

143
00:04:43,133 --> 00:04:45,533
这个就是我等待一个特定紫禁城推出

144
00:04:45,533 --> 00:04:47,899
那我可以用这个Pad进行表示

145
00:04:47,933 --> 00:04:48,299
当然这个

146
00:04:48,300 --> 00:04:48,966
Pad后面

147
00:04:48,966 --> 00:04:51,199
我们会看到有很多复制类型啊

148
00:04:51,733 --> 00:04:54,099
那么当一个进程正常死亡的时候

149
00:04:54,100 --> 00:04:55,533
那么它就会调用这个函数

150
00:04:55,533 --> 00:04:57,966
叫做OS process natural exit

151
00:04:58,133 --> 00:04:59,666
啊process natural exit

152
00:04:59,733 --> 00:05:01,533
那这是什么叫做正常死亡呢

153
00:05:01,533 --> 00:05:03,999
一个进程死亡的话有两种情况

154
00:05:04,066 --> 00:05:05,966
第一种情况就是主线程退出

155
00:05:05,966 --> 00:05:07,299
就是面函数退出

156
00:05:07,366 --> 00:05:08,566
如果面函数退出的话

157
00:05:08,566 --> 00:05:11,533
那这个进程所有多线程都会被杀死

158
00:05:11,766 --> 00:05:13,899
那么这个主这个进程就退出了

159
00:05:13,900 --> 00:05:16,000
另外一种情况就是所有县城退出

160
00:05:16,000 --> 00:05:16,866
也就是说这个

161
00:05:16,900 --> 00:05:19,366
进程所属的所有县城都退出了

162
00:05:19,366 --> 00:05:21,066
那么这个进程也会退出

163
00:05:21,533 --> 00:05:22,766
那么这个进程退出呢

164
00:05:22,766 --> 00:05:24,266
主要包含这么几个步骤啊

165
00:05:24,266 --> 00:05:26,099
我们在这已经写写出来了啊

166
00:05:26,100 --> 00:05:27,400
首先是第一退群

167
00:05:27,700 --> 00:05:29,766
向兄弟姐妹啊告别

168
00:05:29,766 --> 00:05:31,366
也就是sliving lease的告别

169
00:05:31,400 --> 00:05:32,900
还有就是退出什么呢

170
00:05:32,900 --> 00:05:35,266
退出向朋友圈告别就是进程组告别

171
00:05:35,933 --> 00:05:38,699
啊subordinately group list你看这是一

172
00:05:38,766 --> 00:05:39,599
首先是什么

173
00:05:39,600 --> 00:05:42,400
把自己从这个附近城的啊

174
00:05:42,533 --> 00:05:43,766
附近城的这个

175
00:05:43,866 --> 00:05:44,799
这个列表中啊

176
00:05:44,800 --> 00:05:46,566
附近城所指的这个兄弟节点

177
00:05:46,566 --> 00:05:47,799
自己的这个兄弟节点

178
00:05:48,100 --> 00:05:49,000
兄弟节点啊

179
00:05:49,000 --> 00:05:51,100
兄弟姐妹这个列表中拿出来了

180
00:05:51,466 --> 00:05:52,199
还有是什么呢

181
00:05:52,200 --> 00:05:53,400
把自己从这个

182
00:05:53,466 --> 00:05:55,366
兄弟姐妹这个进程组中拿出来了

183
00:05:55,366 --> 00:05:56,166
看到了吧

184
00:05:56,533 --> 00:05:58,266
从进程组中拿出来了啊

185
00:05:58,600 --> 00:05:59,466
金属组织来了

186
00:05:59,500 --> 00:06:02,666
第二呢是告诉后人死亡原因啊

187
00:06:02,666 --> 00:06:04,899
告诉后人死亡原因也就是设置什么呢

188
00:06:04,900 --> 00:06:05,700
退出码

189
00:06:05,966 --> 00:06:08,766
啊设置推出码exit code那么什么意思呢

190
00:06:08,766 --> 00:06:11,399
就是附近城他他附近城

191
00:06:11,766 --> 00:06:13,066
根据这个啊

192
00:06:13,066 --> 00:06:15,966
附近城根据这个exit code来判断什么呢

193
00:06:15,966 --> 00:06:17,266
来判断他的死亡原因

194
00:06:17,266 --> 00:06:17,699
看到了吧

195
00:06:17,700 --> 00:06:19,400
因为wetlite上挂的任务呢

196
00:06:19,400 --> 00:06:20,766
等待他的死亡信息

197
00:06:21,400 --> 00:06:22,366
第三步是什么呢

198
00:06:22,366 --> 00:06:23,866
第三步啊就是这个

199
00:06:24,500 --> 00:06:25,300
嗯

200
00:06:25,700 --> 00:06:28,000
留下自己的死亡记录啊把自己

201
00:06:28,000 --> 00:06:29,566
你看紫禁城一旦退出

202
00:06:29,566 --> 00:06:31,366
他就会把自己挂在附近城的

203
00:06:31,366 --> 00:06:32,999
这个exit Chao的例子中

204
00:06:33,000 --> 00:06:34,300
把这个PCB啊

205
00:06:35,000 --> 00:06:36,766
然后第四件事情是什么呢

206
00:06:36,766 --> 00:06:38,666
第四件事情调用啊

207
00:06:38,666 --> 00:06:40,199
然后再再怎么样你看啊

208
00:06:40,200 --> 00:06:42,300
通过他他死亡了是不是

209
00:06:42,300 --> 00:06:43,933
你看第三步他死亡了

210
00:06:43,966 --> 00:06:45,099
他就要怎么样呢

211
00:06:45,100 --> 00:06:45,733
我看一下

212
00:06:45,733 --> 00:06:46,866
第三步他死亡了

213
00:06:46,866 --> 00:06:49,333
他就要怎么样把自己挂载到什么呢

214
00:06:49,333 --> 00:06:52,166
你看通过subordinate group list

215
00:06:53,000 --> 00:06:54,166
啊啊通过啊

216
00:06:54,166 --> 00:06:55,333
通过这个slabbing list

217
00:06:55,333 --> 00:06:56,599
把自己挂在这个

218
00:06:56,600 --> 00:06:58,766
附近城的exit child的list中

219
00:06:58,800 --> 00:06:59,366
看到了吧

220
00:06:59,366 --> 00:07:00,599
然后怎么样

221
00:07:00,800 --> 00:07:05,500
调用这个osweight check and week parent process啊

222
00:07:05,500 --> 00:07:07,166
唤醒唤醒

223
00:07:07,500 --> 00:07:10,366
等待这个紫禁城死亡的这个附近城

224
00:07:10,766 --> 00:07:12,399
的主线程父亲的主线程

225
00:07:12,500 --> 00:07:13,500
这个函数太重要了

226
00:07:13,500 --> 00:07:14,900
所以我们在这个地方就就

227
00:07:15,166 --> 00:07:18,366
就我们后面会会介重点介绍这个函数

228
00:07:18,500 --> 00:07:20,266
那么唤醒了之后干嘛呢

229
00:07:20,266 --> 00:07:22,066
唤醒了之后呢就是

230
00:07:22,700 --> 00:07:25,966
调用OS still alive child process啊

231
00:07:26,066 --> 00:07:26,999
调用这个函数

232
00:07:27,166 --> 00:07:28,566
那么这个函数干嘛呢

233
00:07:28,566 --> 00:07:30,366
就是向老祖宗托孤

234
00:07:30,800 --> 00:07:31,300
这是什么意思呢

235
00:07:31,300 --> 00:07:33,133
大家看我把我自己死亡了

236
00:07:33,133 --> 00:07:35,133
但是我我可能有紫禁城对吧

237
00:07:35,166 --> 00:07:36,699
我刚才说的是什么呢

238
00:07:36,700 --> 00:07:38,533
这个禁城所拥有的所有的任务

239
00:07:38,533 --> 00:07:40,299
紫紫禁城啊要退出

240
00:07:40,366 --> 00:07:41,333
但问题是这样

241
00:07:41,333 --> 00:07:43,099
这个他的紫禁城并不一定退出

242
00:07:43,100 --> 00:07:43,800
那怎么办呢

243
00:07:43,800 --> 00:07:45,866
他就把自己的所有的紫禁城啊

244
00:07:46,400 --> 00:07:47,300
托孤给谁呢

245
00:07:47,300 --> 00:07:48,566
托孤给这个

246
00:07:48,800 --> 00:07:51,600
就是以need进程或者是keep process进程

247
00:07:51,600 --> 00:07:52,966
后面我会看这个函数我们马

248
00:07:52,966 --> 00:07:54,266
上就会看到这个函数

249
00:07:54,466 --> 00:07:56,666
然后呢把自己标识成什么呢

250
00:07:56,800 --> 00:07:59,900
第五步就是把自己标识成僵尸进程

251
00:07:59,900 --> 00:08:00,733
尊卑状态

252
00:08:00,733 --> 00:08:01,533
尊卑状态

253
00:08:01,600 --> 00:08:02,666
然后呢

254
00:08:03,600 --> 00:08:05,366
啊然后第六步是什么呢

255
00:08:05,533 --> 00:08:08,799
啊那个就是告诉啊

256
00:08:08,800 --> 00:08:10,500
就是说这个我们看一下

257
00:08:10,500 --> 00:08:12,600
调用OSQ这个系统调用啊

258
00:08:12,600 --> 00:08:14,266
OSQ这个系统调用

259
00:08:14,533 --> 00:08:16,366
那么这个是什么呢

260
00:08:16,766 --> 00:08:18,466
就是附近城跑到

261
00:08:18,800 --> 00:08:20,000
呃就是啊

262
00:08:20,000 --> 00:08:22,300
向系统宣告紫禁城已经死亡啊

263
00:08:22,300 --> 00:08:24,500
向系统中宣告紫禁城已经死亡

264
00:08:25,133 --> 00:08:26,199
那么最后怎么样呢

265
00:08:26,200 --> 00:08:29,933
第七步是将自己挂入进程回收列表啊

266
00:08:29,933 --> 00:08:32,066
紫禁程已经挂入到回收列表了

267
00:08:32,066 --> 00:08:33,266
啊回收列表了

268
00:08:33,400 --> 00:08:34,566
那么然后呢

269
00:08:34,566 --> 00:08:36,466
这个为什么要挂到回收列表呢

270
00:08:36,466 --> 00:08:37,566
就是说啊

271
00:08:37,600 --> 00:08:38,466
这个是什么意思呢

272
00:08:38,466 --> 00:08:39,599
这个就是

273
00:08:40,333 --> 00:08:42,566
呃这个就是

274
00:08:42,766 --> 00:08:45,499
我们前面有一个existing那个标记对吧

275
00:08:45,500 --> 00:08:47,066
把那个因为什么

276
00:08:47,066 --> 00:08:47,733
因为我们知道

277
00:08:47,733 --> 00:08:50,799
整个这个鸿蒙系统至多只有64个进程

278
00:08:50,800 --> 00:08:52,366
那当一个紫进程退出的时候

279
00:08:52,366 --> 00:08:53,399
它就要怎么样呢

280
00:08:53,533 --> 00:08:55,899
他要把自己标志成existing

281
00:08:55,900 --> 00:08:56,966
标志成一个标

282
00:08:56,966 --> 00:09:00,166
标记existing然后挂载到这个recycle list里

283
00:09:00,266 --> 00:09:02,366
那么在操作系统在操作

284
00:09:02,366 --> 00:09:03,733
在鸿蒙操作系统启动的时候

285
00:09:03,733 --> 00:09:05,366
它会有一个就是

286
00:09:05,766 --> 00:09:07,999
就是会启动一个后台现成后台任务

287
00:09:08,000 --> 00:09:09,733
这个后台任务专门是什么呢

288
00:09:09,766 --> 00:09:12,199
负责回收这些处于existing

289
00:09:12,466 --> 00:09:13,966
existing状态的PCB啊

290
00:09:13,966 --> 00:09:15,333
所以它就是这样的啊

291
00:09:15,600 --> 00:09:17,100
啊然后呢

292
00:09:17,166 --> 00:09:19,366
然后调用这个第八个是

293
00:09:19,566 --> 00:09:20,999
呃调用这个函数啊

294
00:09:21,000 --> 00:09:22,600
调用这个函数删除啊

295
00:09:22,600 --> 00:09:24,700
这个正态运行的任务啊

296
00:09:25,200 --> 00:09:26,733
然后进行任务调度

297
00:09:26,866 --> 00:09:27,333
任务调度

298
00:09:27,333 --> 00:09:29,466
因为我一个进程退出了是不是

299
00:09:29,566 --> 00:09:30,133
那怎么的呀

300
00:09:30,133 --> 00:09:32,199
我唤醒了一个进程这个所谓唤醒实

301
00:09:32,200 --> 00:09:34,200
际上并没有让他运行他只是把这个

302
00:09:35,000 --> 00:09:36,566
啊把wait它的那个

303
00:09:37,066 --> 00:09:38,066
wait它那个

304
00:09:38,266 --> 00:09:40,166
任务怎么样放到就绪队列里了

305
00:09:40,166 --> 00:09:41,599
然后怎么样在这儿怎么样

306
00:09:41,666 --> 00:09:43,733
在这个地方怎么样要进行进行调度

307
00:09:43,733 --> 00:09:46,699
那我们下面首先看这个OS丢alive

308
00:09:46,700 --> 00:09:47,466
child process

309
00:09:47,466 --> 00:09:48,299
和这个OS run

310
00:09:48,300 --> 00:09:49,300
touch和DELETE

311
00:09:49,700 --> 00:09:52,000
然后呢再再然后看这个weight系统调用

312
00:09:52,000 --> 00:09:53,200
再讲weight系统调用的时候

313
00:09:53,200 --> 00:09:55,666
我们会结合这个weight tag and weight

314
00:09:55,900 --> 00:09:57,800
weight parent process来进行介绍

315
00:09:59,400 --> 00:10:01,733
好首先我们看一下孤儿进程

316
00:10:01,900 --> 00:10:02,900
什么叫孤儿进程

317
00:10:02,900 --> 00:10:03,900
一般情况下呢

318
00:10:03,900 --> 00:10:06,700
往往子进程的生命周期要短于父进程

319
00:10:07,133 --> 00:10:08,699
但因为fork之后呢

320
00:10:08,766 --> 00:10:10,499
进程之间相互独立啊

321
00:10:10,500 --> 00:10:12,066
调度算法一视同仁

322
00:10:12,333 --> 00:10:14,399
父子之间的是弱关系

323
00:10:14,500 --> 00:10:18,200
弱的弱的关系什么情况都可能发生

324
00:10:18,400 --> 00:10:20,666
内核是允许附近城先退出

325
00:10:20,666 --> 00:10:22,166
如果附近城退出

326
00:10:22,166 --> 00:10:24,866
而他的一个或多个紫禁城还在运行

327
00:10:25,000 --> 00:10:27,466
那么这些紫禁城就被称为孤儿禁城

328
00:10:27,800 --> 00:10:30,766
故而进城最终将被两位老祖宗

329
00:10:30,766 --> 00:10:33,499
也就是以匿的和keep process所收养

330
00:10:33,766 --> 00:10:35,799
那么并由老祖宗完成

331
00:10:35,800 --> 00:10:37,900
对他们的状态进行收益的工作

332
00:10:37,966 --> 00:10:39,533
所以大家看啊这个是什么意

333
00:10:39,533 --> 00:10:41,166
OSD alive child process

334
00:10:41,166 --> 00:10:41,933
你从这个名字上

335
00:10:41,933 --> 00:10:42,899
你就可以知道这是什么

336
00:10:42,900 --> 00:10:43,766
处理什么

337
00:10:44,166 --> 00:10:45,766
一个如果一个进程退出

338
00:10:45,766 --> 00:10:48,666
就要怎么样处理他这个进程的紫进程

339
00:10:48,666 --> 00:10:49,799
什么是上紫进程

340
00:10:49,800 --> 00:10:51,000
活着的紫进程

341
00:10:51,133 --> 00:10:51,866
那干嘛呢

342
00:10:51,866 --> 00:10:52,799
实际上就是啊

343
00:10:52,800 --> 00:10:54,300
你看首先是判断哎

344
00:10:54,300 --> 00:10:57,200
这个退出进程的child list有没有紫进程

345
00:10:57,566 --> 00:10:59,299
啊如果没还有紫禁城的话

346
00:10:59,300 --> 00:11:00,800
那我就便利这个紫禁城

347
00:11:01,066 --> 00:11:01,866
看到了便利紫

348
00:11:01,866 --> 00:11:03,299
禁城然后呢

349
00:11:03,300 --> 00:11:04,266
判断这个

350
00:11:04,266 --> 00:11:06,666
退出进程到底是用户态还是内核态

351
00:11:06,700 --> 00:11:08,100
那如果是用户态的话

352
00:11:08,100 --> 00:11:10,200
他就会把这个根据相应的情况

353
00:11:10,200 --> 00:11:12,266
你看派人的复制好派人他ID

354
00:11:12,266 --> 00:11:14,299
然后就会把这些紫禁城怎么样

355
00:11:14,900 --> 00:11:15,966
如果是用户态的话

356
00:11:15,966 --> 00:11:18,499
他就会把这些紫禁城插入到什么呢

357
00:11:18,600 --> 00:11:20,000
你看他就会把它插入到

358
00:11:20,000 --> 00:11:21,766
这个parent的child list里

359
00:11:21,800 --> 00:11:24,466
所以说啊所以说你看这地方是parent list

360
00:11:24,533 --> 00:11:26,099
所以说如果它是用户态的话

361
00:11:26,100 --> 00:11:28,166
它会它就会插入到以need的

362
00:11:28,166 --> 00:11:29,499
如果它要是parent的话

363
00:11:29,500 --> 00:11:30,866
它就会插到Chrono

364
00:11:30,900 --> 00:11:34,333
Chrono啊k parent k process的这个child list中

365
00:11:36,200 --> 00:11:39,600
那么下面我看一下这个OS task to delete

366
00:11:39,666 --> 00:11:42,499
run task to delete那么我们看一下啊

367
00:11:42,500 --> 00:11:43,700
它是干嘛呢

368
00:11:43,866 --> 00:11:46,266
它是啊它是删除掉什么呢

369
00:11:46,266 --> 00:11:47,899
这个进程的所有线程

370
00:11:48,133 --> 00:11:48,699
看到了吧

371
00:11:48,700 --> 00:11:49,933
把所有县城删除

372
00:11:50,000 --> 00:11:50,533
因为什么呢

373
00:11:50,533 --> 00:11:52,099
因为如果这个进程消亡的话

374
00:11:52,100 --> 00:11:53,900
那他的所有所有的任务

375
00:11:53,900 --> 00:11:55,966
他下辖的所有县城都会被干掉

376
00:11:56,100 --> 00:11:56,400
所以

377
00:11:56,400 --> 00:11:58,566
这个主要是删除这个进城所属的所

378
00:11:58,566 --> 00:11:59,133
有县城的

379
00:11:59,133 --> 00:11:59,733
看到了吧

380
00:11:59,733 --> 00:12:00,733
删除这个县城

381
00:12:00,900 --> 00:12:02,733
然后县城数减一看到了吧

382
00:12:02,733 --> 00:12:05,599
然后把这个删除的县城加到这个县城

383
00:12:05,600 --> 00:12:07,466
TCB的这个recycle里子里

384
00:12:07,666 --> 00:12:09,499
进程有recycle recycle list

385
00:12:09,500 --> 00:12:11,300
那县城也有recycle list啊

386
00:12:11,300 --> 00:12:13,733
然后呢写一个事件通知啊

387
00:12:14,300 --> 00:12:15,866
释放这个县城释放资源

388
00:12:15,900 --> 00:12:17,133
然后进行县城调度

389
00:12:17,766 --> 00:12:19,133
然后进行进行调动

390
00:12:19,333 --> 00:12:21,333
那下面呢进入我们讲的这个

391
00:12:21,333 --> 00:12:23,466
这这部分的最关键的一个性能调用

392
00:12:23,466 --> 00:12:25,366
这个性能调用就是胃的性能调用

393
00:12:25,933 --> 00:12:28,866
一个进程在终止时会关闭所有文

394
00:12:28,866 --> 00:12:32,266
件描述符释放在用户空间分配的内存

395
00:12:32,400 --> 00:12:35,900
但它的PCB还保留着内核在其保存

396
00:12:35,933 --> 00:12:37,733
在其中保存了一些信息

397
00:12:37,800 --> 00:12:40,400
如果是正常终止则保存的

398
00:12:40,733 --> 00:12:42,166
保存着退出状态

399
00:12:42,533 --> 00:12:43,766
如果是异常中止

400
00:12:43,766 --> 00:12:46,466
则保存着导致该进程中止的信号

401
00:12:46,466 --> 00:12:47,266
是哪个

402
00:12:48,133 --> 00:12:49,533
这个进程的附进程

403
00:12:49,533 --> 00:12:51,866
可以调用wait或wait PID等

404
00:12:52,300 --> 00:12:53,500
获取这些信息

405
00:12:53,500 --> 00:12:55,566
然后彻底删除掉这个进程

406
00:12:55,700 --> 00:12:57,333
如果一个进程已经终止

407
00:12:57,400 --> 00:12:57,766
但

408
00:12:57,766 --> 00:13:00,399
他的附进程尚未调用未的或未的PID

409
00:13:00,400 --> 00:13:01,200
对他进行清理

410
00:13:01,200 --> 00:13:02,900
那此时我们把这个

411
00:13:03,200 --> 00:13:05,666
这个紫进程所处的状态称为僵尸状态

412
00:13:05,766 --> 00:13:07,533
那么就是这这进程

413
00:13:07,933 --> 00:13:11,699
任何进城在刚终止时都是僵尸进城

414
00:13:11,900 --> 00:13:13,700
正常情况下僵尸进城呢

415
00:13:13,700 --> 00:13:16,000
都会立刻被附近城清理

416
00:13:16,200 --> 00:13:17,133
那不正常情况下

417
00:13:17,133 --> 00:13:19,299
我们就必须要通过task这个命令

418
00:13:19,300 --> 00:13:21,266
来检查系统中有哪些

419
00:13:21,266 --> 00:13:22,599
处于准备状态的

420
00:13:22,600 --> 00:13:23,933
线程啊进程

421
00:13:23,966 --> 00:13:25,733
然后用wait PID命令

422
00:13:25,733 --> 00:13:27,333
怎么样进行手工清理啊

423
00:13:27,333 --> 00:13:28,099
手工清理

424
00:13:28,100 --> 00:13:30,100
那么有两个wait调用

425
00:13:30,100 --> 00:13:31,600
一个是wait这个是调用

426
00:13:31,600 --> 00:13:33,100
这个wait要用是等待什么呢

427
00:13:33,100 --> 00:13:34,600
任何一个紫禁城退出

428
00:13:35,100 --> 00:13:36,533
那这个位的PID是什么呢

429
00:13:36,533 --> 00:13:38,166
这有个PID我们看一下

430
00:13:38,200 --> 00:13:39,700
那PID这个数据呢

431
00:13:39,700 --> 00:13:41,333
根据不同情况代表不同含义

432
00:13:41,333 --> 00:13:44,066
那pid大于0的时候就是啊等

433
00:13:44,666 --> 00:13:45,499
等待什么

434
00:13:45,500 --> 00:13:46,500
特定的PID

435
00:13:46,500 --> 00:13:48,466
为特定的紫禁城退出的时候

436
00:13:49,133 --> 00:13:50,733
那么如果PID等于-1的话

437
00:13:50,733 --> 00:13:51,599
那么就等待什么呢

438
00:13:51,600 --> 00:13:53,266
任何一个紫禁城退出

439
00:13:53,266 --> 00:13:55,099
它就和wet是一样的了啊

440
00:13:55,100 --> 00:13:56,700
如果你把这个PID称成-1

441
00:13:56,700 --> 00:13:58,533
它实际上就退化成wet了啊

442
00:13:59,066 --> 00:14:00,599
那么如果其实这个word

443
00:14:00,600 --> 00:14:02,533
就是对word PID的一个封装而已啊

444
00:14:02,533 --> 00:14:04,166
只不过它里头就是word PID

445
00:14:04,166 --> 00:14:05,899
这个PID的-1懂了

446
00:14:06,133 --> 00:14:08,799
然后如果PID是-1的话就怎么样呢

447
00:14:08,866 --> 00:14:10,733
如果是小于小于-1的

448
00:14:10,733 --> 00:14:11,999
那就是等待什么呢

449
00:14:12,000 --> 00:14:12,933
这个ID啊

450
00:14:12,933 --> 00:14:15,166
当然这个ID首要取决于值比如说-2

451
00:14:15,266 --> 00:14:18,199
那么就是说什么进程组ID为2的啊

452
00:14:18,200 --> 00:14:20,000
某一个绝对值为2啊

453
00:14:20,000 --> 00:14:20,866
绝对值是2

454
00:14:20,900 --> 00:14:23,466
那在这个进程组中这是进程组啊

455
00:14:23,500 --> 00:14:25,066
任何一个紫禁城退出啊

456
00:14:25,066 --> 00:14:26,466
我们后面会看到啊

457
00:14:27,366 --> 00:14:28,399
好你看

458
00:14:28,600 --> 00:14:30,333
那么为了PID啊

459
00:14:30,333 --> 00:14:32,533
在鸿蒙系统中一个进程结束了

460
00:14:32,533 --> 00:14:35,299
但是他的附进程没有等待他

461
00:14:35,333 --> 00:14:36,733
那么他就会啊

462
00:14:36,900 --> 00:14:39,533
他就会变成一个僵尸进程啊

463
00:14:39,566 --> 00:14:41,466
那么这就是僵尸进程啊

464
00:14:41,466 --> 00:14:42,266
僵尸进程

465
00:14:45,300 --> 00:14:46,333
啊降式进程

466
00:14:46,366 --> 00:14:48,599
那么通过系统调用wordpid

467
00:14:48,600 --> 00:14:50,666
可以彻底清除这个子进程

468
00:14:50,666 --> 00:14:53,366
归还PCB那么最终我们看到啊

469
00:14:53,366 --> 00:14:55,133
这个weight PID最终调用的是谁呢

470
00:14:55,133 --> 00:14:56,099
就是sys weight

471
00:14:56,100 --> 00:14:57,066
这个系统调用

472
00:14:57,066 --> 00:14:58,799
那调这个lose weight啊

473
00:14:58,800 --> 00:15:00,700
lose weight这个lose weight干嘛呢

474
00:15:00,733 --> 00:15:02,566
这个lose weight就是首先啊

475
00:15:02,566 --> 00:15:05,399
你看它调用了这个函数叫做OS

476
00:15:05,466 --> 00:15:08,566
你我们看一下这个process CB是什么呢

477
00:15:08,566 --> 00:15:10,566
这个process CB是

478
00:15:11,400 --> 00:15:13,066
这process CB是car

479
00:15:13,066 --> 00:15:14,666
你看通过Carn的process guide

480
00:15:14,666 --> 00:15:16,699
就是获取当前的进程

481
00:15:16,866 --> 00:15:18,599
然后再通过当前进程

482
00:15:18,600 --> 00:15:20,066
获取当前的任务啊

483
00:15:20,100 --> 00:15:21,166
获取当前的任务

484
00:15:21,300 --> 00:15:25,600
然后调用OS weight child process check啊

485
00:15:25,666 --> 00:15:28,533
那么OS weight child process check检查

486
00:15:28,966 --> 00:15:30,533
当等待的紫禁城PID

487
00:15:30,533 --> 00:15:32,499
是否已经出现在自己的

488
00:15:32,700 --> 00:15:34,133
PCB的退出列表

489
00:15:34,166 --> 00:15:35,899
exit chal的list中

490
00:15:36,000 --> 00:15:37,666
如果找到了

491
00:15:37,666 --> 00:15:39,566
在这个列表中找到了PCB啊

492
00:15:39,566 --> 00:15:41,499
那么那么我们这个

493
00:15:41,766 --> 00:15:43,266
那么我们这个chal的

494
00:15:43,300 --> 00:15:45,533
CB中就保存着是找到的这个

495
00:15:45,600 --> 00:15:46,566
找到的这个

496
00:15:47,200 --> 00:15:48,466
紫禁城的这个PCB

497
00:15:48,700 --> 00:15:50,933
那么这个就不为空啊不为空

498
00:15:50,933 --> 00:15:52,333
那大家看如果不为空的话

499
00:15:52,333 --> 00:15:53,566
那我就直接在这怎么样

500
00:15:53,566 --> 00:15:54,466
就不会wait了啊

501
00:15:54,466 --> 00:15:55,199
就不会wait了

502
00:15:55,200 --> 00:15:56,933
我就直接把它给回收掉了

503
00:15:56,933 --> 00:15:57,333
看到了吧

504
00:15:57,333 --> 00:15:58,999
如果child CB不为空

505
00:15:59,000 --> 00:16:01,800
则表示为它的紫禁城已经退出

506
00:16:01,800 --> 00:16:03,100
那么我们就调用这个

507
00:16:03,266 --> 00:16:05,999
OS weight recycle child process进行处理

508
00:16:06,666 --> 00:16:07,899
那么否则啊

509
00:16:07,900 --> 00:16:09,400
如果我刚才第一遍找

510
00:16:09,400 --> 00:16:10,766
查找的时候找不到

511
00:16:10,866 --> 00:16:12,766
那就表示如果运行到这里呢

512
00:16:12,766 --> 00:16:15,499
就表示等待的紫禁城不在啊

513
00:16:15,500 --> 00:16:18,000
现在还不在附近城的等待队列中

514
00:16:18,000 --> 00:16:21,666
于是怎么样又调用OS weight insert weight list

515
00:16:21,733 --> 00:16:24,566
用Audio函数将当前线程啊

516
00:16:24,566 --> 00:16:27,266
也就是说当前进程的主线程

517
00:16:27,800 --> 00:16:30,533
保存到附近成PCB的wait list中

518
00:16:30,666 --> 00:16:32,133
既挂起当前线程

519
00:16:32,400 --> 00:16:34,300
然后呢调用啊

520
00:16:34,300 --> 00:16:35,066
然后调用谁

521
00:16:35,066 --> 00:16:36,899
然后调用这个OS guide you

522
00:16:37,366 --> 00:16:39,533
sky do re sky do函数进行调度

523
00:16:39,600 --> 00:16:41,333
因为我现在怎么样主线成挂起了

524
00:16:41,333 --> 00:16:42,399
我要进行调度

525
00:16:42,600 --> 00:16:44,200
那么当继续执行时

526
00:16:44,333 --> 00:16:46,966
也就是说当啊这个如果哎

527
00:16:46,966 --> 00:16:48,099
如果再继续往下

528
00:16:48,100 --> 00:16:49,733
你看现在进进进行调度了

529
00:16:49,733 --> 00:16:51,466
现在这些代码都没有执行

530
00:16:51,500 --> 00:16:52,300
那当

531
00:16:52,800 --> 00:16:54,166
当这个当这个

532
00:16:54,166 --> 00:16:55,133
就这个wait

533
00:16:55,133 --> 00:16:56,999
到调用wait性调这个主任务啊

534
00:16:57,000 --> 00:16:58,500
这个主线程被唤醒的时候

535
00:16:58,500 --> 00:17:00,133
就从这个地方开始继续运行

536
00:17:00,133 --> 00:17:02,699
对吧那么所以当继续运行时

537
00:17:02,700 --> 00:17:05,766
一定是等待的紫线紫禁城已经退出

538
00:17:05,933 --> 00:17:07,166
那么我们还记得

539
00:17:07,400 --> 00:17:09,300
同学们还是否还记得这个OS

540
00:17:09,300 --> 00:17:10,400
process natural exit

541
00:17:10,400 --> 00:17:11,200
的这个函数

542
00:17:11,400 --> 00:17:11,733
那么

543
00:17:11,733 --> 00:17:14,166
在这个函数里调用了这个OS weight check and

544
00:17:14,166 --> 00:17:16,566
wake parent process这个函数吗

545
00:17:16,600 --> 00:17:19,766
那么当一个线程退出时就会调用啊

546
00:17:20,200 --> 00:17:22,666
啊当一个进程啊当一个进程退出时啊

547
00:17:22,666 --> 00:17:26,533
就会调用这个函数啊来唤醒PCB啊

548
00:17:26,533 --> 00:17:28,733
这个位置就是这个进程紫进程的

549
00:17:28,733 --> 00:17:29,266
复进程的

550
00:17:29,266 --> 00:17:32,166
PCB的就会检查呀这个紫进程

551
00:17:32,166 --> 00:17:33,599
这个退出的紫进程的

552
00:17:33,600 --> 00:17:35,300
复进程的PCB的wetlite

553
00:17:35,533 --> 00:17:37,799
有没有线程在等待着它

554
00:17:37,866 --> 00:17:38,799
主线程等待着它

555
00:17:38,800 --> 00:17:39,533
如果有

556
00:17:39,533 --> 00:17:42,733
那么怎么样它就会啊唤醒这个线程

557
00:17:43,000 --> 00:17:43,766
换成主线程

558
00:17:43,766 --> 00:17:45,766
然后才从这个位置继续运行

559
00:17:45,900 --> 00:17:47,400
那后面就很好理解了啊

560
00:17:47,400 --> 00:17:48,100
那么

561
00:17:48,100 --> 00:17:49,966
这个主线程一被一旦被唤醒干嘛呢

562
00:17:49,966 --> 00:17:52,499
就是调用这个OS wait recycle child process

563
00:17:52,500 --> 00:17:53,000
这个函数

564
00:17:53,000 --> 00:17:54,666
把这个紫禁城的

565
00:17:55,200 --> 00:17:58,066
刚刚退出这个紫禁城的child PCB给

566
00:17:58,400 --> 00:17:59,466
啊回收过来

567
00:17:59,866 --> 00:18:01,066
好我们来看一下啊

568
00:18:01,066 --> 00:18:02,066
下面我们来看啥呢

569
00:18:02,066 --> 00:18:03,566
我们就来看一下这个函数啊

570
00:18:03,566 --> 00:18:06,199
叫做OS weight child process check

571
00:18:06,466 --> 00:18:08,066
那刚才我们说了这个函数干嘛呢

572
00:18:08,066 --> 00:18:09,866
这个函数实际上是检查什么

573
00:18:09,966 --> 00:18:13,066
检查当前进程的weight啊

574
00:18:13,066 --> 00:18:14,933
检查当前进程的exit

575
00:18:15,000 --> 00:18:17,700
exit child list中是否有什么

576
00:18:17,700 --> 00:18:21,333
是否有wait wait的这个wait这个函数

577
00:18:21,866 --> 00:18:23,566
啊被wait这个PID的PCB

578
00:18:23,666 --> 00:18:24,266
如果有的话

579
00:18:24,266 --> 00:18:26,866
我就把它返保存到这个Chald CB里

580
00:18:26,966 --> 00:18:27,866
好我们看一下啊

581
00:18:27,866 --> 00:18:30,799
首先我们看一下这个process CB Chald list

582
00:18:31,266 --> 00:18:33,733
和exit child例子为不为空啊

583
00:18:33,733 --> 00:18:35,333
如果为空的话就返回错误

584
00:18:35,366 --> 00:18:35,999
然后调用这

585
00:18:36,000 --> 00:18:36,866
个看到了吧

586
00:18:36,866 --> 00:18:37,733
那这个是干嘛呢

587
00:18:37,733 --> 00:18:39,199
这个你看啊这个是干嘛呢

588
00:18:39,200 --> 00:18:41,466
你看首先是你通过这个名字上

589
00:18:41,466 --> 00:18:42,366
你就可以知道

590
00:18:42,366 --> 00:18:44,899
在这个PCB的exit child

591
00:18:44,900 --> 00:18:47,733
exit child例子中找这个PID啊

592
00:18:47,733 --> 00:18:48,533
如果能找到

593
00:18:48,533 --> 00:18:50,266
那process CB如果不等于空的话

594
00:18:50,266 --> 00:18:51,133
那就怎么样

595
00:18:51,133 --> 00:18:53,766
就执行返回成功了我就找到了对不对

596
00:18:53,800 --> 00:18:55,366
我就找到了就返回成功

597
00:18:55,600 --> 00:18:57,666
如果他没有的话那没有怎么办

598
00:18:57,666 --> 00:18:59,366
那你看我现在等待的这个

599
00:18:59,366 --> 00:19:00,299
这个PID是什么

600
00:19:00,300 --> 00:19:01,700
这个PID就是我等待的

601
00:19:01,700 --> 00:19:03,000
等待退出的紫禁城

602
00:19:03,066 --> 00:19:04,366
那我就把这个PID

603
00:19:04,366 --> 00:19:06,666
设置到了这个run task的wet PID

604
00:19:06,666 --> 00:19:07,533
这个非常重要啊

605
00:19:07,533 --> 00:19:07,966
这个非常

606
00:19:07,966 --> 00:19:08,866
为什么非常重要呢

607
00:19:08,866 --> 00:19:10,133
因为当

608
00:19:10,900 --> 00:19:12,700
我等待的那个紫禁城退出的时候

609
00:19:12,700 --> 00:19:15,333
他会调用这个OS process natural exit

610
00:19:15,400 --> 00:19:18,733
然后进而调用osweight check and Wig parent一个

611
00:19:18,933 --> 00:19:20,366
呃parent process

612
00:19:20,600 --> 00:19:24,100
进而调用osweight Wig specific process

613
00:19:24,100 --> 00:19:27,166
那在这个prosweight specific process里

614
00:19:27,166 --> 00:19:28,199
就会检查

615
00:19:28,766 --> 00:19:31,733
啊附近程的wait list里的每一个wait

616
00:19:32,000 --> 00:19:33,566
每一个TCB有没有

617
00:19:33,700 --> 00:19:35,466
每个TCB的这个wait p i d

618
00:19:35,466 --> 00:19:36,466
等不等于这个p i d

619
00:19:36,466 --> 00:19:38,133
如果等于那他就找到了

620
00:19:38,133 --> 00:19:38,966
就唤醒他

621
00:19:39,200 --> 00:19:40,000
啊

622
00:19:40,466 --> 00:19:41,933
好那么我们继续来看啊

623
00:19:41,933 --> 00:19:43,399
我们继续来看那现在是什么呢

624
00:19:43,400 --> 00:19:43,866
我把

625
00:19:43,866 --> 00:19:46,399
我我是如果要是我要是没有找到的话

626
00:19:46,400 --> 00:19:47,800
我这把PID记住啊

627
00:19:47,800 --> 00:19:50,300
PID记住然后呢根据这个PID的值

628
00:19:50,366 --> 00:19:51,999
我就把它放到这个就绪

629
00:19:52,000 --> 00:19:52,800
就是这个

630
00:19:53,066 --> 00:19:53,866
哪呢

631
00:19:54,900 --> 00:19:55,700
啊

632
00:19:56,300 --> 00:19:58,966
等待任意的紫禁城等待任意紫禁城

633
00:19:59,133 --> 00:20:00,199
如果找到的话呢

634
00:20:00,200 --> 00:20:02,000
你看啊如果找到的话呢

635
00:20:02,000 --> 00:20:03,133
我就直接啊怎么

636
00:20:03,133 --> 00:20:04,966
样未跳转到这wait back

637
00:20:05,066 --> 00:20:06,766
跳转到w wait back然后就直接退出了

638
00:20:06,766 --> 00:20:08,399
你看设置了设置好了

639
00:20:08,400 --> 00:20:09,933
那如果没有找到啊

640
00:20:09,933 --> 00:20:11,166
没有找到那怎么办呢

641
00:20:11,166 --> 00:20:12,566
那我就要怎么样呢

642
00:20:12,866 --> 00:20:15,166
根据不同情况来进行处理了啊

643
00:20:15,300 --> 00:20:17,333
根据不同的情况来进行处理了

644
00:20:17,566 --> 00:20:19,366
那么比如说啊比如说

645
00:20:19,700 --> 00:20:23,066
我们看一下啊如果PID我看一下啊

646
00:20:23,266 --> 00:20:24,066
我看一下

647
00:20:25,333 --> 00:20:25,666
啊啊

648
00:20:25,666 --> 00:20:27,199
这个是这样啊这个是这样啊

649
00:20:27,200 --> 00:20:28,300
如果pid大于0

650
00:20:28,300 --> 00:20:30,133
我们在这只说如果pid大于0

651
00:20:30,133 --> 00:20:31,766
那我们想一想啊

652
00:20:31,800 --> 00:20:33,400
如果pid大于0表示什么意思呢

653
00:20:33,400 --> 00:20:34,200
pid大于0

654
00:20:34,200 --> 00:20:36,666
表示的是它等待的是某一个什么

655
00:20:36,966 --> 00:20:38,333
他等待的是某一个进程

656
00:20:38,333 --> 00:20:40,566
那首首先我要在这个exit

657
00:20:40,766 --> 00:20:43,333
exit Chao的例子中找他有没有出现

658
00:20:43,400 --> 00:20:45,266
如果出现了我就直接退出啊

659
00:20:45,266 --> 00:20:45,866
我就直接退

660
00:20:45,866 --> 00:20:46,899
如果没有出现的话

661
00:20:46,900 --> 00:20:48,733
我我就把这个PID付给他

662
00:20:48,900 --> 00:20:51,533
然后然后撤离啊然后撤离

663
00:20:51,700 --> 00:20:54,333
那如果PID等于-1的话表示什么意思呢

664
00:20:54,333 --> 00:20:56,466
表示的是我要找的是一个进程组

665
00:20:56,700 --> 00:20:58,066
对吧找的是个进程组

666
00:20:58,133 --> 00:20:59,199
那么在这个地方呢

667
00:20:59,200 --> 00:21:00,966
就是我要找这个进程

668
00:21:01,066 --> 00:21:02,099
我要找啊

669
00:21:02,133 --> 00:21:03,399
如果PA等于-1的话

670
00:21:03,400 --> 00:21:04,500
我就找这个进程组中

671
00:21:04,500 --> 00:21:06,333
这个是这个进程组是什么

672
00:21:06,333 --> 00:21:08,799
这个进程组中是否有任何一个进程

673
00:21:08,900 --> 00:21:11,400
退出了是否有任何一个进程退出

674
00:21:11,533 --> 00:21:12,799
那么如果要是

675
00:21:13,266 --> 00:21:14,566
有任何一个进程退出的话

676
00:21:14,566 --> 00:21:16,599
那我PI差不不不为空的话

677
00:21:16,600 --> 00:21:17,466
我就直接退出

678
00:21:17,866 --> 00:21:18,366
直接退出

679
00:21:18,366 --> 00:21:19,066
否则的话呢

680
00:21:19,066 --> 00:21:21,599
我就把这个进程组的ID记录记录起来

681
00:21:21,600 --> 00:21:22,400
看到了吧

682
00:21:22,400 --> 00:21:25,066
啊然后呢这个l是什么意思呢

683
00:21:25,066 --> 00:21:26,066
l就是

684
00:21:26,966 --> 00:21:28,599
啊不不不PID等于-1啊

685
00:21:28,600 --> 00:21:29,266
PID等于-1

686
00:21:29,266 --> 00:21:30,899
表示就是等待任何一个进程啊

687
00:21:30,900 --> 00:21:32,500
等待一任何一个人我说错了

688
00:21:32,533 --> 00:21:33,666
等待任何一个进程

689
00:21:33,666 --> 00:21:34,499
那我就怎么样呢

690
00:21:34,500 --> 00:21:36,566
就是等待看有没有任何一个进程

691
00:21:36,666 --> 00:21:38,066
如果要是有任何一个进程的话

692
00:21:38,066 --> 00:21:39,699
我就怎么样设置好啊

693
00:21:39,733 --> 00:21:40,733
否则的话我就

694
00:21:41,266 --> 00:21:41,766
我就怎么样

695
00:21:41,766 --> 00:21:44,733
把这个PID等于-1设置成未的PID啊

696
00:21:44,800 --> 00:21:45,733
那么这个是什么意思呢

697
00:21:45,733 --> 00:21:46,299
这个是等

698
00:21:46,300 --> 00:21:48,500
这个才是等待某一个具体的进程组

699
00:21:48,500 --> 00:21:50,133
然后怎么样我找到这个进程组

700
00:21:50,133 --> 00:21:51,099
看到了找到进程组

701
00:21:51,100 --> 00:21:52,366
如果这个进程组为空的话

702
00:21:52,366 --> 00:21:53,333
我就返回错误

703
00:21:53,466 --> 00:21:55,066
否则的话我就怎么样呢

704
00:21:55,266 --> 00:21:55,966
我就看一下

705
00:21:55,966 --> 00:21:57,199
在这个进进程组里

706
00:21:57,200 --> 00:21:59,166
是不是有任何一个进程退出

707
00:21:59,166 --> 00:22:01,066
如果如果有进程退出的话

708
00:22:01,066 --> 00:22:03,666
那么我就直接把这个退出进程返回

709
00:22:03,700 --> 00:22:04,966
否则的话我把这个

710
00:22:05,100 --> 00:22:06,700
这个进程组的ID复复到

711
00:22:06,700 --> 00:22:07,800
复过来看到了吧

712
00:22:07,900 --> 00:22:10,100
那么然后这个位的p i d改成g ID

713
00:22:10,100 --> 00:22:11,100
看到了g ID

714
00:22:11,800 --> 00:22:12,800
这个是wait any

715
00:22:12,866 --> 00:22:14,799
表示等待任何一个进程退出

716
00:22:14,800 --> 00:22:17,066
这个是表示等待一个进程组退出

717
00:22:17,133 --> 00:22:18,566
那这个呢就表示Pro

718
00:22:18,566 --> 00:22:20,999
表示等待某一个具体的进程退出

719
00:22:21,066 --> 00:22:23,799
那这个后面有用啊后面有用好

720
00:22:24,000 --> 00:22:27,666
那这个就是说便利这个exit child list

721
00:22:27,700 --> 00:22:29,866
然后来看啊有没有退出的

722
00:22:31,000 --> 00:22:31,966
有没有退出的

723
00:22:32,066 --> 00:22:35,099
那你看如果啊我我这个

724
00:22:35,166 --> 00:22:36,966
我这个当前便利的

725
00:22:36,966 --> 00:22:39,399
这个exit child中的某一个节点

726
00:22:39,400 --> 00:22:41,500
和这个我等待的这个节点相同的话

727
00:22:41,500 --> 00:22:42,466
那就表示有

728
00:22:42,566 --> 00:22:43,266
我找到了

729
00:22:43,266 --> 00:22:45,166
我找到了我就把这个exit child返回

730
00:22:45,166 --> 00:22:46,699
否则的话话返回not

731
00:22:47,766 --> 00:22:48,566
那好那

732
00:22:48,566 --> 00:22:49,866
么像前面怎么样呢

733
00:22:49,866 --> 00:22:50,666
前面是这样的

734
00:22:50,666 --> 00:22:51,666
就是说我没找到

735
00:22:51,666 --> 00:22:53,599
假设我没找到这个进程啊

736
00:22:53,600 --> 00:22:54,500
我没找到

737
00:22:54,866 --> 00:22:56,533
等待的这个wet的这个紫禁城

738
00:22:56,533 --> 00:22:59,166
那怎么我就要把当前的进程的主任务

739
00:22:59,166 --> 00:23:01,399
主主线程插入到这个wetlist中

740
00:23:01,500 --> 00:23:04,566
所以你看process CB啊这个head是什么呢

741
00:23:04,566 --> 00:23:07,399
就是这个当前进程的这个wetlist wetlet

742
00:23:07,533 --> 00:23:09,799
我要做的就是把这个task

743
00:23:09,900 --> 00:23:12,533
插入到这个当前进程的wetlist中

744
00:23:13,266 --> 00:23:14,333
啊那怎么查呢

745
00:23:14,400 --> 00:23:16,266
那我刚才说了我们刚才呢

746
00:23:16,266 --> 00:23:16,899
在这个踏

747
00:23:16,900 --> 00:23:18,533
我们刚才执行这个函数的时候

748
00:23:18,533 --> 00:23:19,699
执行这个函数的时候

749
00:23:20,100 --> 00:23:21,000
对这个task怎么样

750
00:23:21,000 --> 00:23:23,366
你看对这个run task设置了不同的情况

751
00:23:23,366 --> 00:23:25,899
你看run task这个flag要么等于Pro

752
00:23:26,200 --> 00:23:27,566
要么等于什么呢

753
00:23:27,566 --> 00:23:29,099
要么等于这个any

754
00:23:29,266 --> 00:23:30,333
要么等于什么呢

755
00:23:30,333 --> 00:23:31,566
等于GID看到了吧

756
00:23:31,566 --> 00:23:33,099
那好那我就根据什么呢

757
00:23:33,100 --> 00:23:33,666
这个你看

758
00:23:33,666 --> 00:23:37,599
如果啊这个weight flag是group的话

759
00:23:37,900 --> 00:23:39,333
啊那么如果他是gloup的话

760
00:23:39,333 --> 00:23:41,366
那我们知道啊gloup怎么样呢

761
00:23:41,366 --> 00:23:42,966
gloup会被插到什么呢

762
00:23:42,966 --> 00:23:43,866
他按照什么呢

763
00:23:43,866 --> 00:23:45,133
他按照Pro在前

764
00:23:45,500 --> 00:23:46,366
gid在中间

765
00:23:46,366 --> 00:23:47,199
any在最后的

766
00:23:47,200 --> 00:23:49,133
这种方式来组织这个wetlist

767
00:23:49,266 --> 00:23:50,499
那么到底怎么组织呢

768
00:23:50,500 --> 00:23:51,666
我们在线下的课程中

769
00:23:51,666 --> 00:23:53,399
会给大家再详细的来介绍

770
00:23:53,700 --> 00:23:54,733
那么把这个

771
00:23:54,733 --> 00:23:57,699
把这个task插入到这个附进程的wetlist

772
00:23:57,700 --> 00:23:58,333
这个列表里

773
00:23:58,333 --> 00:23:59,599
之后呢怎么样

774
00:23:59,666 --> 00:24:01,066
然后调用什么呢

775
00:24:01,066 --> 00:24:02,566
wet函数wet函数

776
00:24:02,566 --> 00:24:04,333
那这个wet函数里头会怎么样

777
00:24:04,333 --> 00:24:06,599
这个wet函数就会把这个当前进程

778
00:24:06,600 --> 00:24:09,100
怎么样插入到什么wet列表里啊

779
00:24:09,400 --> 00:24:10,533
插入到wait列表里

780
00:24:10,533 --> 00:24:12,699
那这个我们后面再讲任务的时候

781
00:24:12,700 --> 00:24:13,800
会详细来介绍

782
00:24:15,166 --> 00:24:17,166
好那么这个然后怎么样

783
00:24:17,166 --> 00:24:19,733
当前进程就就开始处于睡眠态了

784
00:24:19,733 --> 00:24:20,566
睡眠态了

785
00:24:20,733 --> 00:24:21,666
睡眠态干嘛呢

786
00:24:21,666 --> 00:24:23,266
睡眠态我们再回过头来你看

787
00:24:23,500 --> 00:24:25,533
插入完了之后怎么样进行进程调度

788
00:24:25,766 --> 00:24:26,899
啊进行精神调度

789
00:24:26,933 --> 00:24:29,166
那好那现在我们完成了之后呢

790
00:24:29,300 --> 00:24:30,200
那这个函数是什么

791
00:24:30,200 --> 00:24:31,800
这个函数就是natural exit

792
00:24:31,800 --> 00:24:33,333
那个函数调用的就在这

793
00:24:34,366 --> 00:24:35,766
这个natural process

794
00:24:35,766 --> 00:24:37,099
natural exist这个函数

795
00:24:37,166 --> 00:24:38,866
当某一个进程退出的时候

796
00:24:38,866 --> 00:24:40,333
它会调用这个OS weight

797
00:24:40,466 --> 00:24:42,466
check and vague parent process

798
00:24:42,466 --> 00:24:43,133
看到了吧

799
00:24:43,133 --> 00:24:44,199
那好我们看一下

800
00:24:44,300 --> 00:24:46,866
那么这两个函数一个是啊这个

801
00:24:47,500 --> 00:24:49,900
退出进程的复进程一个是什么

802
00:24:50,100 --> 00:24:51,600
退出进程这个是退出进程

803
00:24:51,600 --> 00:24:52,900
这是退出进程的复进程

804
00:24:52,966 --> 00:24:54,099
那我们知道啊

805
00:24:54,133 --> 00:24:56,533
那么我们知道如果一个进程退出

806
00:24:56,533 --> 00:24:58,766
那么他的复进程中的维特利斯中

807
00:24:58,766 --> 00:25:00,666
挂载着你看我们刚才不说了吗

808
00:25:00,666 --> 00:25:03,366
这个task被挂载着这个维特利斯里

809
00:25:03,366 --> 00:25:05,499
所以这个等待这个复进程

810
00:25:05,733 --> 00:25:07,399
等待这个紫禁城退出的这个任务

811
00:25:07,400 --> 00:25:09,466
就是保存在这个wait list中

812
00:25:09,533 --> 00:25:10,999
好那首先判断啊

813
00:25:11,000 --> 00:25:12,900
判断一下这个wait list为为空

814
00:25:12,900 --> 00:25:15,400
如果为空的话那就那就退出了对吧

815
00:25:15,733 --> 00:25:17,366
如果不围空的话怎么样呢

816
00:25:17,366 --> 00:25:19,299
那他就拿着这个紫禁城的ID

817
00:25:19,300 --> 00:25:22,066
到这个附近城的wait list中去挨个去找

818
00:25:22,066 --> 00:25:22,699
看到了吧

819
00:25:22,700 --> 00:25:23,700
那附近城

820
00:25:23,700 --> 00:25:26,600
在附近城的parent CB的wait list中

821
00:25:26,600 --> 00:25:28,866
去查找等待紫禁城的PCB任务

822
00:25:29,066 --> 00:25:31,499
如果找到的话就将指针啊指

823
00:25:31,533 --> 00:25:33,999
就将指针的保存在这个例子中啊

824
00:25:34,000 --> 00:25:35,966
同时将find specific指

825
00:25:35,966 --> 00:25:37,166
成处看到了吧

826
00:25:37,266 --> 00:25:39,799
好在这如果find specific呢

827
00:25:40,366 --> 00:25:41,299
啊不等于处

828
00:25:41,300 --> 00:25:42,733
那么就进行相应的处理

829
00:25:42,733 --> 00:25:44,066
那我们不看这个东西啊

830
00:25:44,066 --> 00:25:44,799
我们看这个

831
00:25:44,800 --> 00:25:46,700
如果find the specific等于处的话

832
00:25:46,700 --> 00:25:47,366
那表示什么呢

833
00:25:47,366 --> 00:25:48,933
就表示在附近城中

834
00:25:48,933 --> 00:25:50,599
有一个附近城的主线城

835
00:25:50,600 --> 00:25:52,600
在等待着子线城的退出

836
00:25:52,800 --> 00:25:53,866
那怎么办呢

837
00:25:53,866 --> 00:25:54,566
那怎么办呢

838
00:25:54,566 --> 00:25:56,566
那好那么就怎么样

839
00:25:57,100 --> 00:26:00,300
那么就要调用这个OS weight weight

840
00:26:00,933 --> 00:26:03,266
啊weight weight task来唤醒这个

841
00:26:03,266 --> 00:26:04,366
什么来唤醒这个

842
00:26:05,200 --> 00:26:06,600
来唤醒等待这个

843
00:26:06,866 --> 00:26:09,933
退出任务的这个退出紫禁城的任务啊

844
00:26:09,966 --> 00:26:11,899
那我们看看一下

845
00:26:12,100 --> 00:26:14,200
首先我们看一下这个OS weight

846
00:26:14,466 --> 00:26:16,299
weak specific process

847
00:26:16,300 --> 00:26:17,900
那你看它这个实际上是什么

848
00:26:17,900 --> 00:26:18,666
我们再看一下

849
00:26:18,666 --> 00:26:20,899
这个head是附近程的wetlist

850
00:26:20,966 --> 00:26:22,066
wetlist列表

851
00:26:22,333 --> 00:26:23,666
这个呢是这个

852
00:26:23,966 --> 00:26:25,499
这个是这个就是

853
00:26:25,966 --> 00:26:28,933
死亡的死亡的这个死亡的紫禁城

854
00:26:29,166 --> 00:26:30,333
死亡的紫禁城那干嘛呢

855
00:26:30,333 --> 00:26:31,766
你看他就在这个

856
00:26:31,766 --> 00:26:33,466
你看他把这个付给这个list

857
00:26:33,466 --> 00:26:34,999
然后在这个list中去找

858
00:26:35,166 --> 00:26:36,466
如果这个啊

859
00:26:36,466 --> 00:26:37,399
如果这个

860
00:26:37,733 --> 00:26:39,466
任务的wet的这个

861
00:26:39,500 --> 00:26:42,200
wet的这个ID号和这个这个号相同

862
00:26:42,300 --> 00:26:43,800
那你看这个wet ID在哪设置的

863
00:26:43,800 --> 00:26:44,900
是不是在这设置的

864
00:26:45,766 --> 00:26:46,599
啊是不在这设

865
00:26:46,600 --> 00:26:49,066
你看把这个p i d设置这个wet wet ID了

866
00:26:49,066 --> 00:26:51,066
看到了吧wet ID好

867
00:26:51,266 --> 00:26:53,299
那么如果是在这找到了的话

868
00:26:53,300 --> 00:26:54,666
那范的就等于处对吧

869
00:26:54,666 --> 00:26:56,499
范的等于处那么就返回不回来了

870
00:26:56,500 --> 00:26:57,300
看到了吧

871
00:26:58,000 --> 00:26:58,500
返回回来

872
00:26:58,500 --> 00:27:01,066
你看这个地方找到了那spice返回处

873
00:27:01,066 --> 00:27:03,299
那么这个find specific等于处

874
00:27:03,666 --> 00:27:04,999
find spicific等于处

875
00:27:05,100 --> 00:27:07,933
那在这个地方呢就是OS weight Wig

876
00:27:07,933 --> 00:27:10,133
task那么就会怎么样呢

877
00:27:10,133 --> 00:27:13,099
就会把这个啊你看我因为我找到了

878
00:27:13,100 --> 00:27:14,300
我找到之后呢

879
00:27:14,300 --> 00:27:15,500
我就把这个怎么样

880
00:27:15,500 --> 00:27:17,166
我就把这个任务怎么唤醒

881
00:27:17,333 --> 00:27:18,133
唤醒

882
00:27:18,533 --> 00:27:22,866
好那么整个的这个就是任务退出啊

883
00:27:22,866 --> 00:27:24,333
就给大家介绍到这里

