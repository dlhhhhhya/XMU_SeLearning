1
00:00:01,300 --> 00:00:02,933
各位同学大家好

2
00:00:03,300 --> 00:00:05,133
本讲我们给大家介绍

3
00:00:05,366 --> 00:00:07,266
鸿蒙light OS的两个主题

4
00:00:07,266 --> 00:00:09,933
分别是系统调用与中断

5
00:00:11,100 --> 00:00:13,800
那么我们首先给大家介绍第一个主题

6
00:00:14,666 --> 00:00:15,533
系统调用

7
00:00:18,366 --> 00:00:20,099
那么首先我们看一下这张图

8
00:00:20,666 --> 00:00:21,899
那么这张图呢

9
00:00:21,900 --> 00:00:25,466
是啊light OS系统调用的整个工作过程

10
00:00:25,666 --> 00:00:28,166
那我们首先看在这个过程中

11
00:00:28,166 --> 00:00:29,966
首先是在应用层

12
00:00:30,200 --> 00:00:32,100
那么应用层中的应用程序

13
00:00:32,400 --> 00:00:34,600
通过调用lab c括函数

14
00:00:35,100 --> 00:00:36,966
啊来触发系统调用

15
00:00:37,866 --> 00:00:40,099
那么在AM处理器中

16
00:00:40,266 --> 00:00:42,599
系统调用的指令是SVC

17
00:00:43,566 --> 00:00:46,199
那么SVC的触发会导致

18
00:00:46,500 --> 00:00:49,800
内核态的一个叫做system cohandler的指

19
00:00:49,966 --> 00:00:51,099
函数来运行

20
00:00:51,333 --> 00:00:52,099
那么最终呢

21
00:00:52,100 --> 00:00:55,066
这个函数代替应用程序来访问

22
00:00:55,966 --> 00:00:57,766
Letos中的各种硬件

23
00:00:58,400 --> 00:01:00,533
那么整个呢它就是这样的一个

24
00:01:01,133 --> 00:01:01,999
工作流程

25
00:01:05,133 --> 00:01:07,366
那么以下呢我们可以更详细的

26
00:01:07,666 --> 00:01:09,599
来说明一下处理流程

27
00:01:09,600 --> 00:01:10,400
我们以

28
00:01:11,333 --> 00:01:12,266
一个名叫

29
00:01:12,866 --> 00:01:16,699
MQ open那么它是messageq open消息对列

30
00:01:16,733 --> 00:01:17,166
啊

31
00:01:17,166 --> 00:01:18,933
这个这样的一个括函数为例

32
00:01:19,000 --> 00:01:20,666
来给大家介绍一下啊

33
00:01:20,666 --> 00:01:22,966
它的这个系统调用的一个完整过程

34
00:01:23,300 --> 00:01:24,166
首先是

35
00:01:25,333 --> 00:01:27,733
在用户态下的maint main函数

36
00:01:27,966 --> 00:01:30,533
使用系统调用MQ open

37
00:01:31,366 --> 00:01:34,566
那么MQ open中调用SMS CO

38
00:01:35,100 --> 00:01:37,966
将参数传递给计存器R7

39
00:01:38,600 --> 00:01:39,966
R0到R6

40
00:01:39,966 --> 00:01:42,766
那么后面我们会知道R7保存的就是

41
00:01:43,066 --> 00:01:44,333
m q open这个系统

42
00:01:44,533 --> 00:01:45,566
m q open这个库

43
00:01:45,566 --> 00:01:47,566
函数所对应的系统调用的名称啊

44
00:01:47,566 --> 00:01:48,466
系统调用号

45
00:01:48,733 --> 00:01:51,466
那么R0到R6保存的是

46
00:01:51,866 --> 00:01:52,666
啊

47
00:01:52,766 --> 00:01:54,466
这个系统调用的参数

48
00:01:55,333 --> 00:01:56,933
那么以上这两个东西呢

49
00:01:56,933 --> 00:01:59,099
对应着我们上一张图的

50
00:01:59,266 --> 00:02:01,766
啊应用层的这个应用层部分

51
00:02:02,133 --> 00:02:02,933
应用层部分

52
00:02:04,766 --> 00:02:08,566
接着通过SVC0命令

53
00:02:08,800 --> 00:02:11,766
完成从用户态到内核态的切换

54
00:02:12,700 --> 00:02:14,200
那么完成切换之后呢

55
00:02:14,200 --> 00:02:15,666
那么SVC命令

56
00:02:16,200 --> 00:02:18,366
完成了SVC0这个命令之后呢

57
00:02:19,300 --> 00:02:20,300
系统状态

58
00:02:20,533 --> 00:02:22,466
或者说CPU状态就完成

59
00:02:22,466 --> 00:02:24,999
就从用户态切换到了内核态

60
00:02:25,166 --> 00:02:28,766
那么在内核态就会主动地触发软中断

61
00:02:29,000 --> 00:02:31,066
所对应的中断处理函数

62
00:02:31,100 --> 00:02:35,366
那么这个就这个叫做OS except SWI

63
00:02:36,066 --> 00:02:36,866
HDL

64
00:02:37,466 --> 00:02:40,499
那么SWI就是software interrupt软中断

65
00:02:40,800 --> 00:02:42,500
HDL就是Handoler的缩写

66
00:02:43,000 --> 00:02:45,400
那么这时候PC计算器指向

67
00:02:46,266 --> 00:02:50,466
就是OS accept s w i handle的取指令

68
00:02:50,600 --> 00:02:51,666
就是指向这个

69
00:02:51,666 --> 00:02:53,266
这个处理程序的第一条指令

70
00:02:53,866 --> 00:02:56,199
那么在后面我们会介绍这个

71
00:02:56,200 --> 00:02:58,100
这个是一个汇编语言编程序

72
00:02:58,133 --> 00:02:59,733
那么在这个汇编语言编程序中

73
00:02:59,733 --> 00:03:01,799
首先会保护用户现场

74
00:03:01,933 --> 00:03:05,133
那么把用户现场保存到一个叫做

75
00:03:05,700 --> 00:03:06,266
叫做什么呢

76
00:03:06,266 --> 00:03:07,299
进程上下文

77
00:03:07,300 --> 00:03:09,766
就是用户上下文的这么一个数据结构

78
00:03:09,766 --> 00:03:12,699
中那么最终完成一个非常重要的命

79
00:03:12,766 --> 00:03:14,533
非常重要的功能就是调用

80
00:03:14,933 --> 00:03:19,599
OSRM A32 system handler handle这个程序

81
00:03:19,600 --> 00:03:22,266
那么这个程序我们后面也会也会讲啊

82
00:03:22,266 --> 00:03:23,166
这个也会讲

83
00:03:23,266 --> 00:03:25,399
那么它对应的是一个什么操作呢

84
00:03:25,466 --> 00:03:28,566
它对应的就是这个操作啊这个操作

85
00:03:31,866 --> 00:03:32,999
那么最后呢

86
00:03:33,066 --> 00:03:33,866
由

87
00:03:34,733 --> 00:03:37,099
啊最后呢由这个OSRM

88
00:03:37,533 --> 00:03:39,666
啊最后呢是这样啊你看

89
00:03:39,733 --> 00:03:43,699
然后OSRM SY a a三二system call handle呢

90
00:03:43,700 --> 00:03:45,400
会根据我们刚才说了

91
00:03:45,400 --> 00:03:47,566
我们刚才把这个R7保

92
00:03:47,933 --> 00:03:48,933
这个27寄存器

93
00:03:48,933 --> 00:03:50,399
保存的就是具体的

94
00:03:50,400 --> 00:03:52,933
比如说MQ所对应的那个系统调用号

95
00:03:53,166 --> 00:03:54,133
那么这样的话呢

96
00:03:54,133 --> 00:03:56,799
这个这个这个函数啊就会查询根

97
00:03:56,800 --> 00:03:59,000
据这个调调用号来查询一个什么呢

98
00:03:59,000 --> 00:04:00,300
来来查询一个数组

99
00:04:00,566 --> 00:04:01,399
那这个数组呢

100
00:04:01,400 --> 00:04:02,100
就保存着

101
00:04:02,100 --> 00:04:04,466
每一个系统调用所对应的内核函数

102
00:04:04,766 --> 00:04:07,733
最后呢这个arm就会根据这个系统

103
00:04:07,766 --> 00:04:09,866
调用号来调用相应的函数

104
00:04:10,100 --> 00:04:10,533
然后呢

105
00:04:10,533 --> 00:04:13,999
这个函数的入入口参数就是这个20-22

106
00:04:14,000 --> 00:04:15,666
这个些寄存器的内容我们知道

107
00:04:15,666 --> 00:04:16,766
刚才我们知道了啊

108
00:04:16,900 --> 00:04:18,866
这个寄存器内容已经保存在上

109
00:04:18,866 --> 00:04:19,899
进程上下文了

110
00:04:19,900 --> 00:04:22,266
就是保存在一个进程上下文

111
00:04:22,266 --> 00:04:23,466
这样的一个数据结构中

112
00:04:23,466 --> 00:04:26,166
那么当这个完成完成处理之后呢

113
00:04:26,333 --> 00:04:28,899
就是这个except SWI handle

114
00:04:28,900 --> 00:04:30,800
就会恢复用户现场

115
00:04:31,400 --> 00:04:32,300
最后呢

116
00:04:33,066 --> 00:04:35,699
由用户它的切换和内核内核态

117
00:04:35,700 --> 00:04:37,400
也就是表示啊

118
00:04:38,266 --> 00:04:39,333
嗯系统调用

119
00:04:39,400 --> 00:04:42,333
已经代替用户完成了相应的工作

120
00:04:42,333 --> 00:04:43,666
然后呢就恢复现场

121
00:04:43,666 --> 00:04:46,366
返回用户的这个应用程序继续执行

122
00:04:48,966 --> 00:04:52,366
那么与系统调用相关的函数我们说啊

123
00:04:52,366 --> 00:04:54,166
与系统调用主要有两部分组成啊

124
00:04:54,166 --> 00:04:56,466
我们看系统调用实际上有两部分组成

125
00:04:56,666 --> 00:04:58,466
一部分是用户态的部分

126
00:04:58,466 --> 00:05:00,099
一部分是内核态的部分

127
00:05:00,200 --> 00:05:01,733
所以我们第一个project

128
00:05:01,733 --> 00:05:03,666
让大家编写一个系统调用

129
00:05:03,666 --> 00:05:05,266
大家实际上要编写两部分内容

130
00:05:05,266 --> 00:05:06,333
一部分用户态内容

131
00:05:06,333 --> 00:05:07,799
一部分是内核态内容

132
00:05:08,166 --> 00:05:08,866
那我们这个

133
00:05:08,866 --> 00:05:10,966
现在给大家讲的主要是内核态的内容

134
00:05:11,066 --> 00:05:12,766
那与内核态相关的代码呢

135
00:05:12,766 --> 00:05:14,733
主要保存在以下这两个文件中

136
00:05:14,733 --> 00:05:17,066
一个叫做loss杠system点c

137
00:05:17,266 --> 00:05:21,166
一个叫做s y s co杠look up点h

138
00:05:21,266 --> 00:05:23,733
那么大家可以看这两个文件啊

139
00:05:23,766 --> 00:05:26,399
那么在lost system点c中啊

140
00:05:26,400 --> 00:05:29,900
定义了系统调用函数的规范格式规

141
00:05:29,900 --> 00:05:31,933
范包括参数的个数等

142
00:05:31,966 --> 00:05:33,166
还有两个全局数组

143
00:05:33,166 --> 00:05:35,266
分别是global system co handle

144
00:05:35,700 --> 00:05:38,966
和global system call number arguments

145
00:05:38,966 --> 00:05:40,066
那从这个名字上

146
00:05:40,066 --> 00:05:41,499
你就可以知道这个保存的是什么呢

147
00:05:41,500 --> 00:05:42,966
这个保存的就是

148
00:05:43,200 --> 00:05:46,066
系统调用的这个函数的一个数组

149
00:05:46,066 --> 00:05:47,533
函数指针数组啊

150
00:05:47,533 --> 00:05:49,266
我在这儿提前说一下啊

151
00:05:49,266 --> 00:05:50,133
提前说一下

152
00:05:52,766 --> 00:05:54,699
啊比如说我们这个系统啊

153
00:05:54,700 --> 00:05:56,266
支持很多的系统调用

154
00:05:56,266 --> 00:05:57,133
支持很多的系统调用

155
00:05:57,133 --> 00:05:58,166
比如说MQ open

156
00:05:58,166 --> 00:06:01,799
比如说我们我们经常用的f open f red f red

157
00:06:02,000 --> 00:06:03,366
那这些东西都是系统调用

158
00:06:03,366 --> 00:06:04,866
那么每一个这样的系统调用

159
00:06:04,866 --> 00:06:05,966
在内核中的

160
00:06:06,066 --> 00:06:08,733
这个global system code都有一个指针啊

161
00:06:08,733 --> 00:06:09,933
函数指针与之对应

162
00:06:10,066 --> 00:06:10,666
当我们调用

163
00:06:10,666 --> 00:06:13,066
比如说我们调用这个MQ open的时候

164
00:06:13,066 --> 00:06:15,533
那么MQ open对应一个系统调用号

165
00:06:15,766 --> 00:06:17,799
那么系统调用号实际上就是这个系统

166
00:06:18,100 --> 00:06:19,366
这个系内用户态下

167
00:06:19,366 --> 00:06:22,133
这个系统调用在内核态的一个偏移量

168
00:06:22,400 --> 00:06:24,533
偏移量那么我们就根据这个偏移量

169
00:06:25,100 --> 00:06:26,900
系统调用也就是偏移量的号码

170
00:06:26,900 --> 00:06:27,800
到这个数字中找

171
00:06:27,800 --> 00:06:30,000
比如说跟MQ open

172
00:06:30,300 --> 00:06:32,266
跟我们刚才说那个MQ open

173
00:06:32,366 --> 00:06:33,666
相对应的那个号

174
00:06:33,666 --> 00:06:35,766
比如说系统调用号是100

175
00:06:35,933 --> 00:06:37,133
或比如说是我

176
00:06:37,133 --> 00:06:39,899
我举个例子比如说105 105

177
00:06:39,933 --> 00:06:41,399
那么那么我们知道

178
00:06:41,400 --> 00:06:44,500
这105就会被保存在R7寄存器中

179
00:06:44,733 --> 00:06:45,899
R7寄存器中

180
00:06:45,900 --> 00:06:48,300
那么在内在内核态执行的时候

181
00:06:48,300 --> 00:06:50,566
它就会用这个R7寄存器中保存的105

182
00:06:50,566 --> 00:06:52,499
到这个到这个global

183
00:06:52,533 --> 00:06:54,666
这个就是这个global system cloud handle

184
00:06:54,666 --> 00:06:56,399
去找找105

185
00:06:56,400 --> 00:06:57,533
那比如说105在这儿

186
00:06:57,533 --> 00:07:00,666
那这个就是这个MQ MSC MQ open

187
00:07:00,666 --> 00:07:02,466
所对应的这个函数啊

188
00:07:02,466 --> 00:07:03,899
内核处理函数的指针

189
00:07:04,500 --> 00:07:04,966
函数指针

190
00:07:04,966 --> 00:07:05,699
然后他那个

191
00:07:05,700 --> 00:07:07,700
他就在这个地方运行这个函数

192
00:07:07,700 --> 00:07:10,300
那么把运行的结果保存在20计算器中

193
00:07:10,700 --> 00:07:13,133
啊 20计存器是保存这个返回值的

194
00:07:13,300 --> 00:07:14,933
然后就返再返回到用户态

195
00:07:14,933 --> 00:07:16,666
那整个的这么一个工作过程

196
00:07:16,666 --> 00:07:18,299
大概就是这样的一个样子啊

197
00:07:19,400 --> 00:07:20,800
那么这个保存的是什么呢

198
00:07:20,800 --> 00:07:23,200
这个保存就是这个系统调用

199
00:07:23,200 --> 00:07:24,200
比如说MQ open

200
00:07:24,333 --> 00:07:28,299
那么它所所拥有的这个操作数的个数

201
00:07:29,466 --> 00:07:31,466
那么分别用于存储这个啊

202
00:07:31,466 --> 00:07:32,499
分别用于存储呢

203
00:07:32,500 --> 00:07:35,500
就是存储接口影射关系就是函数之恩

204
00:07:35,500 --> 00:07:36,533
还有就是这个接口

205
00:07:36,533 --> 00:07:38,133
也就是个函数参数个数

206
00:07:39,000 --> 00:07:40,966
定义系统调用初始化函数啊

207
00:07:40,966 --> 00:07:42,933
这个是进行系统初始化的

208
00:07:42,933 --> 00:07:43,666
那这是啥意思

209
00:07:43,666 --> 00:07:45,399
就是初始化我刚才说的这些

210
00:07:45,400 --> 00:07:46,066
全局数据结构

211
00:07:46,066 --> 00:07:47,466
特别是这global system

212
00:07:47,600 --> 00:07:49,266
handle的这个数据结构的函数

213
00:07:49,800 --> 00:07:52,100
那么主要用于初始化上述两个数组

214
00:07:52,300 --> 00:07:55,333
还有就是定义函数loss modulet

215
00:07:55,400 --> 00:07:56,766
将系统调用模块

216
00:07:56,766 --> 00:07:59,066
注册到内核的启动框架中

217
00:07:59,066 --> 00:08:00,399
并设置较高的无限极

218
00:08:00,400 --> 00:08:03,566
方便操作系统对系统调用进行初始化

219
00:08:03,600 --> 00:08:04,566
那么什么意思呢

220
00:08:04,566 --> 00:08:05,733
就是说这个函数啊

221
00:08:05,733 --> 00:08:07,099
这个函数由谁调用呢

222
00:08:07,100 --> 00:08:08,266
这个函数是在

223
00:08:08,966 --> 00:08:09,766
啊由这个

224
00:08:09,966 --> 00:08:12,866
由这个红来进行进行初始化啊

225
00:08:12,866 --> 00:08:13,733
由这个红来

226
00:08:13,733 --> 00:08:15,466
怎么样注册到操作系统内核

227
00:08:15,466 --> 00:08:16,999
那当它操作系统启动的时候

228
00:08:17,000 --> 00:08:18,666
它就会自动运行这个函数

229
00:08:18,800 --> 00:08:19,600
这个函数

230
00:08:20,133 --> 00:08:20,933
定义

231
00:08:21,400 --> 00:08:24,800
函数OSRM A32 sismcord handle啊

232
00:08:24,900 --> 00:08:25,866
依据传入的

233
00:08:25,866 --> 00:08:28,066
你看这个依据传入的性能调用号

234
00:08:28,266 --> 00:08:29,499
啊及其参数

235
00:08:29,500 --> 00:08:32,100
来执行具体的函数调用操作

236
00:08:32,100 --> 00:08:33,166
那么函数的实现呢

237
00:08:33,166 --> 00:08:35,466
一般在Systemcar目录的

238
00:08:35,566 --> 00:08:37,099
目录下的原代码文件中

239
00:08:37,566 --> 00:08:39,999
这是这是system点c

240
00:08:40,300 --> 00:08:43,166
那么system点a call点look杠look up点h

241
00:08:43,166 --> 00:08:45,266
是定义影射表

242
00:08:45,466 --> 00:08:47,499
通过系统调用编号

243
00:08:47,966 --> 00:08:51,199
影射系统调用函数声明和实现

244
00:08:51,300 --> 00:08:52,466
那么这个是什么意思呢

245
00:08:52,466 --> 00:08:53,866
这个实际上就是另一个红

246
00:08:53,866 --> 00:08:55,366
那这个红有什么用处呢

247
00:08:55,366 --> 00:08:58,166
这个红主要是用来促使化的啊

248
00:08:58,166 --> 00:09:00,166
处使化啊在这个地方有用

249
00:09:01,266 --> 00:09:01,299
啊

250
00:09:01,300 --> 00:09:03,166
我们看待会我们研究这个函数的时候

251
00:09:03,166 --> 00:09:03,899
初始化的时候

252
00:09:03,900 --> 00:09:05,933
我们就会看到它在这里头就运用

253
00:09:06,100 --> 00:09:08,933
运用到了这个system COROUP中定义的红

254
00:09:14,133 --> 00:09:16,333
好我们下面呢就给大家举一个例子

255
00:09:16,333 --> 00:09:19,133
那么你看我们在这说说整个这个

256
00:09:19,300 --> 00:09:21,933
整个这个系统调用完成分这么几步

257
00:09:21,933 --> 00:09:22,933
看到了分这么几步

258
00:09:22,933 --> 00:09:24,299
那么我们现在呢就

259
00:09:24,466 --> 00:09:26,599
一步一步的来实来看一下

260
00:09:26,600 --> 00:09:28,366
拿一个系统调用就是这个MQ

261
00:09:28,366 --> 00:09:30,499
Mac MQ open这个系统调用

262
00:09:30,600 --> 00:09:31,800
来看一下怎么实现

263
00:09:32,166 --> 00:09:33,966
那我们看一下啊这是用户程序

264
00:09:34,066 --> 00:09:35,066
这是用户程序

265
00:09:35,100 --> 00:09:37,966
那么在用户程序中呢它它采用了Mac HQ

266
00:09:37,966 --> 00:09:38,466
我们知道

267
00:09:38,466 --> 00:09:39,333
后面我们就会知道

268
00:09:39,333 --> 00:09:41,266
Mac HQ实际上是进行进程间

269
00:09:41,266 --> 00:09:42,866
通信的一种方式啊

270
00:09:43,166 --> 00:09:45,733
那么采用消息对列的方式来进行进

271
00:09:45,766 --> 00:09:46,899
来进行通信啊

272
00:09:46,900 --> 00:09:47,733
来进行通信

273
00:09:48,100 --> 00:09:49,700
那么现在我们先不管这个东西啊

274
00:09:49,700 --> 00:09:51,333
我们看一下这个massage q呢

275
00:09:51,466 --> 00:09:53,499
这个这个系统这个这个什么

276
00:09:53,500 --> 00:09:54,400
这个库函数啊

277
00:09:54,400 --> 00:09:55,866
我们现在说这是库函数

278
00:09:55,933 --> 00:09:57,799
这个库函数呢包含4个参数

279
00:09:57,800 --> 00:09:59,566
看这是massageq的name

280
00:09:59,966 --> 00:10:01,466
这是这是模式

281
00:10:01,466 --> 00:10:03,366
看到了啊这个这个是第二个参数啊

282
00:10:03,366 --> 00:10:04,966
第二个参数我用来干嘛的

283
00:10:05,000 --> 00:10:06,466
第三个就是模式啊

284
00:10:06,466 --> 00:10:07,366
还有一些属性

285
00:10:07,366 --> 00:10:08,166
看到了吧

286
00:10:08,166 --> 00:10:10,733
好那么我在应用程序里这么写

287
00:10:10,800 --> 00:10:11,500
那么实际上

288
00:10:11,500 --> 00:10:12,966
这个括函数内部是怎么写的

289
00:10:12,966 --> 00:10:13,966
它是这样写的

290
00:10:14,466 --> 00:10:15,899
当我调mass q的时候

291
00:10:15,900 --> 00:10:17,133
这个库函数内部是这样的

292
00:10:17,133 --> 00:10:19,733
我们看这个地方是一个可变参数啊

293
00:10:19,733 --> 00:10:21,799
可变参数可变参数指的意什么意思呢

294
00:10:21,800 --> 00:10:23,100
就是后面这个数据

295
00:10:23,400 --> 00:10:24,900
这个参数个数是不定的

296
00:10:24,900 --> 00:10:26,766
那在这里头我们就要用到这个

297
00:10:27,266 --> 00:10:29,066
VA list VA start

298
00:10:29,100 --> 00:10:32,766
VA argument VA and这样的一些这些红定义啊

299
00:10:32,766 --> 00:10:33,566
这些红定义

300
00:10:33,700 --> 00:10:34,700
那这是什么意思呢

301
00:10:34,700 --> 00:10:35,466
我们看一下啊

302
00:10:35,466 --> 00:10:36,266
我们看一下

303
00:10:36,300 --> 00:10:37,333
首先是什么呢

304
00:10:37,333 --> 00:10:38,666
首先是啊

305
00:10:38,866 --> 00:10:39,399
呃

306
00:10:39,400 --> 00:10:41,766
就是说我在用户态下通过函数调用

307
00:10:41,766 --> 00:10:44,199
把这些参数传递给了括函数啊

308
00:10:44,200 --> 00:10:45,966
库函数那么库函数要干嘛呢

309
00:10:45,966 --> 00:10:48,133
库函数就要把这个因为这是可变参数

310
00:10:48,133 --> 00:10:51,266
所以库函数就要用这些VA list VA start

311
00:10:51,266 --> 00:10:52,766
vargument VA and

312
00:10:52,966 --> 00:10:53,966
来把这些可变

313
00:10:53,966 --> 00:10:55,766
参数保存在它的局部变量里

314
00:10:55,766 --> 00:10:56,499
看到了吧

315
00:10:56,500 --> 00:10:57,366
在这里是什么意思呢

316
00:10:57,366 --> 00:10:59,299
你看第一个参数是flag

317
00:10:59,300 --> 00:11:01,866
就是这个create和啊WR

318
00:11:01,933 --> 00:11:05,133
所以说它把啊我们后面会说会解释啊

319
00:11:05,200 --> 00:11:06,700
它这是一个可变参数列表

320
00:11:06,700 --> 00:11:08,500
那它把这个可变参数列表的指针

321
00:11:08,500 --> 00:11:09,100
就指到这儿

322
00:11:09,100 --> 00:11:09,966
这个位置了

323
00:11:09,966 --> 00:11:11,399
啊指到这个位置了

324
00:11:11,466 --> 00:11:12,399
那然后呢

325
00:11:12,400 --> 00:11:14,733
下一个就是下一个参数就是mode啊mode

326
00:11:14,800 --> 00:11:16,600
那那你看它这个是什么意思呢

327
00:11:16,600 --> 00:11:19,333
这个就是它把这个可变参数列表了

328
00:11:19,333 --> 00:11:19,899
这个mode

329
00:11:19,900 --> 00:11:21,366
这个参数放到这个mode

330
00:11:21,366 --> 00:11:22,533
这个局部变量里了

331
00:11:22,600 --> 00:11:23,866
mode这个局部变量里

332
00:11:23,900 --> 00:11:24,966
然后指针向下移动

333
00:11:24,966 --> 00:11:27,066
一个位置所以就指到这个attribute

334
00:11:27,200 --> 00:11:29,300
那然后呢再用vargument

335
00:11:30,066 --> 00:11:32,699
啊再把这个attribute啊

336
00:11:32,700 --> 00:11:34,000
这个传递过来的attribute

337
00:11:34,000 --> 00:11:36,533
保存在它本地的这个attribute里了啊

338
00:11:36,533 --> 00:11:38,599
最后呢把把这个

339
00:11:39,500 --> 00:11:41,333
VA list这个这个数据

340
00:11:41,700 --> 00:11:44,566
把这个AP这个AP这是这个是那个

341
00:11:45,333 --> 00:11:46,899
数局局部变量的数据类型

342
00:11:46,900 --> 00:11:47,966
这个是局部变量

343
00:11:47,966 --> 00:11:48,533
那我怎么样

344
00:11:48,533 --> 00:11:49,966
我用完了这个AP之后呢

345
00:11:49,966 --> 00:11:52,499
我就把这个AP所占的资源释放掉

346
00:11:52,566 --> 00:11:53,699
那么大家看啊

347
00:11:54,500 --> 00:11:56,000
他完成这个什么工作呢

348
00:11:56,000 --> 00:11:58,000
他完成这个工作就是把用户

349
00:11:58,333 --> 00:11:59,066
用户太下

350
00:11:59,066 --> 00:11:59,999
这个系统调查参数

351
00:12:00,000 --> 00:12:01,600
保存到了他的局部变量里

352
00:12:01,733 --> 00:12:02,266
看到了啊

353
00:12:02,266 --> 00:12:03,666
保存到flag里

354
00:12:03,666 --> 00:12:06,266
保存到了mode里保存到了attribute里啊

355
00:12:06,266 --> 00:12:07,066
看到了吧

356
00:12:07,100 --> 00:12:09,200
然后大家看啊然后他干嘛呢

357
00:12:09,200 --> 00:12:10,200
然后他就

358
00:12:10,933 --> 00:12:12,066
把这个局部变量

359
00:12:12,100 --> 00:12:14,733
作为参数传递给了这个叫做

360
00:12:14,966 --> 00:12:18,333
sys CO啊system CO这样的一个函数啊

361
00:12:18,333 --> 00:12:20,166
这个这个函数实际上是个红定义啊

362
00:12:20,166 --> 00:12:21,966
我们后面接着看啊

363
00:12:22,100 --> 00:12:23,333
大家看这个地方是什么呢

364
00:12:23,333 --> 00:12:26,199
这个地方就是m open所对应的

365
00:12:26,200 --> 00:12:27,500
这是个系统调用号

366
00:12:28,000 --> 00:12:29,133
这是一个系统调换号啊

367
00:12:29,133 --> 00:12:31,199
它表示的就是啊

368
00:12:31,600 --> 00:12:33,766
m open所对应的系统调换号

369
00:12:40,533 --> 00:12:42,766
好在这给大家稍微解释一下什么呢

370
00:12:42,766 --> 00:12:44,666
解释一下这个可变参数

371
00:12:44,933 --> 00:12:46,499
那么c语言中

372
00:12:46,566 --> 00:12:48,966
可变参数也叫varible arguments

373
00:12:48,966 --> 00:12:49,766
是一种

374
00:12:50,133 --> 00:12:53,366
允许函数接收不定数量参数的计数

375
00:12:53,766 --> 00:12:55,066
那么可变函数呢

376
00:12:55,066 --> 00:12:58,166
通常在需要处理可变数量的参数

377
00:12:58,466 --> 00:13:00,699
或不同类型参数的函数中使用

378
00:13:00,900 --> 00:13:02,700
那么c语言提供了一组

379
00:13:02,966 --> 00:13:05,666
标准库洪来处理可变参数

380
00:13:05,666 --> 00:13:06,733
那么这些洪位

381
00:13:06,733 --> 00:13:07,533
于

382
00:13:07,866 --> 00:13:08,666
STD

383
00:13:09,133 --> 00:13:10,933
ARG点h头文件中

384
00:13:10,933 --> 00:13:12,466
那么下面呢是一些

385
00:13:12,700 --> 00:13:15,100
处理可变参数的常见标准库

386
00:13:15,100 --> 00:13:16,766
红以及如何使用它

387
00:13:17,300 --> 00:13:19,666
那么VA list是一个类型

388
00:13:20,000 --> 00:13:22,400
用于声明一个可变参数列表

389
00:13:22,933 --> 00:13:27,299
VA start红用于初始化可变参数列表

390
00:13:27,933 --> 00:13:31,199
将其指向可变参数列表的第一个参数

391
00:13:32,000 --> 00:13:32,800
AR

392
00:13:34,000 --> 00:13:36,366
arg varg红

393
00:13:36,366 --> 00:13:38,466
用于从可变参数列表中

394
00:13:38,600 --> 00:13:40,266
获取下一个参数的值

395
00:13:40,266 --> 00:13:43,066
同时将参数列表的位置向后移动

396
00:13:43,333 --> 00:13:44,599
Van的红

397
00:13:44,666 --> 00:13:46,999
用于结束对可变参数列表的访问

398
00:13:47,000 --> 00:13:48,266
释放相关资源

399
00:13:48,533 --> 00:13:49,399
那我们在这呢

400
00:13:49,400 --> 00:13:51,366
重点说一下这个VA star的红

401
00:13:51,400 --> 00:13:52,966
那我们看一下VA star的红呢

402
00:13:52,966 --> 00:13:54,466
实际上包含了两个参数

403
00:13:54,700 --> 00:13:55,766
第一个参数AP

404
00:13:55,766 --> 00:13:58,099
是一个VA list类型的对象

405
00:13:58,533 --> 00:14:01,166
它用于表示可变参数列表

406
00:14:01,600 --> 00:14:05,400
那么VA start会初始化这个VA list对象

407
00:14:05,466 --> 00:14:08,733
使其指向可变参数列表的起始位置

408
00:14:09,466 --> 00:14:12,899
那么VA last啊就是last power meter

409
00:14:13,266 --> 00:14:14,766
是可变参数列表的

410
00:14:14,766 --> 00:14:16,499
最后一个非可变参数啊

411
00:14:16,500 --> 00:14:17,500
这个你要记住啊

412
00:14:17,500 --> 00:14:18,900
大家看这个非常重要

413
00:14:19,100 --> 00:14:19,900
就是这个

414
00:14:20,466 --> 00:14:22,466
last power meter就是这个参数啊

415
00:14:22,466 --> 00:14:23,399
这个参数是什么呢

416
00:14:23,400 --> 00:14:25,600
是可变参数列表中的最后一个

417
00:14:25,600 --> 00:14:26,666
非可变参数

418
00:14:26,700 --> 00:14:28,000
那我们待会儿会有例子

419
00:14:28,166 --> 00:14:29,366
那么VA start呢

420
00:14:29,366 --> 00:14:31,099
使用这个参数来确定

421
00:14:31,400 --> 00:14:33,333
可变参数列表的起始位置

422
00:14:34,166 --> 00:14:35,199
好我们看一下例子啊

423
00:14:35,200 --> 00:14:35,933
看一个例子

424
00:14:35,933 --> 00:14:36,733
以下这个例子

425
00:14:36,733 --> 00:14:38,899
就展示了如何在函数中使用

426
00:14:39,000 --> 00:14:39,666
那么大家看

427
00:14:39,666 --> 00:14:40,533
比如说我现在呢

428
00:14:40,533 --> 00:14:43,099
定义了一个函数叫做print intagers

429
00:14:43,100 --> 00:14:44,333
print intagers

430
00:14:44,733 --> 00:14:45,666
那么在这个地方呢

431
00:14:45,666 --> 00:14:48,766
我们说这个print print integer是一个它的

432
00:14:48,766 --> 00:14:50,766
这个这个函数的参数是可变

433
00:14:50,766 --> 00:14:52,533
比如说在这里头有3个参数

434
00:14:52,533 --> 00:14:53,866
那如果把它变成4

435
00:14:53,866 --> 00:14:55,066
那后面就可以有4个参数

436
00:14:55,066 --> 00:14:56,933
变成5后面就可以有5个参数

437
00:14:57,266 --> 00:14:58,666
那么大家看在这里头啊

438
00:14:58,666 --> 00:15:00,666
在这里头第一个参第一个非可

439
00:15:00,666 --> 00:15:01,899
最后一个非可变参数什么

440
00:15:01,900 --> 00:15:02,700
就是count

441
00:15:02,733 --> 00:15:04,899
这count你后面这个值可以变

442
00:15:04,966 --> 00:15:06,266
但这个count值不变

443
00:15:06,266 --> 00:15:08,299
count不是不是这count位置不变

444
00:15:08,300 --> 00:15:09,300
看到了count位置不变

445
00:15:09,300 --> 00:15:10,866
所以你看在这说的啥

446
00:15:10,866 --> 00:15:12,199
在这说的是你看啊

447
00:15:12,400 --> 00:15:13,133
在这说的是什么呢

448
00:15:13,133 --> 00:15:15,933
这个vs start的这个last parameter是什么呢

449
00:15:15,933 --> 00:15:17,133
是可变参数列表中

450
00:15:17,133 --> 00:15:18,666
最后一个非可变参数

451
00:15:18,766 --> 00:15:20,133
所以在我们这个例子里

452
00:15:20,133 --> 00:15:22,399
这个con就是这个可变参数列表中的

453
00:15:22,400 --> 00:15:23,933
最后一个非可变参数

454
00:15:24,366 --> 00:15:25,166
我们看一下啊

455
00:15:25,166 --> 00:15:26,699
首先我用这个v a list

456
00:15:26,700 --> 00:15:28,600
来声明了一个可变参数列表

457
00:15:28,733 --> 00:15:29,733
可变参数列表

458
00:15:29,933 --> 00:15:31,699
然后呢然后呢

459
00:15:31,700 --> 00:15:33,566
你看这个可变参数列表

460
00:15:33,566 --> 00:15:35,899
它的起始就是这个起始位置是哪呢

461
00:15:35,900 --> 00:15:37,600
是lock com的后面这个

462
00:15:38,366 --> 00:15:39,666
come的后面这个位置

463
00:15:39,666 --> 00:15:40,699
所以come的是什么呢

464
00:15:40,700 --> 00:15:42,066
come的是这个起始

465
00:15:42,133 --> 00:15:44,599
可变参数列表中的第一个啊

466
00:15:44,600 --> 00:15:46,133
最后一个非可变参数

467
00:15:47,266 --> 00:15:48,866
所以他就可以用这个count

468
00:15:48,866 --> 00:15:50,166
我们可以用count来定位

469
00:15:50,166 --> 00:15:51,599
这个可变参数的起始位置

470
00:15:51,600 --> 00:15:53,066
就是这个count后边这个位置

471
00:15:53,166 --> 00:15:54,999
也就是这个位置啊

472
00:15:55,000 --> 00:15:55,766
这个位置

473
00:15:55,766 --> 00:15:56,599
那这是什么意思呢

474
00:15:56,600 --> 00:15:57,766
这个就是他把count

475
00:15:57,933 --> 00:15:59,899
他把这个count读进来了看到了吗

476
00:15:59,900 --> 00:16:01,500
读到这个count里了啊

477
00:16:01,900 --> 00:16:02,866
读到这个comt里了

478
00:16:02,933 --> 00:16:05,666
然后呢你看啊啊啊不不是他把comt

479
00:16:05,666 --> 00:16:06,366
读到这里了

480
00:16:06,366 --> 00:16:06,899
他是怎么样

481
00:16:06,900 --> 00:16:07,766
他用这个comt

482
00:16:07,766 --> 00:16:07,966
来

483
00:16:07,966 --> 00:16:10,099
定位了可变参数列表的起始位置啊

484
00:16:10,100 --> 00:16:12,100
定位了这个可变参数的起始位置

485
00:16:12,200 --> 00:16:14,966
然后你看啊for i等于0 i小于con

486
00:16:14,966 --> 00:16:15,699
这con是几

487
00:16:15,700 --> 00:16:17,966
cont是3 看到了i小于3 i加加

488
00:16:18,133 --> 00:16:19,933
然后呢因为什么呢

489
00:16:19,933 --> 00:16:21,699
因为他在这个start已经定位了

490
00:16:21,700 --> 00:16:22,600
com的起始

491
00:16:22,900 --> 00:16:24,700
就是可变参数列表的起始位置啊

492
00:16:24,700 --> 00:16:25,666
就是这个位置

493
00:16:25,766 --> 00:16:28,666
然后怎么样你看他依次读取三个值啊

494
00:16:28,966 --> 00:16:30,733
首先当com等于0的时候

495
00:16:30,733 --> 00:16:31,999
当i等于0的时候

496
00:16:32,066 --> 00:16:34,066
他把10读到这个number里了

497
00:16:34,066 --> 00:16:34,999
然后打印出来

498
00:16:35,300 --> 00:16:35,866
然后呢

499
00:16:35,866 --> 00:16:39,166
再往下走啊come等于一的时候他读了20

500
00:16:39,166 --> 00:16:40,966
come等于2的时候他读了30

501
00:16:41,133 --> 00:16:42,799
那这样的话他就循环三次

502
00:16:42,800 --> 00:16:45,500
把这个1020和30都打印出来了

503
00:16:45,566 --> 00:16:46,499
那完成之后呢

504
00:16:46,500 --> 00:16:48,266
就他就要把这个ARG

505
00:16:48,266 --> 00:16:50,099
给这个这个课文参数列表给

506
00:16:50,266 --> 00:16:51,566
释放掉啊

507
00:16:51,566 --> 00:16:52,699
这就是整个这个

508
00:16:52,700 --> 00:16:54,300
课文参数列表的一个应用

509
00:16:56,933 --> 00:16:59,366
好那我们上次刚刚说过了啊

510
00:16:59,366 --> 00:17:00,066
它是什么呢

511
00:17:00,066 --> 00:17:01,366
你看是完成了一个

512
00:17:01,366 --> 00:17:02,899
这个system card的一个系统调用

513
00:17:02,900 --> 00:17:03,400
那我们看一下

514
00:17:03,400 --> 00:17:05,200
这system card系统调用是什么呢

515
00:17:05,500 --> 00:17:07,000
system CO仍然是一个什么

516
00:17:07,000 --> 00:17:07,966
可变参数列表

517
00:17:07,966 --> 00:17:08,933
可变参数列表

518
00:17:09,066 --> 00:17:10,666
然后呢它在这个地方有6个

519
00:17:10,666 --> 00:17:11,533
又有6个

520
00:17:11,533 --> 00:17:13,799
有6个这个局部变量啊

521
00:17:13,800 --> 00:17:14,566
局部变量

522
00:17:14,566 --> 00:17:17,133
那么我们知道啊这个system CO呢

523
00:17:17,166 --> 00:17:19,166
其中有4个参数对吧

524
00:17:19,166 --> 00:17:20,099
有4个参数

525
00:17:20,100 --> 00:17:21,533
那这个地方有6个

526
00:17:21,600 --> 00:17:22,766
有6个局部变量

527
00:17:23,100 --> 00:17:24,166
所以呢你看他干嘛呢

528
00:17:24,166 --> 00:17:27,466
他首先啊我们知道任何一个局部变量

529
00:17:27,500 --> 00:17:29,600
不任何一个这个就是

530
00:17:29,600 --> 00:17:32,066
系统调用那他都是以这样的一个格式

531
00:17:32,066 --> 00:17:33,733
这个第一个位置一定是什么

532
00:17:33,733 --> 00:17:35,066
一定是系统调用号

533
00:17:35,266 --> 00:17:35,799
而剩下的

534
00:17:35,800 --> 00:17:38,600
是与具体系统调用相关的一些参数

535
00:17:38,600 --> 00:17:40,300
对吧所以我们知道这个

536
00:17:40,333 --> 00:17:41,866
最后一个不变参数是什么

537
00:17:41,866 --> 00:17:42,866
就是这个n对吧

538
00:17:42,866 --> 00:17:44,866
因为无论任何一个系统调用

539
00:17:44,866 --> 00:17:45,666
它都是什么

540
00:17:45,666 --> 00:17:46,933
它都是系统调用号

541
00:17:46,966 --> 00:17:49,333
所以你看在这就是Vstar的APN

542
00:17:49,333 --> 00:17:50,066
看到了吧

543
00:17:50,066 --> 00:17:52,366
那么这个在鸿蒙系统中

544
00:17:52,366 --> 00:17:54,766
你看他后有后后面有6个参数啊

545
00:17:54,766 --> 00:17:55,933
有6个局部变量

546
00:17:55,966 --> 00:17:56,699
所以你看啊

547
00:17:56,700 --> 00:17:59,300
在这个在这个MQ open里有只有4个

548
00:17:59,300 --> 00:18:01,200
所以你看他这只有4个会被

549
00:18:02,300 --> 00:18:03,566
会被会被会被设置啊

550
00:18:03,566 --> 00:18:05,566
会被设置分别放到a b c d

551
00:18:05,700 --> 00:18:06,500
剩下两个没有

552
00:18:06,500 --> 00:18:07,566
那由此可见呢

553
00:18:07,566 --> 00:18:08,466
整个这个

554
00:18:08,666 --> 00:18:09,733
整个这个系统啊

555
00:18:09,733 --> 00:18:11,533
支持最多有6个参数啊

556
00:18:11,533 --> 00:18:12,566
每个系统都要支

557
00:18:12,966 --> 00:18:14,566
就是所有的信条至多有6个

558
00:18:14,766 --> 00:18:15,533
那在这个地方

559
00:18:15,533 --> 00:18:16,299
我们就可以理解

560
00:18:16,300 --> 00:18:18,300
为什么这地方要用可变参数了

561
00:18:18,300 --> 00:18:18,800
为什么呢

562
00:18:18,800 --> 00:18:19,600
因为你看

563
00:18:19,700 --> 00:18:23,500
比如说SYSM open我用的是4个参数

564
00:18:23,600 --> 00:18:24,400
比如说

565
00:18:25,200 --> 00:18:26,666
f open f open

566
00:18:26,733 --> 00:18:27,666
那f open呢

567
00:18:27,666 --> 00:18:28,899
它它对应的是什么

568
00:18:28,900 --> 00:18:30,200
它可能就不是4个参数了

569
00:18:30,200 --> 00:18:31,600
可能是3个参数

570
00:18:31,733 --> 00:18:32,066
对吧

571
00:18:32,066 --> 00:18:34,533
两个参数甚至3个参或者三个参数

572
00:18:34,666 --> 00:18:35,866
所以这个地方每一个系统

573
00:18:35,866 --> 00:18:37,566
由于每一个系统调用它所

574
00:18:37,900 --> 00:18:39,666
传入的这个参数个数不一样

575
00:18:39,666 --> 00:18:42,099
所以这地方就用就得用什么可变参数

576
00:18:42,733 --> 00:18:43,699
啊可变参数

577
00:18:43,766 --> 00:18:46,566
那好那我们看啊他把这些可变参数呢

578
00:18:46,566 --> 00:18:49,133
他把这些系统调的参数分别保存在a b

579
00:18:49,133 --> 00:18:50,599
c d e f这6个局部

580
00:18:50,600 --> 00:18:51,266
局部变量里

581
00:18:51,266 --> 00:18:53,366
了然后他又调用了什么呢

582
00:18:53,366 --> 00:18:55,166
两个下划线system call

583
00:18:55,533 --> 00:18:56,166
system call啊

584
00:18:56,166 --> 00:18:57,366
它又调用了这个函数

585
00:18:58,766 --> 00:18:59,933
看到了又调上这个函数

586
00:18:59,933 --> 00:19:01,566
那么这个函数非常关键啊

587
00:19:01,566 --> 00:19:02,599
这个函数非常关键

588
00:19:02,600 --> 00:19:04,533
那么它完成一个什么作用呢

589
00:19:04,566 --> 00:19:07,299
它完成的作用就是依据参数个数

590
00:19:07,466 --> 00:19:10,133
的不同调用不同的底层处理函数

591
00:19:10,133 --> 00:19:12,966
那么将寄存器啊将参数存入寄存器中

592
00:19:13,933 --> 00:19:14,599
这是什么意思呢

593
00:19:14,600 --> 00:19:16,300
我们看一下这个红的展开啊

594
00:19:16,300 --> 00:19:17,466
这个红的展开啊

595
00:19:17,466 --> 00:19:18,399
这个红的展开

596
00:19:18,700 --> 00:19:20,600
那么你看这就是杠杠

597
00:19:20,666 --> 00:19:22,499
两个两个下划线CSM扣

598
00:19:22,600 --> 00:19:24,166
那么我们看它就用什么

599
00:19:24,166 --> 00:19:25,499
两个下划线CSM扣

600
00:19:25,933 --> 00:19:29,366
DISP啊这个东西来对它进行替换

601
00:19:29,400 --> 00:19:29,733
看到了吗

602
00:19:29,733 --> 00:19:30,366
这不是替换吗

603
00:19:30,366 --> 00:19:32,799
你看你看他不是调用这个东西了吗

604
00:19:32,800 --> 00:19:33,366
这个东西

605
00:19:33,366 --> 00:19:35,966
那然后他就给他替换成这这个东西

606
00:19:36,133 --> 00:19:37,099
那这个东西什么东西

607
00:19:37,100 --> 00:19:39,500
你看啊这个东西的第一个是一个什么

608
00:19:39,500 --> 00:19:42,066
是一个叫做system card的一个字符串啊

609
00:19:42,066 --> 00:19:42,699
这个是什么

610
00:19:42,700 --> 00:19:44,066
这个就是VA啊

611
00:19:44,066 --> 00:19:46,599
VA VA varguments

612
00:19:46,600 --> 00:19:47,533
这个传递是什么

613
00:19:47,533 --> 00:19:49,066
你看就传递的是这个

614
00:19:49,333 --> 00:19:50,133
这个列表

615
00:19:50,866 --> 00:19:53,166
传递传递的这个这个可变参数列表

616
00:19:53,500 --> 00:19:54,600
可变参数列表

617
00:19:54,600 --> 00:19:55,866
那我们再看这个

618
00:19:56,066 --> 00:19:58,133
两个下环形system call display是什么呢

619
00:19:58,133 --> 00:19:59,966
是这个在这儿进进行定义的

620
00:19:59,966 --> 00:20:04,599
你看它会被它替换叫做system call contact

621
00:20:04,800 --> 00:20:07,100
con呃concat concat

622
00:20:07,100 --> 00:20:08,700
我们知道concat是什么意思

623
00:20:08,733 --> 00:20:09,699
连接的意思

624
00:20:10,700 --> 00:20:11,333
连接的意思

625
00:20:11,333 --> 00:20:13,166
那这个你看这个这个b是什么

626
00:20:13,166 --> 00:20:14,499
就是这个system call在这写了

627
00:20:14,500 --> 00:20:15,766
就是system call字母串

628
00:20:16,100 --> 00:20:17,500
它把谁和谁连接在一起呢

629
00:20:17,500 --> 00:20:19,000
它把这个system call两个下划

630
00:20:19,000 --> 00:20:20,866
线system call和什么呢

631
00:20:20,866 --> 00:20:21,266
和这个

632
00:20:21,266 --> 00:20:24,166
你看这是这是system call number argument

633
00:20:24,166 --> 00:20:24,899
这是什么意思

634
00:20:24,900 --> 00:20:26,766
就是求系统调用

635
00:20:26,766 --> 00:20:29,066
到这个系统调用的这个可变列表里

636
00:20:29,066 --> 00:20:30,666
到底有多少个参数

637
00:20:30,700 --> 00:20:31,800
有多少个参数在我们这

638
00:20:31,800 --> 00:20:32,600
刚才这个

639
00:20:33,200 --> 00:20:34,866
MQ open里有几个参数

640
00:20:34,866 --> 00:20:35,933
是不是有4个参数

641
00:20:35,966 --> 00:20:36,899
所以这个红啊

642
00:20:36,900 --> 00:20:38,200
在上面有一顿定义

643
00:20:38,200 --> 00:20:39,400
这个代表连接的意思

644
00:20:39,400 --> 00:20:39,766
看到了吗

645
00:20:39,766 --> 00:20:40,599
连接的意思

646
00:20:40,600 --> 00:20:41,400
那它什么意思呢

647
00:20:41,400 --> 00:20:43,566
它就是把这个两个下划线system

648
00:20:44,266 --> 00:20:46,266
system和这个4啊

649
00:20:46,500 --> 00:20:47,800
因为MQ有4个参数嘛

650
00:20:47,800 --> 00:20:48,366
所以这个红

651
00:20:48,366 --> 00:20:51,066
就求出这个MQ具体的参

652
00:20:51,066 --> 00:20:52,799
具体的性调用一共有多少个参数

653
00:20:52,800 --> 00:20:54,466
然后他就把这两个东西连在一起

654
00:20:54,466 --> 00:20:56,699
就是什么杠杠system call 4

655
00:20:57,000 --> 00:20:58,300
那后面是一个括号

656
00:20:58,300 --> 00:21:00,366
加上传递过来的这个科研参数

657
00:21:00,366 --> 00:21:02,299
那么大家看它的结果是什么呢

658
00:21:02,300 --> 00:21:04,066
是不是就是调用啊

659
00:21:04,066 --> 00:21:05,266
就是调用哪个呀

660
00:21:06,166 --> 00:21:07,266
就是调用这个

661
00:21:08,566 --> 00:21:09,566
我刚才我说的

662
00:21:09,566 --> 00:21:12,499
就是针对我们刚才说的那个MQSMQ open

663
00:21:12,500 --> 00:21:13,066
这个系统调

664
00:21:13,066 --> 00:21:14,199
因为它有四个参数

665
00:21:14,366 --> 00:21:16,099
所以在这个地方经过连接之后

666
00:21:16,100 --> 00:21:17,600
就生成了这个字母串

667
00:21:17,733 --> 00:21:18,699
systemcard 4

668
00:21:19,100 --> 00:21:21,933
然后呢把这个参数列表放到这里

669
00:21:22,800 --> 00:21:23,800
看到了放在这里

670
00:21:23,800 --> 00:21:24,900
那就完成了什么呢

671
00:21:24,900 --> 00:21:26,133
完成了啊

672
00:21:26,133 --> 00:21:29,266
你看我们从我们刚才呢就是说啊

673
00:21:29,266 --> 00:21:31,733
讲一顿讲一顿讲就完成了什么呢

674
00:21:31,733 --> 00:21:32,533
这个拼接

675
00:21:32,566 --> 00:21:35,566
那我们再看下面具体看一下这个CS

676
00:21:35,933 --> 00:21:37,799
两个下划线CSM扣4

677
00:21:37,800 --> 00:21:39,366
它到底是一个什么东西啊

678
00:21:39,500 --> 00:21:40,533
那我们看啊

679
00:21:41,133 --> 00:21:42,466
这些东西都是什么呢

680
00:21:42,466 --> 00:21:44,599
保存在局部变量传递过来的啊

681
00:21:44,600 --> 00:21:45,133
都是什么

682
00:21:45,133 --> 00:21:46,099
就是杠杠CSM

683
00:21:46,100 --> 00:21:47,866
靠那个函数保存到局部变量

684
00:21:47,866 --> 00:21:48,733
传递过来了

685
00:21:48,733 --> 00:21:49,933
那我们看它干嘛呢

686
00:21:49,933 --> 00:21:50,733
你看啊

687
00:21:50,900 --> 00:21:53,133
在这里你看它把这个这是一个句

688
00:21:53,133 --> 00:21:54,199
这是一个汇编语言

689
00:21:54,200 --> 00:21:54,866
它怎么样呢

690
00:21:54,866 --> 00:21:56,166
它把这个n

691
00:21:56,166 --> 00:21:56,999
这个n是不是

692
00:21:57,000 --> 00:21:57,733
这n是什么

693
00:21:57,733 --> 00:21:59,733
就是m q open的系统调用号

694
00:21:59,900 --> 00:22:02,400
它把这个n保存在了A7处理器中

695
00:22:02,733 --> 00:22:06,266
A7处理器中然后把ABCD这四个参数

696
00:22:06,366 --> 00:22:10,099
分别保存到了R0 R1 R2和R3寄存器中

697
00:22:10,100 --> 00:22:10,866
所以大家看啊

698
00:22:10,866 --> 00:22:12,533
它这完成的是一个什么呢

699
00:22:12,666 --> 00:22:15,333
完成的是把参数由内存

700
00:22:15,500 --> 00:22:16,933
保存到了寄存器中

701
00:22:17,333 --> 00:22:18,133
这是内存单元

702
00:22:18,133 --> 00:22:19,866
然后保存因为这是局务页链啊

703
00:22:19,866 --> 00:22:21,399
局部页链就是内存中的单元

704
00:22:21,400 --> 00:22:24,300
或者说战中的战中的那个存储单元

705
00:22:24,400 --> 00:22:25,966
然后保存到了寄存器中

706
00:22:26,066 --> 00:22:28,166
然后再看他调用了又调用了

707
00:22:28,366 --> 00:22:30,933
叫做ASM system扣这个函数

708
00:22:30,933 --> 00:22:31,799
那好我们再看一下

709
00:22:31,800 --> 00:22:33,900
这个ASM system扣函数是什么

710
00:22:34,800 --> 00:22:37,333
来看这就是a s m c信号函数

711
00:22:37,466 --> 00:22:39,899
大家想一想我们现在头脑中想一想啊

712
00:22:40,333 --> 00:22:43,733
想一想就是说我们现在呢这是CPU

713
00:22:45,300 --> 00:22:46,100
CPU

714
00:22:46,733 --> 00:22:49,599
那么大家看啊CPU里呢有很多寄存器

715
00:22:49,600 --> 00:22:51,566
其中呢有R0寄存器

716
00:22:52,533 --> 00:22:54,866
一直到R12寄存器

717
00:22:55,700 --> 00:22:56,866
22计存器

718
00:22:57,200 --> 00:22:58,766
那么我们刚才怎么样

719
00:22:58,766 --> 00:23:01,466
把27寄存器中保存了系统调用号

720
00:23:01,533 --> 00:23:03,099
然后把那参数啊

721
00:23:03,333 --> 00:23:05,866
这27保存了系统调用号n对吧

722
00:23:05,933 --> 00:23:06,766
那么那些参数

723
00:23:06,766 --> 00:23:09,333
我分别保存到了R0到R3寄存器

724
00:23:09,333 --> 00:23:10,333
这四个参数啊

725
00:23:10,333 --> 00:23:11,799
保存这个寄存器了

726
00:23:11,800 --> 00:23:12,400
然后怎么样呢

727
00:23:12,400 --> 00:23:14,700
通过S V C 0来进行什么呢

728
00:23:14,700 --> 00:23:15,566
来进行

729
00:23:16,533 --> 00:23:16,566
啊

730
00:23:16,566 --> 00:23:19,599
来进行由用户态到内核态的一个切换

731
00:23:19,766 --> 00:23:21,966
由用户用户态到内核态的一个切换

732
00:23:21,966 --> 00:23:24,866
那这样的话当SC0成执行成功的时候

733
00:23:24,866 --> 00:23:26,066
我现在就进入内核态了

734
00:23:26,066 --> 00:23:28,266
也就是操作系统开始执行了啊

735
00:23:28,266 --> 00:23:29,866
所以这就是一个分水岭啊

736
00:23:29,866 --> 00:23:30,999
这头是一个分水岭

737
00:23:33,366 --> 00:23:35,666
那好那么我们提到了这个

738
00:23:35,666 --> 00:23:38,599
就是呃这个内核态

739
00:23:38,600 --> 00:23:39,766
那么我们看一下啊

740
00:23:39,766 --> 00:23:42,366
arm处理器一共几支持几种状态

741
00:23:42,400 --> 00:23:43,266
几种状态

742
00:23:43,666 --> 00:23:45,366
那么在这里头我们看一下这个

743
00:23:45,366 --> 00:23:47,999
SVC指令和和SVC模式

744
00:23:48,300 --> 00:23:51,600
SVC指令呢称为super Supervisor扣

745
00:23:51,666 --> 00:23:55,799
那么用于完成工作模式的切换啊切换

746
00:23:55,966 --> 00:23:59,999
那么future Supervisor呢简称也简称是SVC

747
00:24:00,366 --> 00:24:03,466
那么系统调用通过执行SVC命令

748
00:24:03,933 --> 00:24:05,533
触发arm软中断

749
00:24:05,966 --> 00:24:08,499
从而呢切换到SVC管理模式

750
00:24:08,600 --> 00:24:11,966
那么进而呢执行软中断异常处理函数

751
00:24:11,966 --> 00:24:13,866
大家看啊这个就是中断向量表

752
00:24:13,866 --> 00:24:15,666
就是我们系统初始化的时候

753
00:24:15,666 --> 00:24:16,866
arm在什么呢

754
00:24:17,366 --> 00:24:20,099
am在操作系统最前面保存的是什么呢

755
00:24:20,166 --> 00:24:23,066
就是说实际上Chrono的最前面并不是

756
00:24:23,066 --> 00:24:23,699
操作系统代码

757
00:24:23,700 --> 00:24:25,200
而是这个中中的向量表

758
00:24:25,666 --> 00:24:27,133
啊中段向量表中段向量表

759
00:24:27,266 --> 00:24:28,399
那么当这个

760
00:24:28,733 --> 00:24:31,299
当我们一执行这个SVC命令的时候

761
00:24:31,300 --> 00:24:32,900
那么arm处理器就自动的

762
00:24:32,900 --> 00:24:33,900
这就硬件完成了

763
00:24:33,900 --> 00:24:35,900
自动的到这个中段向量表的

764
00:24:36,100 --> 00:24:38,900
第三个位置来执行这个OS except

765
00:24:39,333 --> 00:24:41,733
SWI handle这个程序啊这个程序

766
00:24:41,866 --> 00:24:44,099
那么这个程序就是软中段处理程序

767
00:24:44,933 --> 00:24:47,299
那么这个程序呢是由汇编语言写的啊

768
00:24:47,300 --> 00:24:49,266
所以我们现在我们现在梳理一下

769
00:24:49,266 --> 00:24:49,666
就是说

770
00:24:49,666 --> 00:24:51,699
当我一执行这个SVM指令的时候

771
00:24:51,700 --> 00:24:53,866
由硬件直接跳转到什么呢

772
00:24:53,866 --> 00:24:55,299
我们初始化好的这个

773
00:24:55,600 --> 00:24:57,866
这个这个OS except

774
00:24:57,866 --> 00:25:00,066
SW handle这个函数来运行

775
00:25:01,000 --> 00:25:01,600
单运行

776
00:25:01,600 --> 00:25:04,266
那么除了这个软中断处理函数之外呢

777
00:25:04,266 --> 00:25:05,333
我们看一下还有什么

778
00:25:05,333 --> 00:25:06,199
比如说啊

779
00:25:06,300 --> 00:25:07,533
这个这个这个是什么

780
00:25:07,533 --> 00:25:09,699
reset Victor你就知道这是什么

781
00:25:10,200 --> 00:25:11,900
这个这个函数是什么

782
00:25:11,900 --> 00:25:13,566
就是重启啊重启

783
00:25:13,566 --> 00:25:14,966
比如说我们按一下reset键

784
00:25:14,966 --> 00:25:16,766
我们计算机都reset键对吧

785
00:25:16,766 --> 00:25:17,999
那么按一下reset键

786
00:25:18,066 --> 00:25:20,599
那就自动的会运行这个这个处理程序

787
00:25:20,766 --> 00:25:22,199
啊那这个是什么呢

788
00:25:22,200 --> 00:25:26,333
accept and define instruction handle这是什么

789
00:25:26,333 --> 00:25:29,199
就是说未定义啊未定义指令处

790
00:25:29,200 --> 00:25:30,000
当

791
00:25:30,466 --> 00:25:31,333
CPU执行的时候

792
00:25:31,333 --> 00:25:33,299
发现是碰到不认识的指令的时候

793
00:25:33,300 --> 00:25:34,733
他就会跳转到这儿来执行

794
00:25:35,100 --> 00:25:37,166
那么这个呢是取指异常啊

795
00:25:37,166 --> 00:25:38,599
取指异常的处理程序

796
00:25:38,733 --> 00:25:41,199
这个是取数据啊数据异常的处理程序

797
00:25:41,200 --> 00:25:43,066
这个是地址异常的处理程序

798
00:25:43,133 --> 00:25:44,499
那这个就是硬中断处理程序

799
00:25:44,500 --> 00:25:45,900
我们后面讲中断啊

800
00:25:45,900 --> 00:25:47,666
中断主要是针对他的

801
00:25:47,666 --> 00:25:49,199
那这个地方还有个快中断

802
00:25:49,266 --> 00:25:51,299
那么那么这就是一般中断

803
00:25:51,366 --> 00:25:53,766
一般来讲呢在系统中的那个比较

804
00:25:53,800 --> 00:25:55,500
就是比较速度比较快的

805
00:25:55,500 --> 00:25:56,266
比如说网卡

806
00:25:56,266 --> 00:25:58,133
那么一般都保存在快中断里

807
00:25:58,300 --> 00:25:59,133
那比如说键盘呢

808
00:25:59,133 --> 00:26:00,766
鼠标啊这种比较慢的慢速设备

809
00:26:00,766 --> 00:26:02,166
一般都保存在这个

810
00:26:02,266 --> 00:26:02,933
都由这个

811
00:26:02,933 --> 00:26:05,399
一般的这个中断处理程序来运行

812
00:26:09,866 --> 00:26:11,533
那么刚才说的是什么

813
00:26:11,533 --> 00:26:13,666
刚才说的是这个7个什么呢

814
00:26:13,666 --> 00:26:14,766
7个中段处理函数

815
00:26:14,766 --> 00:26:16,166
那这7个中段处理函数呢

816
00:26:16,166 --> 00:26:16,899
就与什么呢

817
00:26:16,900 --> 00:26:19,466
就与这个啊

818
00:26:19,466 --> 00:26:21,999
就与这个啊用户模式相

819
00:26:22,066 --> 00:26:23,333
用户模式相对应啊

820
00:26:23,333 --> 00:26:24,366
用户模式相对应

821
00:26:25,066 --> 00:26:25,566
但啊

822
00:26:25,566 --> 00:26:27,166
这个这个没有一一对应啊

823
00:26:27,166 --> 00:26:28,133
没有一一对应啊

824
00:26:28,133 --> 00:26:30,266
那么我们说啊即处理器一般

825
00:26:30,266 --> 00:26:31,399
处于这么几种模式

826
00:26:31,400 --> 00:26:33,900
首先是第一种模式叫做用户态模式

827
00:26:33,900 --> 00:26:34,766
用户态模式

828
00:26:34,966 --> 00:26:35,399
用户态

829
00:26:35,400 --> 00:26:37,533
当然没有对应这里的任何一个什么

830
00:26:37,533 --> 00:26:38,333
任何一个东西啊

831
00:26:38,333 --> 00:26:39,499
没有对应一个任何东西

832
00:26:39,900 --> 00:26:41,100
然后就是快中断模式

833
00:26:41,100 --> 00:26:42,733
快中断模式的用于处理

834
00:26:42,733 --> 00:26:44,999
对时间要求比较紧急的中断请求

835
00:26:45,000 --> 00:26:47,200
一般用于数据传输和通道处理

836
00:26:47,300 --> 00:26:48,533
那最典型就是网卡

837
00:26:48,533 --> 00:26:49,933
那对应的是这个状态

838
00:26:50,500 --> 00:26:52,900
这个中断那然后是一般中断

839
00:26:52,900 --> 00:26:54,066
一般中断模式啊

840
00:26:54,066 --> 00:26:55,533
用于处理一般的中断请求

841
00:26:55,533 --> 00:26:56,599
那对应的是这个

842
00:26:57,533 --> 00:26:58,799
啊这个都中断项量

843
00:26:59,000 --> 00:26:59,966
那么管理模式

844
00:26:59,966 --> 00:27:01,299
也就是我们现在所

845
00:27:01,333 --> 00:27:02,966
说的这个系统中断啊

846
00:27:02,966 --> 00:27:03,733
系统调用啊

847
00:27:03,733 --> 00:27:07,666
用于系统处置化和软中断处处理

848
00:27:07,900 --> 00:27:09,866
那么用户模式下的用户程序呢

849
00:27:09,866 --> 00:27:12,766
请求使用硬件资源是通过软中断

850
00:27:13,000 --> 00:27:16,166
软件中断进入该模式就是SVC命令啊

851
00:27:16,566 --> 00:27:17,499
那么他是谁呢

852
00:27:17,500 --> 00:27:19,500
他对应的是这个这个模式

853
00:27:19,800 --> 00:27:22,666
那么数值数据访问终止模式

854
00:27:22,866 --> 00:27:26,133
用于支持虚拟内存或者是存储器保护

855
00:27:26,566 --> 00:27:29,533
当用户程序访啊访问非法的地址

856
00:27:29,533 --> 00:27:32,066
或者是没有权限进行读取内存

857
00:27:32,366 --> 00:27:34,266
内存地址时它进入该模式

858
00:27:34,266 --> 00:27:35,366
那么它主要是

859
00:27:35,466 --> 00:27:37,099
后面我们再去虚拟内存的时候

860
00:27:37,100 --> 00:27:38,200
也会利用这个东西

861
00:27:38,200 --> 00:27:40,100
你比如说你访问了其他的

862
00:27:40,800 --> 00:27:43,733
其他进程的地址啊那他就会终止你啊

863
00:27:43,733 --> 00:27:45,999
终止就会触发这个中断

864
00:27:46,400 --> 00:27:48,366
那么系统模式

865
00:27:48,366 --> 00:27:50,699
那么操作系统在该模式下呢

866
00:27:50,700 --> 00:27:53,866
可以方便的访问用户模式计算器

867
00:27:53,866 --> 00:27:55,366
并且呢操作系统

868
00:27:55,966 --> 00:27:56,999
的一些特权指令呢

869
00:27:57,000 --> 00:27:58,900
也可以使用这个模式呢

870
00:27:58,900 --> 00:28:00,600
访问一些受控制的资源

871
00:28:00,966 --> 00:28:02,266
啊受控制的资源

872
00:28:03,400 --> 00:28:06,966
还有就是未指定模式未指定啊未指

873
00:28:06,966 --> 00:28:09,099
未定义指令终止模式

874
00:28:09,266 --> 00:28:10,699
那么用于支持

875
00:28:11,566 --> 00:28:14,666
硬件斜处理器的仿软件仿真啊

876
00:28:14,666 --> 00:28:15,699
等等等等啊

877
00:28:15,700 --> 00:28:18,800
软件仿真那这个东西是硬件相关的啊

878
00:28:22,466 --> 00:28:24,066
好那么再继续往下

879
00:28:24,066 --> 00:28:25,666
我们现在说到哪了呢

880
00:28:25,666 --> 00:28:27,966
我们现在说到这个就是啊

881
00:28:27,966 --> 00:28:28,799
我们说到什么呢

882
00:28:28,800 --> 00:28:30,366
就是用户态啊

883
00:28:30,400 --> 00:28:33,200
执行了SVC0命令进入到内核态

884
00:28:33,266 --> 00:28:34,866
那么这时候大家想一想

885
00:28:34,866 --> 00:28:36,366
它的这个无论是

886
00:28:36,800 --> 00:28:39,133
无论是那个就是系统调用的

887
00:28:39,133 --> 00:28:39,966
系统调用号

888
00:28:39,966 --> 00:28:41,099
还是那些参数

889
00:28:41,100 --> 00:28:42,766
都被保存在了寄存器中

890
00:28:42,766 --> 00:28:45,066
对吧被保存在寄存器中了

891
00:28:45,066 --> 00:28:45,966
那么我们知道啊

892
00:28:45,966 --> 00:28:49,299
我们知道当在内核态下要运什么呢

893
00:28:49,300 --> 00:28:50,700
是要是不是要运行这个

894
00:28:50,700 --> 00:28:52,466
MQ open所对应的那个

895
00:28:52,933 --> 00:28:54,499
系统的处理函数

896
00:28:54,566 --> 00:28:54,933
那么

897
00:28:54,933 --> 00:28:56,566
那个系统的处理函数要运行的时候

898
00:28:56,566 --> 00:29:00,133
就会势必会占用这个220221222223

899
00:29:00,200 --> 00:29:02,666
还有227处理这个这个寄存器

900
00:29:02,700 --> 00:29:03,800
所以我们必须要怎么样呢

901
00:29:03,800 --> 00:29:05,466
我们必须首先要把这些寄存器

902
00:29:05,466 --> 00:29:06,099
保存起来

903
00:29:06,100 --> 00:29:07,266
那保存到哪呢

904
00:29:07,266 --> 00:29:09,299
就保存在这个task context的这个

905
00:29:09,300 --> 00:29:10,733
数据结构里啊

906
00:29:10,733 --> 00:29:12,299
你看这个数据结构是什么样的

907
00:29:12,300 --> 00:29:13,933
这个数据结构就是你看你看

908
00:29:13,933 --> 00:29:16,299
从这个有一些特殊特殊寄存器

909
00:29:16,300 --> 00:29:18,300
比如说CPSR这状态寄存器

910
00:29:18,300 --> 00:29:19,766
PC是指针寄存器

911
00:29:20,100 --> 00:29:21,900
这个是链接寄存器啊

912
00:29:21,900 --> 00:29:23,900
然后剩下的这些寄存器看到了吧

913
00:29:24,566 --> 00:29:25,666
看到吧这都是计算器

914
00:29:25,666 --> 00:29:28,366
所以所以大家想一想就是说当我

915
00:29:28,366 --> 00:29:29,333
这个我们知道啊

916
00:29:29,333 --> 00:29:30,599
我们再回顾一下前面

917
00:29:30,600 --> 00:29:31,666
我们再回顾一下前面

918
00:29:31,666 --> 00:29:33,266
大家看当我

919
00:29:34,066 --> 00:29:36,766
当我就是说执行SVC命令之前啊

920
00:29:36,766 --> 00:29:39,133
R7保存的是系统调用号

921
00:29:39,533 --> 00:29:41,699
R0到R3保存的是

922
00:29:42,333 --> 00:29:42,766
这个系

923
00:29:42,766 --> 00:29:45,966
统调用所对应的入口就是这个参数

924
00:29:45,966 --> 00:29:47,366
对吧这个函数的参数

925
00:29:47,400 --> 00:29:50,333
然后去执行OS LQ handle对吧

926
00:29:50,333 --> 00:29:53,599
那么OSQ OS LQ handle第一件事情要干嘛

927
00:29:53,600 --> 00:29:55,700
第一件事情就是要把CPU中

928
00:29:55,866 --> 00:29:57,133
这些数据啊

929
00:29:57,133 --> 00:29:59,499
CPU计存器中的这些数据保存到哪了

930
00:29:59,500 --> 00:30:00,500
保存到这个

931
00:30:01,100 --> 00:30:03,066
这个数据结构里啊所以

932
00:30:03,566 --> 00:30:05,066
他为什么保存的这个数据结构呢

933
00:30:05,066 --> 00:30:08,333
因为真正的系统调用在内核太

934
00:30:08,333 --> 00:30:09,533
那系统调用运行的时候

935
00:30:09,533 --> 00:30:10,799
他要用到这些计算器

936
00:30:10,800 --> 00:30:12,566
如果你要不把原来的这个计算器保

937
00:30:12,566 --> 00:30:15,366
存的话那原来的值就冲掉了对吧

938
00:30:16,266 --> 00:30:17,266
好那它怎么保存呢

939
00:30:17,266 --> 00:30:18,299
现在我们就来看一下

940
00:30:18,300 --> 00:30:21,733
OS except software interrupt handle这个函数

941
00:30:21,733 --> 00:30:22,333
干嘛

942
00:30:22,333 --> 00:30:24,899
那么这个就是它保留啊这个就是它

943
00:30:24,900 --> 00:30:26,066
那个就是

944
00:30:26,533 --> 00:30:28,066
保存的这个方法啊

945
00:30:28,066 --> 00:30:28,999
保存这个方法好

946
00:30:29,000 --> 00:30:31,466
我们我们看一下它怎么保存的

947
00:30:33,666 --> 00:30:35,199
好我们首先呢把这个

948
00:30:36,266 --> 00:30:37,199
啊把这个

949
00:30:40,500 --> 00:30:42,666
把这个复制过来这样的好好看一些啊

950
00:30:42,666 --> 00:30:43,466
好

951
00:30:44,900 --> 00:30:46,166
我们看一下啊

952
00:30:46,266 --> 00:30:48,099
那么这个呢是

953
00:30:48,733 --> 00:30:49,499
呃是这样啊

954
00:30:49,500 --> 00:30:52,300
当执行SV命SVC命令的时候他

955
00:30:52,300 --> 00:30:53,966
他需要进行战切换啊

956
00:30:53,966 --> 00:30:56,466
战切换由用户战啊

957
00:30:56,466 --> 00:30:58,999
由用户探下的用户战切换到了内核战

958
00:30:59,100 --> 00:31:00,900
那至于说用户战和内核战

959
00:31:00,900 --> 00:31:01,533
这是怎么回事

960
00:31:01,533 --> 00:31:04,066
等到我们讲那个就是任务任务的时候

961
00:31:04,066 --> 00:31:04,899
我们会给大家说

962
00:31:04,900 --> 00:31:07,200
你只要知道他现在已经进入内核战了

963
00:31:07,500 --> 00:31:08,600
那么内核站呢

964
00:31:08,600 --> 00:31:10,400
就是你看这是SP是站指针

965
00:31:10,466 --> 00:31:12,366
站指针那这个函数代表什么

966
00:31:12,366 --> 00:31:13,866
这条语句代表什么意思呢

967
00:31:13,933 --> 00:31:15,799
这条语句代表的是啊

968
00:31:15,800 --> 00:31:17,466
他首先啊他首先

969
00:31:17,466 --> 00:31:19,866
你看第一条语句是这样你看他首先

970
00:31:19,866 --> 00:31:20,499
第一条语句他

971
00:31:20,500 --> 00:31:23,566
把PC和这个CPSR计存器保存起来了

972
00:31:23,600 --> 00:31:26,766
把CPU当前的CPSR和PC这个

973
00:31:27,466 --> 00:31:28,266
这个数

974
00:31:28,800 --> 00:31:29,866
保存起来了

975
00:31:30,066 --> 00:31:30,966
然后呢

976
00:31:31,866 --> 00:31:33,499
然后呢他然后呢

977
00:31:33,500 --> 00:31:35,800
你看啊这个这个表什么意思就是把

978
00:31:36,000 --> 00:31:36,800
R2

979
00:31:37,066 --> 00:31:38,399
保存起来压到战力

980
00:31:38,400 --> 00:31:39,933
然后把R12压到战力

981
00:31:39,933 --> 00:31:42,299
然后再把R3到R0依次压到战力

982
00:31:42,300 --> 00:31:44,066
看R3 R1 R2 R0

983
00:31:44,133 --> 00:31:45,866
所以执行到这块的时候

984
00:31:45,866 --> 00:31:47,166
执行到这块的时候啊

985
00:31:47,166 --> 00:31:48,599
战指针已经指到这了

986
00:31:50,466 --> 00:31:51,199
我看一下啊

987
00:31:51,200 --> 00:31:52,000
批注一下

988
00:31:52,166 --> 00:31:52,966
啊

989
00:31:53,133 --> 00:31:54,566
执行这个条指令的时候

990
00:31:54,566 --> 00:31:56,666
站指针已经指到这个位置了

991
00:31:57,300 --> 00:31:58,500
啊已经指到这个位置了

992
00:31:58,500 --> 00:31:59,566
然后呢再看

993
00:31:59,766 --> 00:32:01,933
然后呢他在这个地方执行这两个操作

994
00:32:01,933 --> 00:32:02,866
这两个操作是什么呢

995
00:32:02,866 --> 00:32:03,766
站指针不动

996
00:32:03,933 --> 00:32:07,366
2 然后把23和24保存到这个位置

997
00:32:09,266 --> 00:32:10,499
啊包括这个位置

998
00:32:10,900 --> 00:32:12,533
但是你注意这时候站指针没动

999
00:32:12,533 --> 00:32:13,666
然后他怎么样呢

1000
00:32:13,700 --> 00:32:14,766
然后乘以4

1001
00:32:14,766 --> 00:32:17,199
那么大家看站指针加上4

1002
00:32:17,400 --> 00:32:20,333
你看啊站指针加上41234哎

1003
00:32:20,333 --> 00:32:21,466
他是不是指到这个位置了

1004
00:32:21,466 --> 00:32:22,266
看到了吧

1005
00:32:23,100 --> 00:32:24,166
所以这条指令呢

1006
00:32:24,166 --> 00:32:27,299
是让这个占指针挪到挪动到这个位置

1007
00:32:27,466 --> 00:32:27,966
为什么呢

1008
00:32:27,966 --> 00:32:30,466
因为你看是32位嘛32位就是4字节

1009
00:32:30,466 --> 00:32:31,499
看到了4字节

1010
00:32:31,566 --> 00:32:33,666
所以他加4就让占指针移到这个位置

1011
00:32:33,666 --> 00:32:34,333
然后怎么办呢

1012
00:32:34,333 --> 00:32:36,799
注意你看啊他把这个什么呢

1013
00:32:36,800 --> 00:32:38,766
他把27保存到这个位置了

1014
00:32:38,766 --> 00:32:39,366
看到了吧

1015
00:32:39,366 --> 00:32:41,099
2727是什么

1016
00:32:42,300 --> 00:32:44,933
R7是不是就是我们说的这个

1017
00:32:44,933 --> 00:32:46,733
这个系统调用号啊

1018
00:32:46,733 --> 00:32:47,466
看到了吗

1019
00:32:47,466 --> 00:32:49,333
所以注意啊这个非常重要

1020
00:32:49,366 --> 00:32:51,199
Reserve r保存的是什么

1021
00:32:51,200 --> 00:32:53,200
保存的是系统调用号

1022
00:32:53,400 --> 00:32:56,666
那么我们再看R0到R3

1023
00:32:56,666 --> 00:32:57,666
这个保存的是什么

1024
00:32:57,666 --> 00:32:59,566
这个系统调用所对应的参数

1025
00:33:00,066 --> 00:33:00,499
看到了吧

1026
00:33:00,500 --> 00:33:01,566
这个非常重要啊

1027
00:33:01,566 --> 00:33:03,299
你你记住我说的这些话

1028
00:33:04,200 --> 00:33:05,000
好

1029
00:33:06,933 --> 00:33:08,999
那么完成了这些操作之后呢

1030
00:33:09,000 --> 00:33:10,600
他就实现了一个什么目的呢

1031
00:33:10,600 --> 00:33:12,133
他就实现了把r

1032
00:33:12,533 --> 00:33:15,666
把CPU寄存器中的值保存到了站上啊

1033
00:33:15,666 --> 00:33:16,866
保存到了站指针啊

1034
00:33:16,866 --> 00:33:17,799
保存这个系统

1035
00:33:17,900 --> 00:33:19,900
就这个任务所对应的内核站里了

1036
00:33:20,133 --> 00:33:21,599
然后呢他在这判断一下

1037
00:33:21,600 --> 00:33:23,000
那我们知道这个27是什么

1038
00:33:23,000 --> 00:33:24,366
这个27是系统调用号

1039
00:33:24,366 --> 00:33:26,599
当前的系统调用号等不等于119

1040
00:33:26,766 --> 00:33:29,099
如果不等于119

1041
00:33:29,500 --> 00:33:30,333
你看b e吗

1042
00:33:30,333 --> 00:33:31,566
就是不等

1043
00:33:31,566 --> 00:33:32,799
不等怎么的就跳转

1044
00:33:32,866 --> 00:33:33,699
那跳转到哪了

1045
00:33:33,700 --> 00:33:34,600
就是CSM号

1046
00:33:34,600 --> 00:33:35,966
那这个119是干嘛呢

1047
00:33:35,966 --> 00:33:37,933
这个119是关于这个

1048
00:33:38,400 --> 00:33:41,000
就是信号处理的这么一个系统调用

1049
00:33:41,066 --> 00:33:41,966
但是这个信号处理

1050
00:33:41,966 --> 00:33:43,399
系统调用是由信号处发的

1051
00:33:43,400 --> 00:33:45,100
它不是由用户处发的

1052
00:33:45,133 --> 00:33:47,099
所以R7中保存的这个

1053
00:33:47,333 --> 00:33:49,266
因为我们是通过软中断来陷入的

1054
00:33:49,266 --> 00:33:51,699
所以如果27要等于119的话那就不对

1055
00:33:51,766 --> 00:33:54,299
不对所以必须要判断27等于119

1056
00:33:54,300 --> 00:33:55,733
如果27等于11不对

1057
00:33:55,800 --> 00:33:56,600
否则的话

1058
00:33:56,600 --> 00:33:58,000
又如果27等于119的话

1059
00:33:58,000 --> 00:34:00,166
我就我们就不能走普通的中断分值

1060
00:34:00,166 --> 00:34:01,366
我们要走其他分值

1061
00:34:01,700 --> 00:34:03,400
那么因为我们不讲这个东西嘛

1062
00:34:03,400 --> 00:34:05,400
所以我们就假设他不等啊

1063
00:34:05,400 --> 00:34:06,866
不等就走到下一个

1064
00:34:07,200 --> 00:34:08,266
下一个位置了

1065
00:34:10,400 --> 00:34:11,366
啊下一个位置

1066
00:34:11,400 --> 00:34:15,400
那么然后呢就就执行这个ISOS is system code

1067
00:34:15,400 --> 00:34:17,300
就表示它是一个普通的系统调用

1068
00:34:17,366 --> 00:34:18,166
那么怎么办呢

1069
00:34:18,166 --> 00:34:20,099
那你看那这个是什么

1070
00:34:20,100 --> 00:34:21,500
这个SP现在是什么

1071
00:34:21,500 --> 00:34:23,533
这个SP现在指向的是什么呢

1072
00:34:23,533 --> 00:34:24,366
因为我们知道啊

1073
00:34:24,366 --> 00:34:26,566
这个SP现在指向的就是这个

1074
00:34:26,666 --> 00:34:27,599
这个这个这个这

1075
00:34:27,600 --> 00:34:30,700
个这个这个这个task context的啊

1076
00:34:30,766 --> 00:34:33,566
这个这个数据结构体是个数据结构体

1077
00:34:33,566 --> 00:34:35,333
那我就把这个数据结构体的指针

1078
00:34:35,333 --> 00:34:36,299
付给这个R0

1079
00:34:36,300 --> 00:34:37,100
看到了吧

1080
00:34:37,366 --> 00:34:39,666
把这个结构体的指针付给R0

1081
00:34:40,966 --> 00:34:41,933
然后呢

1082
00:34:42,700 --> 00:34:44,166
呃为什么要把这个数

1083
00:34:44,266 --> 00:34:45,333
结构体指针付给R0呢

1084
00:34:45,333 --> 00:34:46,499
后面我们会说啊

1085
00:34:46,533 --> 00:34:49,699
然后执行这个OSRM A42 system call函斗

1086
00:34:49,700 --> 00:34:50,500
看到了吧

1087
00:34:50,500 --> 00:34:52,066
啊执行这个函数

1088
00:34:53,533 --> 00:34:55,533
那么执行完这个

1089
00:34:56,066 --> 00:34:57,699
执行完这段后边语言我们知道什么

1090
00:34:57,700 --> 00:34:58,533
我们知道了啊

1091
00:34:58,533 --> 00:34:59,099
我们知道了

1092
00:34:59,100 --> 00:35:01,200
我们把所需要的这个参数啊

1093
00:35:01,200 --> 00:35:02,566
都保存在这个系统站了

1094
00:35:02,566 --> 00:35:05,333
这个信这个任务所对应的系统站了

1095
00:35:05,333 --> 00:35:07,733
这个RESERVE 2保存的就是这个参数

1096
00:35:08,166 --> 00:35:10,733
这个锐字2保存之后系统调用的调号

1097
00:35:10,866 --> 00:35:12,933
220到223保存的是什么呢

1098
00:35:12,933 --> 00:35:15,266
是这个系统调用所对应的参数列表

1099
00:35:15,366 --> 00:35:17,533
参数然后我们去调用这个

1100
00:35:18,200 --> 00:35:20,333
32这个这个函数这个函数

1101
00:35:20,466 --> 00:35:22,266
那么我们把这个结构体的指针

1102
00:35:22,266 --> 00:35:24,699
我们把这个结构体的指针付给了这个

1103
00:35:25,566 --> 00:35:26,899
保存到了220中

1104
00:35:28,300 --> 00:35:28,866
好

1105
00:35:28,866 --> 00:35:31,933
下面我们来看一下这个OSM32这个函数

1106
00:35:31,933 --> 00:35:33,099
那么大家看这个是什么

1107
00:35:33,100 --> 00:35:34,266
它的入口参数是什么

1108
00:35:34,266 --> 00:35:35,899
它的入口参数就是这个

1109
00:35:35,900 --> 00:35:37,700
就是这个task context

1110
00:35:37,866 --> 00:35:38,933
那么我们知道啊

1111
00:35:38,933 --> 00:35:42,099
在c语言里这个一个函数的一个函数

1112
00:35:42,100 --> 00:35:44,066
如果一个函数的入口参数

1113
00:35:44,466 --> 00:35:44,933
是什么呢

1114
00:35:44,933 --> 00:35:47,699
是保存在这个R0中R0计算器的

1115
00:35:47,700 --> 00:35:49,300
从R0开始的计算器中

1116
00:35:49,466 --> 00:35:51,266
也就是这个指针就是这个R0

1117
00:35:52,933 --> 00:35:55,666
啊这个这个参数啊这个参数就是R0

1118
00:35:55,666 --> 00:35:57,333
那我们上面说了这个R0是谁

1119
00:35:57,600 --> 00:36:00,366
这个R0是不是就是这个task context的地

1120
00:36:00,366 --> 00:36:03,166
址啊对吧这个task contact的地址

1121
00:36:03,200 --> 00:36:06,133
而我们保存的那个就是系统调用号

1122
00:36:06,133 --> 00:36:09,166
还有那些入口参数啊给系统调

1123
00:36:09,166 --> 00:36:10,466
给系统调的这些入口参数

1124
00:36:10,466 --> 00:36:12,333
是不是都保存在这个task

1125
00:36:12,700 --> 00:36:14,133
contact的结构里头

1126
00:36:14,133 --> 00:36:15,499
所以它这个实际上啊

1127
00:36:15,500 --> 00:36:17,700
实际上就借助于这个地方啊

1128
00:36:18,466 --> 00:36:20,599
这个这这这条语句就完成了什么呢

1129
00:36:20,600 --> 00:36:22,100
就完成了像这个

1130
00:36:22,500 --> 00:36:23,933
像这个啊

1131
00:36:23,933 --> 00:36:25,733
M a 32 system括函斗

1132
00:36:25,733 --> 00:36:27,699
进行参数传递的这么一个功能

1133
00:36:27,700 --> 00:36:28,500
啊

1134
00:36:28,700 --> 00:36:30,800
功能大家看啊在这写的

1135
00:36:30,800 --> 00:36:32,766
传入参数registers

1136
00:36:32,766 --> 00:36:34,866
指向的是task connects结构体

1137
00:36:34,933 --> 00:36:36,966
那么结构体的20-6

1138
00:36:37,100 --> 00:36:39,100
存放着系统调所对应的参数

1139
00:36:39,100 --> 00:36:40,900
resume存放的是什么呢

1140
00:36:40,966 --> 00:36:42,733
系统调换号就是这个地方存放

1141
00:36:42,733 --> 00:36:45,099
系统调换号这些存放的是指针

1142
00:36:45,733 --> 00:36:46,333
啊不

1143
00:36:46,333 --> 00:36:46,933
存存放的

1144
00:36:46,933 --> 00:36:49,133
这这是这个系统调用所对应的参数

1145
00:36:49,400 --> 00:36:50,366
好你看他在这

1146
00:36:50,366 --> 00:36:51,766
所以他在这第一句话是什么

1147
00:36:51,766 --> 00:36:55,099
就是从register这个task context中怎么样

1148
00:36:55,766 --> 00:36:59,933
啊首先找这个task context的result 2这个

1149
00:37:00,366 --> 00:37:01,166
这个内容

1150
00:37:01,166 --> 00:37:02,366
然后把它放到command里

1151
00:37:02,366 --> 00:37:03,199
那这个就是什么

1152
00:37:03,200 --> 00:37:04,300
系统调用编号

1153
00:37:04,400 --> 00:37:05,466
系统调用编号

1154
00:37:05,566 --> 00:37:07,933
然后判断这个编号是是不是有效的

1155
00:37:07,933 --> 00:37:10,166
如果是无效的就直接返回

1156
00:37:10,366 --> 00:37:12,066
那如果是有效的话那这个是什么呢

1157
00:37:12,066 --> 00:37:12,866
这个就是

1158
00:37:12,866 --> 00:37:14,999
系统调用所对应那个函数的数组

1159
00:37:15,366 --> 00:37:16,799
那你看我用这个系统调用号

1160
00:37:16,800 --> 00:37:18,766
到这个函数的数组里去指

1161
00:37:18,800 --> 00:37:21,133
查找那我就可以找到与这个系统对

1162
00:37:21,133 --> 00:37:22,766
调用号所对应的内核的

1163
00:37:22,866 --> 00:37:25,366
内核的这个处理函数的函数指针

1164
00:37:25,700 --> 00:37:26,500
那这个是什么呢

1165
00:37:26,500 --> 00:37:28,000
这个我们后面会说啊

1166
00:37:28,100 --> 00:37:29,533
那么这个函数指定找到了

1167
00:37:29,533 --> 00:37:30,699
那这个函数对应的

1168
00:37:30,700 --> 00:37:31,733
参数到底是几个呢

1169
00:37:31,733 --> 00:37:33,266
我们到这个这个地方去找

1170
00:37:33,333 --> 00:37:33,566
这个

1171
00:37:33,566 --> 00:37:36,133
就是这个函数所对应的参数的个数

1172
00:37:36,166 --> 00:37:36,999
那通过这种方式

1173
00:37:37,000 --> 00:37:38,866
我们就找到这个参数的个数啊

1174
00:37:38,866 --> 00:37:39,666
参数的个数

1175
00:37:40,066 --> 00:37:42,333
然后呢来判断啊合不合理

1176
00:37:42,466 --> 00:37:43,266
超不超

1177
00:37:43,266 --> 00:37:45,666
这个也就是说判断这个n numbers对不对

1178
00:37:45,733 --> 00:37:46,066
对不对

1179
00:37:46,066 --> 00:37:48,199
比如说他因为我们知道他最多是

1180
00:37:48,600 --> 00:37:49,566
他最多是几个

1181
00:37:49,566 --> 00:37:51,666
有一个有一个有一个6个对吧

1182
00:37:51,666 --> 00:37:53,733
6个所以说他不能大于大于这个数

1183
00:37:54,000 --> 00:37:54,800
啊

1184
00:37:57,900 --> 00:37:59,200
那么有了这个之后呢

1185
00:37:59,200 --> 00:38:00,333
你看比如说我

1186
00:38:00,333 --> 00:38:02,133
现在我们这个参数是几个参数

1187
00:38:02,133 --> 00:38:03,199
就是什么

1188
00:38:03,933 --> 00:38:05,399
就是四个参数对吧

1189
00:38:05,600 --> 00:38:06,533
就是四个参数

1190
00:38:06,533 --> 00:38:07,799
那好是四个参数的话

1191
00:38:07,800 --> 00:38:09,133
我就怎么样我就去

1192
00:38:09,733 --> 00:38:10,599
调用这个

1193
00:38:11,266 --> 00:38:12,733
啊我看一下啊

1194
00:38:13,400 --> 00:38:14,300
如果是四个参数

1195
00:38:14,300 --> 00:38:16,133
我就调用相应的这个函数啊

1196
00:38:16,133 --> 00:38:16,999
来进行处理

1197
00:38:20,700 --> 00:38:22,800
那么这个呢就是根据这个

1198
00:38:23,700 --> 00:38:25,166
根据不同的这个

1199
00:38:26,166 --> 00:38:27,266
根据参数的不同

1200
00:38:27,266 --> 00:38:29,799
来调用相应的处理函数来进行处理啊

1201
00:38:33,800 --> 00:38:35,133
啊在这还要说一下呢

1202
00:38:35,133 --> 00:38:36,499
最后一个语句就是什么

1203
00:38:36,500 --> 00:38:37,966
然后处理完了之后啊

1204
00:38:37,966 --> 00:38:39,099
你看这handle是什么

1205
00:38:39,100 --> 00:38:40,533
这个handle就是这个

1206
00:38:40,966 --> 00:38:42,966
就是在这得到的处理函数对吧

1207
00:38:42,966 --> 00:38:43,933
在这处理的函数

1208
00:38:43,933 --> 00:38:46,333
然后呢这个函数处理完了之后呢

1209
00:38:46,333 --> 00:38:49,299
就把结果保存到RET这个旧变量中

1210
00:38:49,300 --> 00:38:50,200
然后把RET呢

1211
00:38:50,200 --> 00:38:52,600
作为参数保存在这个20计算器中

1212
00:38:52,600 --> 00:38:54,133
所以20计算器非常重要

1213
00:38:54,200 --> 00:38:56,200
它既是什么函数调用的入口参数

1214
00:38:56,200 --> 00:38:58,200
又是返回函数返回的这个

1215
00:38:58,200 --> 00:38:59,866
返回结果的保存的位置

1216
00:39:02,733 --> 00:39:04,133
那么完成这一切之后呢

1217
00:39:04,133 --> 00:39:06,499
你看刚才我们通过SVC啊

1218
00:39:07,000 --> 00:39:07,933
进入了内核

1219
00:39:07,933 --> 00:39:08,999
那么再回到什么呢

1220
00:39:09,000 --> 00:39:10,866
你看这个地方这个地方返

1221
00:39:10,866 --> 00:39:11,866
回啊这个地方

1222
00:39:12,533 --> 00:39:14,766
啊这个地方返回这个地方返回到哪呢

1223
00:39:14,766 --> 00:39:16,733
是不是就返回我们刚才那汇编语言

1224
00:39:16,900 --> 00:39:19,266
然后那个汇编语言再返回就怎么样呢

1225
00:39:19,266 --> 00:39:21,799
由用内核态就返回到了用户态

1226
00:39:22,200 --> 00:39:22,966
大家看啊

1227
00:39:22,966 --> 00:39:24,299
这个函数执行结束后

1228
00:39:24,300 --> 00:39:27,400
就是这个RM A32I Systemcore handle

1229
00:39:27,400 --> 00:39:31,366
执行结束后呢再返回到OS except SWI handle

1230
00:39:31,600 --> 00:39:32,600
那么这个

1231
00:39:33,166 --> 00:39:35,199
except SW handle后面的代码呢

1232
00:39:35,200 --> 00:39:38,500
用于恢复用户用户模式的现场

1233
00:39:38,933 --> 00:39:41,699
然后呢就返回了返回到用户态了

1234
00:39:44,100 --> 00:39:44,700
好

1235
00:39:44,700 --> 00:39:46,333
那么后面我们说的是什么呢

1236
00:39:46,333 --> 00:39:48,199
后面我们说的就是对这个

1237
00:39:48,800 --> 00:39:49,900
这个指针数组

1238
00:39:50,066 --> 00:39:51,566
这个指针数组的初始化

1239
00:39:51,566 --> 00:39:53,499
那么如何对这个指针数组的初始化

1240
00:39:53,500 --> 00:39:54,533
我们知道是在

1241
00:39:54,733 --> 00:39:56,499
操作系统内科启动的时候

1242
00:39:56,600 --> 00:39:58,166
对这个啊

1243
00:39:58,166 --> 00:39:59,399
global system CO handle

1244
00:39:59,400 --> 00:40:01,700
这个指针数组来进行初始化的

1245
00:40:02,366 --> 00:40:03,066
那我们看一下

1246
00:40:03,066 --> 00:40:04,499
首先看一下这个数据结构

1247
00:40:04,566 --> 00:40:06,866
那第一个数据结构就是system cloud number

1248
00:40:06,866 --> 00:40:08,166
那么这个表示的是什么呢

1249
00:40:08,166 --> 00:40:09,599
就是表示这个系统中

1250
00:40:09,600 --> 00:40:12,800
整个这个Letos中支持的操作系统数

1251
00:40:13,133 --> 00:40:15,599
那么这个be词呢是4表示的是什么呢

1252
00:40:15,600 --> 00:40:17,166
因为是这样啊因为

1253
00:40:17,700 --> 00:40:19,066
每一个它表示的是什么呢

1254
00:40:19,066 --> 00:40:20,533
就是跟后面这个有关系啊

1255
00:40:20,533 --> 00:40:21,566
跟后面我们知道

1256
00:40:21,600 --> 00:40:23,866
在Letos中任何一个操作系统

1257
00:40:23,866 --> 00:40:25,866
它最多只有6个参数啊

1258
00:40:25,866 --> 00:40:26,666
六个参数

1259
00:40:26,933 --> 00:40:28,933
六个参数的话它当然这个

1260
00:40:29,133 --> 00:40:30,333
嗯所以说呢

1261
00:40:30,800 --> 00:40:32,733
这个number如果要是4的话

1262
00:40:32,733 --> 00:40:34,899
4个比特位的话就是最多有16个参数

1263
00:40:34,900 --> 00:40:36,766
它不需要这么多啊不需要这么多

1264
00:40:36,766 --> 00:40:39,333
它现在目前为止只支持6个参数啊

1265
00:40:39,866 --> 00:40:40,866
只是六个参数

1266
00:40:41,000 --> 00:40:42,566
所以说呢但是这个有

1267
00:40:42,566 --> 00:40:44,533
有一定赋予了一定赋予了

1268
00:40:44,600 --> 00:40:47,333
那么我们知道在计算机中呢一个比特

1269
00:40:47,866 --> 00:40:48,966
一个bet是8位

1270
00:40:48,966 --> 00:40:51,399
所以说一个bet就可以保存两个

1271
00:40:51,500 --> 00:40:53,533
两个系统调用的参数个数

1272
00:40:53,666 --> 00:40:56,066
所以它这个地方后面这个都是为你看

1273
00:40:56,066 --> 00:40:57,133
这个2就表示什么呢

1274
00:40:57,133 --> 00:40:58,266
一个字一个字节

1275
00:40:58,266 --> 00:41:00,799
可以表示两个系统调用的这个参数

1276
00:41:00,866 --> 00:41:02,766
那在Letos中是怎么做的呢

1277
00:41:02,766 --> 00:41:04,499
后面我会说啊后面会说

1278
00:41:04,600 --> 00:41:06,133
那这个就是这个

1279
00:41:06,733 --> 00:41:08,199
系统调用的函数指针数组

1280
00:41:08,200 --> 00:41:09,000
那这个是什么呢

1281
00:41:09,000 --> 00:41:10,200
这个就是这个

1282
00:41:10,400 --> 00:41:11,200
每一个

1283
00:41:11,300 --> 00:41:13,000
系统调用所对应的这个参数个数

1284
00:41:13,000 --> 00:41:14,366
保存在这啊保存在这

1285
00:41:14,500 --> 00:41:15,733
我给大家举个例子啊

1286
00:41:15,733 --> 00:41:17,266
比如说我们现在这个系统

1287
00:41:17,400 --> 00:41:19,266
系统中支持80个系统调用

1288
00:41:19,266 --> 00:41:21,933
那我问你这个这个n number这个

1289
00:41:22,100 --> 00:41:24,100
这个数度需要几几个bet呢

1290
00:41:25,166 --> 00:41:28,399
是不是是需要80/2=40个bet对吧

1291
00:41:28,400 --> 00:41:28,900
因为什么呢

1292
00:41:28,900 --> 00:41:31,400
因为我们刚才说了这一个系统调所

1293
00:41:31,566 --> 00:41:32,766
只一个系统调所

1294
00:41:32,766 --> 00:41:34,533
对应的参数个数只是4个位置

1295
00:41:34,533 --> 00:41:35,266
4个位

1296
00:41:35,266 --> 00:41:38,466
那一个一个比特呢就是一个bet啊

1297
00:41:38,466 --> 00:41:39,666
一个字节就是两

1298
00:41:39,666 --> 00:41:41,166
两个能表示两个系统调

1299
00:41:41,166 --> 00:41:44,299
那我们有80个那只需要四四十个

1300
00:41:44,333 --> 00:41:46,199
40个bet就可以了对吧

1301
00:41:46,200 --> 00:41:47,466
40个字节就可以了

1302
00:41:47,733 --> 00:41:49,266
所以他们是这样的一个关系

1303
00:41:51,700 --> 00:41:53,500
那么它是怎么初始化的呢

1304
00:41:53,600 --> 00:41:56,366
那就是用这个lost modulet红啊

1305
00:41:56,366 --> 00:41:58,933
lost modulet红呢用于将系统调用

1306
00:41:59,366 --> 00:42:01,899
初始化函数OS sys

1307
00:42:01,933 --> 00:42:04,266
呃OS system框handle emit

1308
00:42:04,266 --> 00:42:05,733
注册到启动框架中

1309
00:42:05,733 --> 00:42:08,666
那么具体的该红将初始化函数呢

1310
00:42:08,666 --> 00:42:12,299
加入到内核影像的这个red data emit区

1311
00:42:12,500 --> 00:42:13,366
那么内核呢

1312
00:42:13,366 --> 00:42:15,466
在加载的时候会搜索red

1313
00:42:15,800 --> 00:42:18,666
only data init中的所有条目

1314
00:42:18,866 --> 00:42:21,966
并按照优先级呢对它们进行加载

1315
00:42:22,100 --> 00:42:24,900
那么我们这个内核的这个内核

1316
00:42:24,900 --> 00:42:26,600
这个系统调用它的优先级是8

1317
00:42:26,733 --> 00:42:28,566
那么这个模块的优先级越小

1318
00:42:28,566 --> 00:42:29,999
就越先加载啊

1319
00:42:30,100 --> 00:42:32,366
那么它大具体就是这样的一个情况啊

1320
00:42:32,366 --> 00:42:33,899
这是lost mode init

1321
00:42:33,933 --> 00:42:35,133
你看这个就是

1322
00:42:35,600 --> 00:42:36,000
这个是啥

1323
00:42:36,000 --> 00:42:38,200
这个就是这个系统调用的初始化函数

1324
00:42:38,200 --> 00:42:39,300
对吧初始化函数

1325
00:42:39,466 --> 00:42:41,499
然后呢这个是他的这个什么优先级

1326
00:42:41,500 --> 00:42:43,566
看到了吗这优先级他把优先级定为8

1327
00:42:43,700 --> 00:42:45,533
那么这个就是这个红的展开啊

1328
00:42:45,533 --> 00:42:46,066
红的展开

1329
00:42:46,066 --> 00:42:47,799
比如说你刚才把它展开扔这个

1330
00:42:47,800 --> 00:42:48,766
那么就是这个

1331
00:42:49,066 --> 00:42:49,866
最后呢就是这个

1332
00:42:49,866 --> 00:42:52,266
就是说整个这个玩意被这这这段

1333
00:42:52,266 --> 00:42:52,766
代替了

1334
00:42:52,766 --> 00:42:54,966
那这段什么就是我就是刚才说的

1335
00:42:55,200 --> 00:42:56,733
他呢把这个条目

1336
00:42:56,766 --> 00:42:59,333
他把这个条目啊也就是说把这个

1337
00:43:01,066 --> 00:43:02,199
他把这条目啊

1338
00:43:03,366 --> 00:43:04,933
啊就是这个互函数

1339
00:43:04,933 --> 00:43:05,866
这个互函数啊

1340
00:43:05,866 --> 00:43:07,566
这个互函这个互函数就是这个

1341
00:43:07,700 --> 00:43:07,966
啊

1342
00:43:07,966 --> 00:43:08,999
这个这个看到了吧

1343
00:43:09,000 --> 00:43:11,466
写到了这个read only data ED的这个区

1344
00:43:11,600 --> 00:43:13,300
那么当啊系统调

1345
00:43:13,300 --> 00:43:14,766
当这个操作系统初始化的时候

1346
00:43:14,766 --> 00:43:16,166
它就会读这个区

1347
00:43:16,166 --> 00:43:17,699
然后呢执行这个函数

1348
00:43:17,766 --> 00:43:18,866
执行这个勾子函数

1349
00:43:18,866 --> 00:43:20,933
所以这个实际上是个勾子函数啊

1350
00:43:21,800 --> 00:43:23,666
那么当那么我们下面看一下

1351
00:43:23,666 --> 00:43:25,333
这个函数是怎么工作的啊

1352
00:43:25,333 --> 00:43:26,133
这个函数怎么工作

1353
00:43:26,133 --> 00:43:29,099
大家看这个OS systemcard handoinit这个函数

1354
00:43:29,100 --> 00:43:31,566
那我们看在这里头呢定义了一个红

1355
00:43:31,700 --> 00:43:34,200
看到第一个叫systemcard handle define

1356
00:43:34,200 --> 00:43:35,000
看到了define

1357
00:43:35,500 --> 00:43:37,366
那么这个define呢包含了这么几个参数

1358
00:43:37,366 --> 00:43:38,533
一个是ID啊

1359
00:43:38,533 --> 00:43:39,499
一个是function

1360
00:43:39,666 --> 00:43:40,399
一个是time

1361
00:43:40,400 --> 00:43:41,933
一个是number arguments

1362
00:43:41,933 --> 00:43:44,499
number arguments那么这个ID是什么呢

1363
00:43:44,500 --> 00:43:46,733
这个ID就是系统调用号

1364
00:43:47,533 --> 00:43:48,399
那function

1365
00:43:48,400 --> 00:43:50,700
就是这个系统调用所对应的这个

1366
00:43:50,733 --> 00:43:52,766
什么呢所对应的内核函数

1367
00:43:53,066 --> 00:43:54,366
看到了内核函数

1368
00:43:54,466 --> 00:43:56,099
那么这个our type是什么呢

1369
00:43:56,100 --> 00:43:57,333
就是返回啊这个

1370
00:43:57,333 --> 00:43:58,899
这个函数的返回值类型

1371
00:43:59,200 --> 00:44:01,733
n numbers a n a number agument

1372
00:44:01,733 --> 00:44:03,799
就是这个函数所对应的这个

1373
00:44:03,933 --> 00:44:05,099
输入口参数

1374
00:44:05,400 --> 00:44:06,733
所以你看啊他在这是什么

1375
00:44:06,733 --> 00:44:07,966
你看在这看到了吧

1376
00:44:08,066 --> 00:44:10,399
就是说如果这个系统调用号小于

1377
00:44:10,700 --> 00:44:12,600
啊整个系统中的最大效调用号

1378
00:44:12,600 --> 00:44:14,400
表示这个是有效的系统调用

1379
00:44:14,400 --> 00:44:16,366
然后我就把这个focus放到这个

1380
00:44:16,533 --> 00:44:18,466
global system框handle这个数组里了

1381
00:44:18,466 --> 00:44:19,133
看到了吧

1382
00:44:19,133 --> 00:44:20,733
然后呢通过这个操作

1383
00:44:20,866 --> 00:44:22,866
通过这个操作把这个agumen看到了吧

1384
00:44:22,866 --> 00:44:24,866
把这个系统调用的这个输入

1385
00:44:25,166 --> 00:44:27,499
看到吧入口参数的个数放到了这个

1386
00:44:27,666 --> 00:44:30,166
global system call number阿哥们这个输入里了

1387
00:44:30,166 --> 00:44:30,966
看到了吧

1388
00:44:31,166 --> 00:44:32,466
啊那这个地方是2

1389
00:44:32,466 --> 00:44:34,666
所以id除以2就放在这里了

1390
00:44:34,700 --> 00:44:37,066
然后呢可以放到低位和高位啊

1391
00:44:37,266 --> 00:44:38,299
那好我们关键看这儿

1392
00:44:38,300 --> 00:44:40,866
这有个system call look up点h

1393
00:44:40,933 --> 00:44:42,666
那我们在这个点h文件里

1394
00:44:42,666 --> 00:44:45,199
你将你将会看到全都是这个system call

1395
00:44:45,400 --> 00:44:46,566
handle define

1396
00:44:46,566 --> 00:44:47,933
system call handle define

1397
00:44:49,333 --> 00:44:50,366
好这就是这个

1398
00:44:50,366 --> 00:44:51,499
你看这就是这个

1399
00:44:51,533 --> 00:44:52,333
看到了吧

1400
00:44:52,766 --> 00:44:54,899
这个就是system call look up点h

1401
00:44:54,933 --> 00:44:56,566
这个文件的这个内容

1402
00:44:56,700 --> 00:44:58,300
那你看这个是什么意思呢

1403
00:44:58,300 --> 00:45:00,133
再回过头来看你看这个是什么

1404
00:45:00,133 --> 00:45:02,299
你看这是这样首先一个红定义

1405
00:45:02,300 --> 00:45:03,966
然后把这个inklude是什么

1406
00:45:04,000 --> 00:45:04,566
inklude就是

1407
00:45:04,566 --> 00:45:06,533
把这个文件的内容全插在这个位置

1408
00:45:06,933 --> 00:45:07,933
那你就可以想象啊

1409
00:45:07,933 --> 00:45:10,399
首先是编译器的编译的时候

1410
00:45:10,400 --> 00:45:11,133
宏展开的时候

1411
00:45:11,133 --> 00:45:13,166
他首先把刚才我看到那些

1412
00:45:13,333 --> 00:45:15,699
这个system call handle define插到这

1413
00:45:15,766 --> 00:45:17,199
然后用它进行宏展开

1414
00:45:17,200 --> 00:45:19,333
那你想想是不是都是一堆复制语句啊

1415
00:45:19,333 --> 00:45:22,299
对这个global system call和global system call

1416
00:45:23,066 --> 00:45:25,566
啊global system handle和global system CON number

1417
00:45:25,566 --> 00:45:27,766
阿根廷斯这两个数字的一顿初始化

1418
00:45:27,766 --> 00:45:28,566
对吧

1419
00:45:29,166 --> 00:45:30,299
好吧就是初始化

1420
00:45:30,333 --> 00:45:31,133
那么我们看一下

1421
00:45:31,133 --> 00:45:32,999
比如说在这里头有个呃

1422
00:45:33,000 --> 00:45:34,400
这个就是这个system

1423
00:45:34,933 --> 00:45:36,766
这个system infer这个系统调用

1424
00:45:36,766 --> 00:45:37,499
系统调用号

1425
00:45:37,500 --> 00:45:39,466
这个就是处理真正的内核处理函数

1426
00:45:39,466 --> 00:45:40,766
这是它的返回值类型

1427
00:45:40,933 --> 00:45:43,299
那这个呢你看它表示它有一个参数

1428
00:45:43,900 --> 00:45:44,666
看到了吧

1429
00:45:44,666 --> 00:45:46,899
好然后它呢就具体在内核

1430
00:45:46,900 --> 00:45:48,200
就运行内核的程序

1431
00:45:48,200 --> 00:45:50,166
然后来返回一些系统信息

1432
00:45:52,733 --> 00:45:54,133
那我们看一下啊

1433
00:45:54,266 --> 00:45:55,333
最后我们看一下什么

1434
00:45:55,333 --> 00:45:56,166
这个很好理解

1435
00:45:56,166 --> 00:45:58,066
那最后呢我们看一下这个海

1436
00:45:58,066 --> 00:45:59,333
这个地方是怎么回事

1437
00:45:59,733 --> 00:46:01,399
这个地方是代表什么东西啊

1438
00:46:01,400 --> 00:46:02,866
大家可以先思考一下啊

1439
00:46:02,866 --> 00:46:03,999
大家先思考一下

1440
00:46:04,300 --> 00:46:05,533
那你想一想啊

1441
00:46:05,600 --> 00:46:06,933
我有一个ID对吧

1442
00:46:06,933 --> 00:46:07,699
我有个ID

1443
00:46:07,700 --> 00:46:08,966
比如说我们后面给大家

1444
00:46:08,966 --> 00:46:10,466
下面我给大家举个例子啊

1445
00:46:10,466 --> 00:46:11,566
给大家举个例子

1446
00:46:12,266 --> 00:46:12,299
啊

1447
00:46:12,300 --> 00:46:14,366
那么在这里头就要用到这几个红啊

1448
00:46:14,366 --> 00:46:15,133
这几个红

1449
00:46:15,133 --> 00:46:16,266
首先呢我们以

1450
00:46:16,266 --> 00:46:19,666
系统调用编号为0和一的函数为例啊

1451
00:46:19,900 --> 00:46:20,766
系统调换编号

1452
00:46:20,766 --> 00:46:23,099
也就是性调号是0和一的函数为例

1453
00:46:23,266 --> 00:46:24,366
那么是他们呢

1454
00:46:24,466 --> 00:46:26,099
比如说系统调号为0的

1455
00:46:26,266 --> 00:46:27,566
输入参数有两个

1456
00:46:27,566 --> 00:46:30,266
输性调号为一的输入参数有4个

1457
00:46:30,266 --> 00:46:30,999
那么这个2和

1458
00:46:31,000 --> 00:46:36,000
4对应的对应的2G编码分别是0010和0100

1459
00:46:36,100 --> 00:46:38,366
那么他们的他们的ID呢

1460
00:46:39,500 --> 00:46:41,133
你看啊我们就用怎么样呢

1461
00:46:41,133 --> 00:46:43,166
我们用ID除以这个

1462
00:46:43,400 --> 00:46:46,066
啊除以这个这个这个红啊这个红

1463
00:46:46,400 --> 00:46:47,300
那这个红是什么

1464
00:46:47,300 --> 00:46:48,100
这这是2

1465
00:46:48,100 --> 00:46:49,733
所以无论是0还是一

1466
00:46:49,733 --> 00:46:51,766
我除以这个红是不是都等于0啊

1467
00:46:52,266 --> 00:46:53,066
对吧

1468
00:46:53,933 --> 00:46:54,766
啊都是0

1469
00:46:54,766 --> 00:46:55,899
所以说我们就可以知道

1470
00:46:55,900 --> 00:46:57,133
我们根据这个系统调用号

1471
00:46:57,133 --> 00:46:58,533
我们就可以找到什么呢

1472
00:46:58,533 --> 00:47:00,766
我们就可以找到这个系统调用所

1473
00:47:00,900 --> 00:47:03,733
在这个arguments所对应的这个位置啊

1474
00:47:03,733 --> 00:47:04,699
这两个都是

1475
00:47:04,700 --> 00:47:05,600
都对应的是

1476
00:47:05,700 --> 00:47:08,133
这个number arguments的第0号元素

1477
00:47:08,466 --> 00:47:09,199
啊低0号元素

1478
00:47:09,200 --> 00:47:09,766
于是呢

1479
00:47:09,766 --> 00:47:12,599
在这个一开始的时候这个number agment是0

1480
00:47:12,900 --> 00:47:14,366
它的内容是8个0

1481
00:47:14,666 --> 00:47:15,966
好然后我怎么办呢

1482
00:47:15,966 --> 00:47:17,733
然后所以这个地方是0对吧

1483
00:47:17,733 --> 00:47:19,399
这个地方是0 好

1484
00:47:19,400 --> 00:47:22,666
现在比如说ID是00与上一是几

1485
00:47:22,766 --> 00:47:24,366
0与上一是0对不对

1486
00:47:24,366 --> 00:47:27,066
对吧那好如果它是0的话那怎么样

1487
00:47:27,800 --> 00:47:29,533
如果他是0号我就执行什么

1488
00:47:29,533 --> 00:47:31,499
我就执行这个操作对吧

1489
00:47:31,733 --> 00:47:34,966
对吧我们在cn里学过判断这个式子

1490
00:47:34,966 --> 00:47:35,499
等不等于一

1491
00:47:35,500 --> 00:47:36,466
如果等于一只用这个

1492
00:47:36,466 --> 00:47:36,999
如果不等于一

1493
00:47:37,000 --> 00:47:38,266
就执行这个冒号后面这个

1494
00:47:38,266 --> 00:47:39,166
所以怎么样呢

1495
00:47:39,866 --> 00:47:41,533
你看啊如果0

1496
00:47:41,766 --> 00:47:43,399
如果系统电话号为0的话呢

1497
00:47:43,400 --> 00:47:44,733
他和一一相遇得0

1498
00:47:44,733 --> 00:47:45,366
所以怎么样

1499
00:47:45,366 --> 00:47:46,766
他就不不左移啊

1500
00:47:46,766 --> 00:47:47,399
他就不左移

1501
00:47:47,400 --> 00:47:49,166
所以说我们这时候怎么样

1502
00:47:49,166 --> 00:47:51,899
我们你看他原来是零零零零做霍

1503
00:47:51,966 --> 00:47:54,899
那这样的话就变成00000010

1504
00:47:54,900 --> 00:47:56,066
看到了吧0010

1505
00:47:56,700 --> 00:47:56,733
好

1506
00:47:56,733 --> 00:48:00,099
那如果啊如果这个ID是一的话怎么办

1507
00:48:00,100 --> 00:48:02,100
ID和一相与就等于一对

1508
00:48:02,100 --> 00:48:04,333
吧那好那是不是就执行这个对吧

1509
00:48:04,333 --> 00:48:04,999
执行这个

1510
00:48:05,000 --> 00:48:05,933
那这是什么意思呢

1511
00:48:05,933 --> 00:48:08,399
这个是你看我们说过了啊

1512
00:48:08,400 --> 00:48:10,133
我们说系统调用一

1513
00:48:10,133 --> 00:48:11,933
它的这个入口参数有4个

1514
00:48:11,933 --> 00:48:12,933
所以是这个

1515
00:48:12,933 --> 00:48:15,966
这个number argument就是0100对吧

1516
00:48:15,966 --> 00:48:17,366
0100 那这是什么意思

1517
00:48:17,366 --> 00:48:19,199
把0100左移几位呢

1518
00:48:19,766 --> 00:48:21,199
是不是左移四位啊对吧

1519
00:48:21,200 --> 00:48:22,166
那它就变成什么了

1520
00:48:22,166 --> 00:48:24,866
我把0100左移四位就变成了这个

1521
00:48:25,566 --> 00:48:26,699
啊就变成了什么呢

1522
00:48:26,700 --> 00:48:28,333
01000000对吧

1523
00:48:28,333 --> 00:48:29,699
然后再和什么呢

1524
00:48:29,700 --> 00:48:30,966
再和现在的这个阿哥

1525
00:48:30,966 --> 00:48:33,466
嗯阿哥们就是00000010

1526
00:48:33,466 --> 00:48:35,366
那我就一箱货就变成了什么

1527
00:48:35,366 --> 00:48:37,533
就变成了01000010

1528
00:48:37,533 --> 00:48:38,199
看到了吧

1529
00:48:38,200 --> 00:48:39,666
所以啊这个

1530
00:48:40,133 --> 00:48:42,333
global system call number arguments 0

1531
00:48:42,333 --> 00:48:44,166
这个位置就保存了什么呢

1532
00:48:44,166 --> 00:48:46,699
ID号分别是0和一的这两个

1533
00:48:46,700 --> 00:48:48,133
系统调用的这个号

1534
00:48:48,300 --> 00:48:50,166
系统调用所对应的这个参数个数

1535
00:48:50,166 --> 00:48:52,199
那么这个是1号这个是0号

1536
00:48:52,200 --> 00:48:56,066
所以01那依次类推2345等等等等

1537
00:48:56,600 --> 00:48:58,966
所以大家看它是说本质的是什么

1538
00:48:58,966 --> 00:49:01,266
本质上就是根据基偶性

1539
00:49:01,366 --> 00:49:03,799
根据这个系统调用编号的基偶性

1540
00:49:03,900 --> 00:49:05,333
来把它放到这个

1541
00:49:05,466 --> 00:49:07,799
这个number arguments的低位还是高位

1542
00:49:07,800 --> 00:49:09,500
如果它是偶数我就放在低位

1543
00:49:09,500 --> 00:49:11,533
如果它是奇数我就放在高位

1544
00:49:11,966 --> 00:49:13,099
那么至此呢

1545
00:49:13,300 --> 00:49:14,466
我们就把

1546
00:49:14,466 --> 00:49:15,166
就完成了

1547
00:49:15,166 --> 00:49:17,466
对这个系统调用的这么一个完整介绍

1548
00:49:17,533 --> 00:49:18,566
啊谢谢大家

