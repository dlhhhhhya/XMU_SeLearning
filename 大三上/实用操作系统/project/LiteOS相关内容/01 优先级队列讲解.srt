1
00:00:02,200 --> 00:00:05,166
各位同学大家好我们现在继续介绍

2
00:00:05,800 --> 00:00:08,733
第二个非常重要的数据结构类型

3
00:00:08,733 --> 00:00:10,766
那么叫做优先级队列

4
00:00:10,966 --> 00:00:13,066
那么也称为priority run q

5
00:00:17,200 --> 00:00:19,066
那么关于Pro的q中

6
00:00:19,400 --> 00:00:21,500
关于右侵袭队列的原代码呢

7
00:00:21,500 --> 00:00:24,700
主要在主要分布在以下这两个

8
00:00:25,166 --> 00:00:26,799
啊原代码文件中

9
00:00:30,533 --> 00:00:33,133
那么我们首先来看一下这个proto run q

10
00:00:33,133 --> 00:00:35,999
非常重要的一些基础数据结构啊

11
00:00:36,000 --> 00:00:37,100
基础数据结构

12
00:00:37,900 --> 00:00:38,966
那么第一个

13
00:00:39,666 --> 00:00:42,199
啊第一个比较重要的结构是谁呢

14
00:00:42,200 --> 00:00:45,100
就是这个OS Partyq number

15
00:00:45,200 --> 00:00:46,733
那么我们看这有个32

16
00:00:46,733 --> 00:00:47,933
这32表示什么意思呢

17
00:00:47,933 --> 00:00:49,466
这32表示的是

18
00:00:49,600 --> 00:00:50,733
我们现在呢

19
00:00:50,733 --> 00:00:54,199
在我们light OS系统中呢有32个优先机

20
00:00:54,866 --> 00:00:55,599
啊任务

21
00:00:55,600 --> 00:00:57,600
proto Pro优先级队列呢

22
00:00:57,600 --> 00:00:59,166
主要是用来存储什么呢

23
00:00:59,166 --> 00:01:01,366
就是说在系统中的

24
00:01:02,166 --> 00:01:03,533
任务不同任务的

25
00:01:03,533 --> 00:01:07,266
那么在Letos中一共支持32个优先级

26
00:01:07,266 --> 00:01:09,966
所以说这个proto run q呢就有32位

27
00:01:10,400 --> 00:01:12,133
那么就有3就是32

28
00:01:12,333 --> 00:01:14,666
那么现在我们再看第二个红叫做

29
00:01:14,933 --> 00:01:17,399
priority q priority beat

30
00:01:17,666 --> 00:01:19,399
那么这个呢是我们数一下

31
00:01:19,400 --> 00:01:20,766
这一共是8位

32
00:01:21,266 --> 00:01:22,199
这一共是八位

33
00:01:22,366 --> 00:01:24,333
那么一共是八位数啊

34
00:01:24,333 --> 00:01:26,266
每一个八位16斤之数

35
00:01:26,366 --> 00:01:27,166
那么

36
00:01:27,266 --> 00:01:30,166
由于是每个16斤之数是四四个比特

37
00:01:30,166 --> 00:01:33,366
所以一共八八个16斤之数就是32位

38
00:01:33,766 --> 00:01:37,099
32个比特那正好呢与这个32所相对应

39
00:01:37,100 --> 00:01:38,333
与这个32相对应

40
00:01:38,933 --> 00:01:40,366
那么我们再看下一个

41
00:01:40,733 --> 00:01:43,899
叫做g啊那这个g是什么的缩写呢

42
00:01:43,900 --> 00:01:46,733
就是global的缩写global priority q list

43
00:01:46,866 --> 00:01:49,966
那么这个Pro g priority q list是什么东西呢

44
00:01:49,966 --> 00:01:52,399
是这样的一个数组啊这个数组

45
00:01:53,066 --> 00:01:53,599
是指向这

46
00:01:53,600 --> 00:01:54,500
个数组的指针

47
00:01:54,500 --> 00:01:55,966
后面我们会看初始化的时候

48
00:01:55,966 --> 00:01:57,466
他就指向这个数组的指针

49
00:01:57,666 --> 00:01:59,866
那么这个数组呢总共包含什么呢

50
00:01:59,866 --> 00:02:01,399
因为这有32个优先级

51
00:02:01,533 --> 00:02:03,533
所以这一共是有32个

52
00:02:04,366 --> 00:02:06,599
32个元素这个数独有32个元素

53
00:02:06,700 --> 00:02:08,266
每一个元素是一个什么类型的

54
00:02:08,266 --> 00:02:08,799
每一个元素

55
00:02:08,800 --> 00:02:11,133
都是一个双向链表的投掷帧啊

56
00:02:11,133 --> 00:02:12,166
也就是说这个地方

57
00:02:12,166 --> 00:02:14,133
这个是一个双向链表投掷帧

58
00:02:14,333 --> 00:02:15,599
这个是一个双向列表投掷帧

59
00:02:15,600 --> 00:02:17,200
每一个都是一个双向列表投掷帧

60
00:02:17,200 --> 00:02:19,666
那你可以想象那么整个啊

61
00:02:20,266 --> 00:02:21,333
因为它这个头指针

62
00:02:21,333 --> 00:02:22,699
所以这每一个

63
00:02:22,700 --> 00:02:24,466
头指针都指向着一个对列

64
00:02:24,666 --> 00:02:26,299
都指向着一个双向循环对列

65
00:02:26,300 --> 00:02:27,266
双向循环对列

66
00:02:27,400 --> 00:02:28,600
那么具体的来说

67
00:02:28,600 --> 00:02:30,466
这个双向循环对列里挂的是什么呢

68
00:02:30,466 --> 00:02:32,166
就是task CB TCB

69
00:02:32,366 --> 00:02:33,599
就是任务控制框

70
00:02:34,366 --> 00:02:35,166
任务控制块

71
00:02:35,566 --> 00:02:37,099
那么我们知道任务进行

72
00:02:37,166 --> 00:02:38,799
在对任务进行调度的时候

73
00:02:38,800 --> 00:02:40,533
那么实际上就是在这个

74
00:02:40,766 --> 00:02:42,333
就是就是在这个

75
00:02:43,266 --> 00:02:45,399
就是在这个就是paradise q list中

76
00:02:45,400 --> 00:02:46,700
去寻找最高优先

77
00:02:46,700 --> 00:02:48,966
当前系统中最高优先级的这个TCB

78
00:02:49,100 --> 00:02:50,266
然后让它来运行的

79
00:02:51,066 --> 00:02:53,266
好那我们再看还有一个数据

80
00:02:53,266 --> 00:02:54,799
还有一个数据类型叫做

81
00:02:54,900 --> 00:02:56,800
global priority q beatmap

82
00:02:56,966 --> 00:02:58,266
那么这个beatmap是什么

83
00:02:58,266 --> 00:02:59,599
也是个32比特的数

84
00:02:59,733 --> 00:03:02,199
好我现在为什么需要这个东西呢

85
00:03:02,200 --> 00:03:03,733
为什么需要这个beatmap呢

86
00:03:03,766 --> 00:03:05,166
主要就是为了

87
00:03:06,100 --> 00:03:07,266
像我刚才说的一样啊

88
00:03:07,266 --> 00:03:08,266
像我刚才说的一样

89
00:03:08,333 --> 00:03:09,399
一个很重要的

90
00:03:09,566 --> 00:03:11,399
一个很重一类很重要的操作

91
00:03:11,400 --> 00:03:13,733
就是在这个优先级队列中寻找

92
00:03:13,800 --> 00:03:14,900
当前最高优先

93
00:03:14,900 --> 00:03:16,300
处于最高优先级的任务

94
00:03:16,566 --> 00:03:18,333
那么如果没有这个btmile的话

95
00:03:18,333 --> 00:03:19,133
我们怎么做

96
00:03:19,366 --> 00:03:21,199
我们是不是要用一个复循环

97
00:03:21,466 --> 00:03:23,399
循环每一个数度元素

98
00:03:23,400 --> 00:03:23,800
比如说哎

99
00:03:23,800 --> 00:03:25,800
我首先看一下最高优先级的这个

100
00:03:25,800 --> 00:03:26,800
链表空不空

101
00:03:26,866 --> 00:03:27,599
如果不空

102
00:03:27,600 --> 00:03:29,533
那么表示这个链表中有一个元

103
00:03:29,533 --> 00:03:30,666
素可以运行了

104
00:03:30,733 --> 00:03:31,766
然后如果空的话

105
00:03:31,766 --> 00:03:33,366
我们要寻找下一个元素

106
00:03:33,900 --> 00:03:35,266
在空我再寻找下一个元素

107
00:03:35,266 --> 00:03:36,599
所以这是一个four循环啊

108
00:03:36,600 --> 00:03:40,200
是一个o n复杂度的这么一个算法啊

109
00:03:40,200 --> 00:03:41,000
寻找

110
00:03:41,933 --> 00:03:42,966
最高优先级任务

111
00:03:42,966 --> 00:03:44,799
那它是一个o n复杂度的算法

112
00:03:44,800 --> 00:03:47,066
但是有了这个beat map之后啊

113
00:03:47,066 --> 00:03:48,266
我们就可以把这个算法

114
00:03:48,266 --> 00:03:50,133
由o n复杂度变成O1复杂度

115
00:03:50,133 --> 00:03:51,366
所以降低了这个

116
00:03:51,866 --> 00:03:53,533
这个这个寻找时间

117
00:03:53,533 --> 00:03:54,933
那么这个beat my是什么意思呢

118
00:03:54,933 --> 00:03:56,866
这个beat my是一个32位的

119
00:03:57,066 --> 00:03:58,566
32位的这么一个数啊

120
00:03:58,566 --> 00:04:00,466
32位的这么一个数啊

121
00:04:00,533 --> 00:04:01,599
32位这么一个数

122
00:04:01,600 --> 00:04:03,700
那么每一个数呢对应着一个

123
00:04:04,666 --> 00:04:04,799
啊

124
00:04:04,800 --> 00:04:07,333
对应着一个优先级队列中的一个元素

125
00:04:07,333 --> 00:04:08,366
啊一个元素

126
00:04:08,533 --> 00:04:10,066
那么如果这个

127
00:04:10,333 --> 00:04:12,766
这个头节点所对应的列表不空

128
00:04:12,800 --> 00:04:14,300
那么这个元素就是一

129
00:04:14,700 --> 00:04:17,700
如果这个节点所对应的这个

130
00:04:17,866 --> 00:04:18,166
如果

131
00:04:18,166 --> 00:04:20,066
这个比特所对应的这个优先级队列

132
00:04:20,066 --> 00:04:21,599
为空为空

133
00:04:21,666 --> 00:04:22,766
那么这个地方就是0

134
00:04:24,133 --> 00:04:26,733
所以啊这个beatmap呢就是一个01啊

135
00:04:26,733 --> 00:04:28,733
就是一个01的这么一个

136
00:04:29,800 --> 00:04:31,133
一个beatmap

137
00:04:31,133 --> 00:04:33,733
那么0代表的是这个

138
00:04:33,800 --> 00:04:35,966
这个比特所对应的UGG对列为空

139
00:04:36,066 --> 00:04:36,333
一

140
00:04:36,333 --> 00:04:39,099
表示这个比特所对应的UGG对列不空

141
00:04:39,133 --> 00:04:39,933
啊

142
00:04:40,600 --> 00:04:41,800
是这样的一个情况

143
00:04:44,700 --> 00:04:46,533
好那么介绍完了这些呢

144
00:04:46,533 --> 00:04:48,133
我们来介绍这个函数

145
00:04:48,133 --> 00:04:50,399
这个函数叫做OS priority Q1 need

146
00:04:50,600 --> 00:04:52,700
就是对优先级对列进行初始化

147
00:04:52,700 --> 00:04:54,166
那前面我们已经说过了啊

148
00:04:54,166 --> 00:04:55,466
这个优先级对列

149
00:04:55,766 --> 00:05:00,366
是global priority q list指针所指向的一个啊

150
00:05:01,133 --> 00:05:02,066
结构体数组

151
00:05:02,333 --> 00:05:03,566
那么这个结构体数组中

152
00:05:03,566 --> 00:05:05,699
每一个元素都是一个双向循环列表的

153
00:05:05,700 --> 00:05:06,966
头指针啊

154
00:05:06,966 --> 00:05:08,999
头指针那你看这就是你看

155
00:05:09,066 --> 00:05:11,799
通过loss Melo memory ALOC这个函数呢

156
00:05:11,800 --> 00:05:13,900
我们会在内存啊

157
00:05:13,900 --> 00:05:15,666
内存管理章节中进行介绍

158
00:05:15,866 --> 00:05:16,399
那么这个呢

159
00:05:16,400 --> 00:05:19,933
是Letos中的一个内存缓冲池啊

160
00:05:19,933 --> 00:05:20,966
那么大家看

161
00:05:21,100 --> 00:05:24,100
通过这个memory log从这个缓冲池中分配

162
00:05:24,700 --> 00:05:25,600
一个空间啊

163
00:05:25,600 --> 00:05:27,100
这个空间是多大呢

164
00:05:27,200 --> 00:05:28,800
就是这是32对吧

165
00:05:28,800 --> 00:05:30,166
因为有32个优先级

166
00:05:30,166 --> 00:05:33,099
那这个就是这32个优先级的啊

167
00:05:33,100 --> 00:05:34,500
表头表头

168
00:05:34,600 --> 00:05:36,500
所以大家看我手我就怎么样呢

169
00:05:36,500 --> 00:05:39,500
从内存缓冲区中啊从这个缓冲池中

170
00:05:39,933 --> 00:05:42,666
分配一个这么大的一个连续空间

171
00:05:42,700 --> 00:05:45,333
然后把这个连续空间首地址付给这个

172
00:05:46,133 --> 00:05:48,933
global啊就是global Partique list了

173
00:05:48,933 --> 00:05:50,599
那么它的运行结果是什么样呢

174
00:05:50,600 --> 00:05:51,966
就是这样的啊

175
00:05:51,966 --> 00:05:53,333
首先这是一个

176
00:05:54,000 --> 00:05:56,166
32位的32个的数组

177
00:05:56,366 --> 00:05:57,566
32个头指针的数组

178
00:05:57,566 --> 00:05:59,966
每一个都是一个list双向循环列表

179
00:06:00,366 --> 00:06:01,966
DUAL list DUAL list

180
00:06:02,266 --> 00:06:05,066
然后呢这个指针指到这啊

181
00:06:05,066 --> 00:06:07,666
global priority q list指到这

182
00:06:07,766 --> 00:06:08,499
看到了吧

183
00:06:08,500 --> 00:06:11,266
那么完了之后呢我还需要对这个

184
00:06:11,900 --> 00:06:14,066
每一个头指针进行初始化啊

185
00:06:14,066 --> 00:06:14,999
每一个头指针进行初始化

186
00:06:15,000 --> 00:06:15,966
那怎么定初始化呢

187
00:06:15,966 --> 00:06:16,799
就是list in it

188
00:06:17,166 --> 00:06:18,799
我们前面已经说过了就是什么

189
00:06:18,800 --> 00:06:20,600
因为每个头指针都包含两个指针

190
00:06:20,600 --> 00:06:23,100
一个是previous指针一个是NEX的指针

191
00:06:23,300 --> 00:06:25,133
那初始化就是让previous指针

192
00:06:25,133 --> 00:06:27,299
和NEX指针都指向这个节点本身

193
00:06:27,300 --> 00:06:28,266
这就是初始化

194
00:06:29,600 --> 00:06:30,400
啊

195
00:06:32,400 --> 00:06:33,200
好

196
00:06:34,400 --> 00:06:37,200
那么介绍完了这个初始化操作之后呢

197
00:06:37,200 --> 00:06:40,400
我们再介绍另外一个另外一些操作

198
00:06:40,500 --> 00:06:41,666
那么这个操作是什么呢

199
00:06:41,666 --> 00:06:44,799
这个操作就是OS priority q银q

200
00:06:44,866 --> 00:06:45,733
这是什么意思呢

201
00:06:45,900 --> 00:06:47,466
它我们看一下这个函数呢

202
00:06:47,466 --> 00:06:48,499
包含两个参数

203
00:06:48,500 --> 00:06:49,800
第一个参数是呢

204
00:06:49,900 --> 00:06:52,900
priority表示某一个优先级

205
00:06:52,966 --> 00:06:55,199
那第二个呢就是我要往这个优先级

206
00:06:55,666 --> 00:06:58,166
队列中插入的那个元素啊

207
00:06:58,166 --> 00:07:00,899
通常都是一个TCB啊通常都是一个TCB

208
00:07:01,000 --> 00:07:02,366
所以说这个含义是什么呢

209
00:07:02,366 --> 00:07:05,199
就是我要向指定优先级的队列中

210
00:07:05,200 --> 00:07:06,800
插入一个元素啊

211
00:07:06,800 --> 00:07:07,966
叫INQ啊

212
00:07:08,800 --> 00:07:09,366
好

213
00:07:09,366 --> 00:07:12,099
那么我们看一下这个他是怎么做的

214
00:07:12,100 --> 00:07:13,000
他是怎么做的

215
00:07:13,166 --> 00:07:14,466
那么首先呢

216
00:07:14,733 --> 00:07:16,533
第一件事情我们直观的想

217
00:07:16,533 --> 00:07:18,133
我们直观的想第一件事情是什么呀

218
00:07:18,133 --> 00:07:20,199
第一件事情是我要首先获得什么呢

219
00:07:20,200 --> 00:07:21,133
这个prote

220
00:07:21,466 --> 00:07:23,966
这个prote所指向的那个什么

221
00:07:24,300 --> 00:07:25,666
所指向的那个

222
00:07:27,200 --> 00:07:29,100
就是那个那个队列对吧

223
00:07:29,100 --> 00:07:31,566
所指向那个队列啊然后呢

224
00:07:32,933 --> 00:07:35,199
然后呢我要怎么样呢

225
00:07:35,200 --> 00:07:37,266
修改这个队列的beatmap

226
00:07:37,566 --> 00:07:39,366
与这个队列所对应的这个beatmap

227
00:07:39,566 --> 00:07:40,166
为什么呢

228
00:07:40,166 --> 00:07:40,966
因为

229
00:07:41,933 --> 00:07:42,933
可能会什么呢

230
00:07:42,933 --> 00:07:43,766
可能是这样的

231
00:07:43,766 --> 00:07:45,799
就是说与这个priority对

232
00:07:46,000 --> 00:07:48,366
priority对应的那个对列一开始是空的

233
00:07:48,366 --> 00:07:49,299
那如果是空的话

234
00:07:49,300 --> 00:07:51,533
那那个beat MAF相应的位置就是0

235
00:07:51,733 --> 00:07:54,066
所以呢我要怎么样要把它指一啊

236
00:07:54,300 --> 00:07:55,966
所以这就是我们看到的这个地方啊

237
00:07:55,966 --> 00:07:57,699
这个画画圈这个地方

238
00:07:57,700 --> 00:07:59,466
那在这个地方给大家一个例子啊

239
00:07:59,466 --> 00:08:00,366
给大家一个例子

240
00:08:00,400 --> 00:08:01,400
比如说啊

241
00:08:01,500 --> 00:08:04,166
比如说我们现在呢像这个对列中

242
00:08:04,200 --> 00:08:05,466
这个protect是三

243
00:08:06,400 --> 00:08:08,400
我们向具有priorities

244
00:08:08,466 --> 00:08:11,166
就是priority V3的这个对联中插入一个值

245
00:08:11,300 --> 00:08:14,066
那么插入之前这个Betamax的值是这个

246
00:08:14,500 --> 00:08:15,500
那我们看啊

247
00:08:15,566 --> 00:08:17,599
当是33的时候我们看这是个0

248
00:08:17,600 --> 00:08:18,533
表示什么意思啊

249
00:08:18,700 --> 00:08:20,366
表示的是在没有插入之

250
00:08:20,366 --> 00:08:22,466
在没有插入这个新的item之前

251
00:08:22,533 --> 00:08:24,799
那么这个队列3号优先

252
00:08:24,966 --> 00:08:25,766
整个这个系统中

253
00:08:25,766 --> 00:08:27,299
3号优先级这个队列是空的

254
00:08:27,300 --> 00:08:28,100
没有元素

255
00:08:28,200 --> 00:08:29,500
那么现在我要往这个Pro

256
00:08:29,500 --> 00:08:30,800
而且等于3的这个

257
00:08:30,966 --> 00:08:32,733
优先级队列中插入一个元素

258
00:08:32,733 --> 00:08:34,266
那么它就不再是空了

259
00:08:34,466 --> 00:08:35,333
所以我要把它指一

260
00:08:35,333 --> 00:08:36,299
那怎么做呢

261
00:08:36,466 --> 00:08:37,399
所以你看在这

262
00:08:37,733 --> 00:08:40,299
首先呢根据prite取得啊相应

263
00:08:40,866 --> 00:08:43,566
相应的这个prite的右线队列的头指针

264
00:08:43,933 --> 00:08:44,999
判断它是不是空

265
00:08:45,066 --> 00:08:47,133
如果为空的话那怎么办呢

266
00:08:47,133 --> 00:08:48,766
我就要你看这是什么

267
00:08:48,766 --> 00:08:49,666
这就是那个

268
00:08:49,766 --> 00:08:50,566
就是那个

269
00:08:51,900 --> 00:08:54,500
一个8后面七个0的那个那个红啊

270
00:08:54,500 --> 00:08:55,533
我就把它移动什么

271
00:08:55,533 --> 00:08:56,899
你看就是这个这个这个红

272
00:08:56,900 --> 00:08:57,666
这个红

273
00:08:57,666 --> 00:08:59,533
那我怎么样我就把它移动三位啊

274
00:08:59,533 --> 00:08:59,933
移动三位

275
00:08:59,933 --> 00:09:01,099
那移动三位之后呢

276
00:09:01,100 --> 00:09:03,100
他就就变成这样的一个结果了

277
00:09:03,100 --> 00:09:03,666
然后呢

278
00:09:03,666 --> 00:09:06,299
再和这个原来的beat MAM做货操作啊

279
00:09:06,300 --> 00:09:07,166
做货操作

280
00:09:07,533 --> 00:09:09,733
然后你看和完了之后呢

281
00:09:09,766 --> 00:09:11,666
这个优先级V3的这个

282
00:09:12,100 --> 00:09:12,933
优先级队列呢

283
00:09:12,933 --> 00:09:15,966
就他的这个标志就由0变成了一啊

284
00:09:15,966 --> 00:09:17,366
表示u型级

285
00:09:17,366 --> 00:09:19,599
3的这个u型级对列里就已经有元素了

286
00:09:19,600 --> 00:09:21,166
好最后完成什么呢

287
00:09:21,166 --> 00:09:23,599
最后就是通过这个OS啊

288
00:09:23,600 --> 00:09:27,400
例lost以list tail insert啊

289
00:09:27,400 --> 00:09:28,666
把这个新的元素

290
00:09:28,666 --> 00:09:29,533
插入到这个

291
00:09:29,533 --> 00:09:32,466
与3对应的这个u型级对列的尾部啊

292
00:09:32,466 --> 00:09:33,333
这是尾差啊

293
00:09:33,333 --> 00:09:34,533
看到了吧这是尾差

294
00:09:38,866 --> 00:09:41,766
好那么下面呢这个操作

295
00:09:41,766 --> 00:09:43,399
啊我们再看一下下面这个操作

296
00:09:43,566 --> 00:09:44,766
那么下面这个操作呢

297
00:09:44,766 --> 00:09:45,199
叫做什么

298
00:09:45,200 --> 00:09:46,800
叫做OSPLDQ top

299
00:09:46,966 --> 00:09:47,766
那么这个

300
00:09:47,900 --> 00:09:50,500
OSPLDQ top顾名思义是什么意思呢

301
00:09:50,500 --> 00:09:51,800
就是我获得什么

302
00:09:52,066 --> 00:09:53,299
我获得呀

303
00:09:53,300 --> 00:09:54,500
当前这个

304
00:09:55,500 --> 00:09:58,500
系统中具有最高优先级的任务

305
00:09:58,500 --> 00:10:00,100
具有最高优先级的任务

306
00:10:00,133 --> 00:10:01,333
那怎么获得呢

307
00:10:01,533 --> 00:10:02,966
啊我们可以设想一下

308
00:10:03,166 --> 00:10:04,333
啊我们可以设想一下

309
00:10:04,333 --> 00:10:06,266
如果要是没有beat MAF的话

310
00:10:06,400 --> 00:10:08,266
那么我们必须要怎么获得呢

311
00:10:08,900 --> 00:10:11,100
这个global q priority q

312
00:10:11,200 --> 00:10:13,800
list是一个3232个元素的数组

313
00:10:13,800 --> 00:10:15,300
我们就必须用一个指针

314
00:10:15,366 --> 00:10:16,766
然后来逐个判断

315
00:10:17,066 --> 00:10:20,533
来逐个判断每一个元素是不是有值

316
00:10:20,533 --> 00:10:21,799
每一个元素是不是有值

317
00:10:22,133 --> 00:10:23,933
那如果这个元素不空的话

318
00:10:23,933 --> 00:10:25,166
啊这个元素不空的话

319
00:10:25,166 --> 00:10:27,166
那么我们就返回对吧

320
00:10:27,166 --> 00:10:28,266
就返回这个

321
00:10:28,800 --> 00:10:29,266
这个圆

322
00:10:29,266 --> 00:10:31,766
这个这个优先级所对应的第一个

323
00:10:31,866 --> 00:10:35,199
第一个啊第一个TCB啊第一个TCB

324
00:10:35,366 --> 00:10:37,199
但是我们知道这是个很费时的操作

325
00:10:37,200 --> 00:10:38,100
那怎么做呢

326
00:10:38,100 --> 00:10:40,666
那在这给大家引入了一个新的函数

327
00:10:40,666 --> 00:10:42,099
叫做CLZ啊

328
00:10:42,100 --> 00:10:44,200
CLZ CLZ是什么的缩写呢

329
00:10:44,200 --> 00:10:46,166
就是count leading Zero啊

330
00:10:46,166 --> 00:10:48,166
count leading zeros的缩写

331
00:10:48,566 --> 00:10:49,599
那么直译是什么意思呢

332
00:10:49,600 --> 00:10:52,766
就是数什么开头有几个0啊

333
00:10:52,933 --> 00:10:53,966
数开头有几个0

334
00:10:54,100 --> 00:10:55,266
那他数谁

335
00:10:55,366 --> 00:10:56,566
谁的开头有几个0呢

336
00:10:56,566 --> 00:10:58,566
他数的是这个beat map开头有几个0

337
00:10:59,333 --> 00:11:00,499
啊我们看下面这个例子

338
00:11:00,500 --> 00:11:01,666
我们看下面这个例子

339
00:11:01,766 --> 00:11:03,999
比如说这是一个啊beat map

340
00:11:04,000 --> 00:11:05,066
这是一个beat map

341
00:11:05,066 --> 00:11:07,499
那么当我执行c l z命令的时候

342
00:11:07,500 --> 00:11:08,333
它返回是几呢

343
00:11:08,333 --> 00:11:11,399
你看开头有几个012345

344
00:11:11,400 --> 00:11:13,300
有5个0 啊有5个0

345
00:11:13,333 --> 00:11:15,899
那么大家看这个代表的是优先级是0

346
00:11:15,966 --> 00:11:18,766
这个代表的是优先级一优先级2

347
00:11:18,800 --> 00:11:20,066
优先级3

348
00:11:20,266 --> 00:11:22,933
优先级4和优先级5

349
00:11:23,400 --> 00:11:24,200
那大家看

350
00:11:24,200 --> 00:11:26,666
这个count leading zeros这个命令呢

351
00:11:26,666 --> 00:11:28,266
返回的正好是什么

352
00:11:28,300 --> 00:11:30,166
优先级最高的这个任务的优先级

353
00:11:30,166 --> 00:11:30,866
所以大家看

354
00:11:30,866 --> 00:11:33,099
我执行这个CRZ beatmap的时候

355
00:11:33,100 --> 00:11:34,566
正好把这个pride付给

356
00:11:35,000 --> 00:11:37,333
把这个值返回值付给Pro at就是什么

357
00:11:37,333 --> 00:11:38,366
这Pro at是什么

358
00:11:38,600 --> 00:11:40,200
就是当前系统中

359
00:11:40,366 --> 00:11:42,199
具有最高的优先级的那个不空

360
00:11:42,200 --> 00:11:43,100
非空对列啊

361
00:11:43,100 --> 00:11:43,733
非空对列

362
00:11:43,733 --> 00:11:45,799
那好了那我得到这个了之后呢

363
00:11:45,800 --> 00:11:46,933
我从这个对列中

364
00:11:46,933 --> 00:11:48,866
你看我从这个对列中啊

365
00:11:48,866 --> 00:11:49,966
获得第一个元素

366
00:11:50,133 --> 00:11:51,533
获得第一个元素把它返回

367
00:11:51,533 --> 00:11:52,099
看到了吧

368
00:11:52,100 --> 00:11:53,466
那这不就是获得了什么呀

369
00:11:53,466 --> 00:11:54,166
当前系统中

370
00:11:54,166 --> 00:11:56,166
具有最高优先级的那个任务吗

371
00:11:56,800 --> 00:11:58,766
对吧所以大家看啊

372
00:11:59,100 --> 00:12:00,733
我刚才给你举那个例子啊

373
00:12:00,733 --> 00:12:01,866
用用便利的方法

374
00:12:01,866 --> 00:12:03,599
那那个算法的复杂度就是o n的

375
00:12:03,600 --> 00:12:04,000
但是你看

376
00:12:04,000 --> 00:12:06,366
我现在用这个count leading Zero这个命令

377
00:12:06,366 --> 00:12:07,933
怎么样就把由原来o

378
00:12:07,933 --> 00:12:09,866
n的复杂度变成了O1复杂度

379
00:12:10,466 --> 00:12:10,933
看到了吧

380
00:12:10,933 --> 00:12:13,599
这就是加入这个Betamab的重要性

381
00:12:15,766 --> 00:12:18,666
作用啊或者说加入这个beat map的作用

382
00:12:19,400 --> 00:12:20,200
好

383
00:12:20,766 --> 00:12:22,933
那么我们继续来讲解什么呢

384
00:12:22,933 --> 00:12:25,666
我们继续来讲解这个剩余的关于

385
00:12:26,166 --> 00:12:29,066
啊priority呃优先级队列的一些操作

386
00:12:29,066 --> 00:12:29,899
那这个是什么呢

387
00:12:29,900 --> 00:12:32,733
就是OS priority q inq hide

388
00:12:32,733 --> 00:12:33,699
那通过这个名字

389
00:12:33,700 --> 00:12:35,000
我们可以知道这是什么呢

390
00:12:35,000 --> 00:12:36,000
这是说像

391
00:12:36,400 --> 00:12:38,700
优先级队列中啊某一个优先级

392
00:12:38,700 --> 00:12:39,966
这个priority优先级

393
00:12:40,100 --> 00:12:41,966
怎么样头叉这个元素

394
00:12:42,400 --> 00:12:43,466
头插这个元素那好

395
00:12:43,466 --> 00:12:44,266
我们来看

396
00:12:44,300 --> 00:12:46,266
那一开始第一步仍然是这样啊

397
00:12:46,266 --> 00:12:46,966
仍然是这样

398
00:12:46,966 --> 00:12:49,566
我们来判断这个Pro alt啊

399
00:12:49,566 --> 00:12:51,699
这个Pro alt所对应的优优先级

400
00:12:51,933 --> 00:12:53,166
对列是否为空

401
00:12:53,266 --> 00:12:54,333
如果为空的话

402
00:12:54,333 --> 00:12:55,599
那么因为我们要插入

403
00:12:55,600 --> 00:12:58,133
要要向这个Pro alt插入一个新的元素

404
00:12:58,133 --> 00:12:59,499
所以我们就把这个beat map

405
00:12:59,500 --> 00:13:01,600
与这个Pro alt所对应的这个位置之一

406
00:13:01,866 --> 00:13:02,666
看到了吧直译

407
00:13:02,766 --> 00:13:03,966
然后因为是头插

408
00:13:03,966 --> 00:13:06,466
所以我们调用的是lost list had insert

409
00:13:06,466 --> 00:13:07,266
看到了吧

410
00:13:07,333 --> 00:13:10,099
had insert那么把这个新的元素头

411
00:13:10,100 --> 00:13:12,066
插入priority所对应的这个

412
00:13:12,333 --> 00:13:13,466
右线极对列中

413
00:13:17,533 --> 00:13:19,999
好那么这个是尾叉

414
00:13:20,200 --> 00:13:23,100
就是有头叉就有尾叉OS prior to q inq

415
00:13:23,133 --> 00:13:24,699
那我们刚才已经介绍了啊

416
00:13:24,700 --> 00:13:26,333
拿这个作为典型的介绍

417
00:13:26,333 --> 00:13:29,766
大家看这就是尾叉loss list kill insert

418
00:13:29,966 --> 00:13:30,999
那么怎么样呢

419
00:13:31,000 --> 00:13:33,100
把这个待插入的节点

420
00:13:33,166 --> 00:13:35,666
插入到这个Pro to run q的尾部

421
00:13:37,966 --> 00:13:40,666
好那么有插入就有删除啊

422
00:13:40,666 --> 00:13:41,966
有插入就有删除

423
00:13:42,000 --> 00:13:43,366
那么我们看一下啊

424
00:13:43,466 --> 00:13:44,599
现在呢我们

425
00:13:45,466 --> 00:13:48,099
介绍的这个函数叫做OS part的q d q

426
00:13:48,300 --> 00:13:49,566
in q是入队

427
00:13:49,566 --> 00:13:50,799
而d q就是什么

428
00:13:50,900 --> 00:13:52,100
就是出对啊

429
00:13:52,100 --> 00:13:53,700
出对那这是什么意思呢

430
00:13:53,700 --> 00:13:56,400
就是把这个艾特从这个啊

431
00:13:56,500 --> 00:13:57,400
从这个什么呢

432
00:13:57,400 --> 00:14:00,366
从这个啊右线击对列中移除啊

433
00:14:00,366 --> 00:14:01,466
移除那怎么移除呢

434
00:14:01,466 --> 00:14:04,533
大家看首先我调用lost绿色delete

435
00:14:04,566 --> 00:14:05,699
把这个ATM从

436
00:14:05,700 --> 00:14:07,800
相应的这个右线击对列中移除

437
00:14:08,333 --> 00:14:09,066
那么大家想一想

438
00:14:09,066 --> 00:14:10,999
我要移除一个item之后呢

439
00:14:11,000 --> 00:14:11,600
那有可能

440
00:14:11,600 --> 00:14:12,133
这个item

441
00:14:12,133 --> 00:14:13,899
是这个优先级队列中的最后一个元

442
00:14:13,900 --> 00:14:15,100
素那这时候我就要

443
00:14:15,100 --> 00:14:16,800
把这个优先级队列的那个beatmap

444
00:14:16,800 --> 00:14:18,800
与之对应的那个优先级的beatmap

445
00:14:19,300 --> 00:14:21,166
的位置由一变成0对吧

446
00:14:21,166 --> 00:14:21,599
那好

447
00:14:21,600 --> 00:14:24,500
那我怎么找到这个beat MAF的位置呢

448
00:14:24,566 --> 00:14:25,066
位置呢

449
00:14:25,066 --> 00:14:26,966
首先我要知道这个优先级是什么

450
00:14:27,166 --> 00:14:28,966
那你看这个item

451
00:14:28,966 --> 00:14:31,399
实际上是一个dualist的这么一个类型

452
00:14:31,400 --> 00:14:34,766
那好我们就需要用到什么loss dualist entry

453
00:14:34,900 --> 00:14:36,200
那么我们根据这个

454
00:14:36,766 --> 00:14:39,933
这个这个item就可以找到这个TCB的手

455
00:14:39,933 --> 00:14:40,866
手地址啊

456
00:14:40,866 --> 00:14:41,666
TCB的手地址

457
00:14:41,666 --> 00:14:43,266
你看通过这个entry

458
00:14:43,266 --> 00:14:44,766
我就找到这个TCB的手地址

459
00:14:44,766 --> 00:14:46,333
我我画一下图啊你看

460
00:14:47,266 --> 00:14:50,533
比如说这个数据结构是Toss的CB TCB

461
00:14:51,700 --> 00:14:52,500
TCB

462
00:14:52,900 --> 00:14:56,133
TCB那么在TCB里有一个项叫priority

463
00:14:57,566 --> 00:14:59,466
啊priority pri

464
00:15:00,600 --> 00:15:03,733
那么我们这个我们这个item呢

465
00:15:03,733 --> 00:15:05,666
只是在这里指示它的一个什么呢

466
00:15:05,666 --> 00:15:07,899
指它的一个指针是指到这了对吧

467
00:15:07,966 --> 00:15:08,933
所以怎么样呢

468
00:15:08,933 --> 00:15:10,533
我我通过这个entry命令

469
00:15:10,533 --> 00:15:12,399
我执行完这个entry命令之后呢

470
00:15:12,400 --> 00:15:14,066
我就把这个run toss指到哪了

471
00:15:14,066 --> 00:15:15,133
是不是指到这来了

472
00:15:15,900 --> 00:15:17,933
所以run toss就指到这来了

473
00:15:21,766 --> 00:15:23,133
run task就指到这儿来了

474
00:15:23,133 --> 00:15:24,733
那我为什么要指到这儿来呢

475
00:15:24,766 --> 00:15:26,899
因为啊因为我要通过这个run

476
00:15:26,900 --> 00:15:28,733
task来获得这个priority

477
00:15:29,366 --> 00:15:30,066
看到了吧

478
00:15:30,066 --> 00:15:32,699
run task要获得这个priority啊

479
00:15:32,700 --> 00:15:34,966
为什么要获得这个priority呢

480
00:15:35,100 --> 00:15:37,200
那好那在这在这呢

481
00:15:37,200 --> 00:15:40,166
就是说当我获得了这个priority以后呢

482
00:15:40,300 --> 00:15:42,700
priority以后呢我就可以来判断

483
00:15:43,366 --> 00:15:44,966
我删除了这个节点之后

484
00:15:45,000 --> 00:15:47,500
这个protect所对应的这个优先级对列

485
00:15:47,666 --> 00:15:50,533
啊优先级对列是不是空

486
00:15:50,566 --> 00:15:51,999
如果是空的话那我怎么

487
00:15:52,000 --> 00:15:53,466
样我就要把这个

488
00:15:54,666 --> 00:15:56,133
与这个优先级对列所对应的

489
00:15:56,133 --> 00:15:56,733
这个beat map

490
00:15:56,733 --> 00:15:57,533
怎么样清零

491
00:15:57,566 --> 00:15:58,266
看到了吧

492
00:15:58,266 --> 00:16:00,499
所以为什么要在这进行一次转换

493
00:16:00,500 --> 00:16:02,133
它它它的原因在这呢

494
00:16:02,200 --> 00:16:04,133
啊这是

495
00:16:05,100 --> 00:16:06,100
这个东西啊

496
00:16:11,266 --> 00:16:12,066
好

497
00:16:13,000 --> 00:16:14,966
那么同样的道理啊同样的道理

498
00:16:16,000 --> 00:16:18,166
那么我们再看一下这个啊这个

499
00:16:18,500 --> 00:16:22,166
那么这个函数OS party q top获取

500
00:16:22,933 --> 00:16:23,866
就绪队列

501
00:16:24,300 --> 00:16:26,133
优先级最高的双向

502
00:16:26,533 --> 00:16:28,166
列表的头节点啊头节点

503
00:16:28,166 --> 00:16:30,099
那同样道理这个也很简单啊

504
00:16:30,133 --> 00:16:31,499
我们前面已经介绍了啊

505
00:16:31,500 --> 00:16:32,966
首先是获得什么呢

506
00:16:32,966 --> 00:16:33,866
就是获得

507
00:16:33,966 --> 00:16:34,999
整个啊

508
00:16:35,000 --> 00:16:36,133
整个优先级队列中

509
00:16:36,133 --> 00:16:38,566
最高优先级的优先级号priority

510
00:16:38,700 --> 00:16:39,200
然后呢

511
00:16:39,200 --> 00:16:41,466
取得这个priority的第一个元素啊

512
00:16:41,466 --> 00:16:42,266
第一个元素

513
00:16:43,366 --> 00:16:46,599
好我们来看这个函数那这个函数是

514
00:16:47,133 --> 00:16:49,099
叫做OS part q size

515
00:16:49,100 --> 00:16:50,500
那么这个函数顾名思义

516
00:16:50,500 --> 00:16:53,566
我们知道它是获得某一个指定优先级

517
00:16:53,566 --> 00:16:55,566
也就是party这个优先级中

518
00:16:56,000 --> 00:16:57,000
那么优先

519
00:16:57,900 --> 00:17:00,800
嗯这个优先级队列中保存的这个

520
00:17:01,133 --> 00:17:02,299
节点的个数的啊

521
00:17:02,300 --> 00:17:03,933
那我们首先看一下这个函数

522
00:17:03,933 --> 00:17:05,799
它的这个局部变量

523
00:17:06,933 --> 00:17:08,499
那么它一共包含这么几个局部变量

524
00:17:08,500 --> 00:17:09,500
就是item count

525
00:17:09,766 --> 00:17:12,099
item count是用来累计这个

526
00:17:13,100 --> 00:17:15,466
啊累计这个UG对列中啊

527
00:17:15,466 --> 00:17:16,933
节点个数的这么一个

528
00:17:17,400 --> 00:17:18,400
这么一个变量

529
00:17:18,400 --> 00:17:19,700
那current NODE是什么呢

530
00:17:19,700 --> 00:17:21,466
就是我们看一下啊

531
00:17:21,933 --> 00:17:23,299
换一下换一下

532
00:17:23,500 --> 00:17:25,000
那么我们知道啊

533
00:17:26,933 --> 00:17:28,666
那么整个的这个

534
00:17:30,566 --> 00:17:32,533
整个的这个这个

535
00:17:34,100 --> 00:17:36,566
优先级队列呢是由32个

536
00:17:37,666 --> 00:17:39,666
32个这个这个

537
00:17:39,866 --> 00:17:41,899
啊双向循环列表的透支人构成的

538
00:17:41,900 --> 00:17:44,000
假如说我们这个prote是一的话

539
00:17:44,466 --> 00:17:45,933
假如假如说这个地方是一的话

540
00:17:45,933 --> 00:17:47,333
那么这个就是第一

541
00:17:47,333 --> 00:17:49,866
个Pro ALTI的头指针

542
00:17:50,000 --> 00:17:51,933
那么我们假设这个Pro ALTI指针呢

543
00:17:51,933 --> 00:17:52,766
包含了

544
00:17:53,133 --> 00:17:55,533
包含了三个节点啊包含了三个节点

545
00:17:56,266 --> 00:17:58,399
那我要是我要想返回这个

546
00:17:59,333 --> 00:18:02,299
这个优先级队列中的数度的元素

547
00:18:02,300 --> 00:18:03,266
数度的个数啊

548
00:18:03,266 --> 00:18:04,366
这有有几个节点数

549
00:18:04,366 --> 00:18:05,566
那我是不是要便利

550
00:18:05,700 --> 00:18:08,300
通过一个four循环来辨利这个队列

551
00:18:09,333 --> 00:18:11,699
来别离这个列表啊

552
00:18:11,700 --> 00:18:13,466
来别离这个列表线下列表

553
00:18:13,533 --> 00:18:16,133
好那这个current NODE就是用来辨离这个

554
00:18:16,133 --> 00:18:17,133
线下列表的

555
00:18:17,333 --> 00:18:19,933
那么保存每一个当前当前的节点

556
00:18:20,166 --> 00:18:22,066
好那么剩下的这个SMP

557
00:18:22,066 --> 00:18:23,333
这个部分我们先不看啊

558
00:18:23,333 --> 00:18:24,166
我们先不看

559
00:18:24,400 --> 00:18:26,066
那么我们看一下这个

560
00:18:26,600 --> 00:18:29,166
大家看在这这个是一个for循环啊

561
00:18:29,166 --> 00:18:30,599
for for什么呢

562
00:18:30,600 --> 00:18:32,966
for这个循环列表中你看

563
00:18:33,166 --> 00:18:35,699
首先是根据priority去这个global

564
00:18:35,933 --> 00:18:38,333
priority q lease中取得这个头指针

565
00:18:38,566 --> 00:18:40,733
然后呢这个for ISS呢就是

566
00:18:41,700 --> 00:18:43,600
把就是就是一个for循环for里

567
00:18:43,766 --> 00:18:45,133
for这里的每一个节点

568
00:18:45,166 --> 00:18:46,866
把这个节点放到carnet NODE里

569
00:18:46,866 --> 00:18:48,499
那么如果这carnet NODE呢

570
00:18:48,500 --> 00:18:49,966
没没有没有结束

571
00:18:50,000 --> 00:18:51,166
没有到末尾的话

572
00:18:51,200 --> 00:18:52,766
那么就把这个item con加加

573
00:18:52,766 --> 00:18:55,066
那最后一段把这个item con返回

574
00:18:55,200 --> 00:18:56,400
就可以了啊

575
00:18:57,666 --> 00:18:59,733
那么这个亲和性是怎么回事呢

576
00:18:59,733 --> 00:19:00,999
这就涉及到一个啊

577
00:19:01,000 --> 00:19:03,300
对称多处理器的这个概念啊

578
00:19:03,333 --> 00:19:05,466
那么这个我们在啊刻

579
00:19:05,933 --> 00:19:09,199
就是离线的这个离线的情况下来讲解

580
00:19:09,266 --> 00:19:11,066
来讲解那么在线的这个视频中

581
00:19:11,066 --> 00:19:12,333
我们就不做讲解了

582
00:19:20,600 --> 00:19:23,066
好那我们看一下这个

583
00:19:23,866 --> 00:19:24,666
关于

584
00:19:25,066 --> 00:19:28,066
优先级队列的最后一个操作是OS get

585
00:19:28,300 --> 00:19:30,933
top task OS get top task那

586
00:19:30,933 --> 00:19:32,466
么这个是什么意思呢

587
00:19:32,466 --> 00:19:35,266
就是它也是获得什么的优先级队列中

588
00:19:35,466 --> 00:19:37,533
具有最高优先级的那个任务啊

589
00:19:37,533 --> 00:19:38,999
具有最高优先级的那个任务

590
00:19:39,166 --> 00:19:41,899
那么priority是什么呢

591
00:19:41,900 --> 00:19:45,333
是啊用来保存这个局部变量的

592
00:19:45,333 --> 00:19:47,266
用来用来保存最高优先级

593
00:19:47,333 --> 00:19:48,499
那beatmap呢

594
00:19:48,666 --> 00:19:51,166
是一个临时变量啊是一个临时变量

595
00:19:51,333 --> 00:19:54,866
那么它呢是跟啊是跟什么有关呢

596
00:19:54,866 --> 00:19:57,766
是跟那个就是我们说的那个

597
00:19:57,866 --> 00:19:58,733
位图有关啊

598
00:19:58,733 --> 00:19:59,533
位图有关

599
00:20:00,400 --> 00:20:03,100
new task啊用来保存的是什么呢

600
00:20:03,100 --> 00:20:04,800
用来保存选出来的那个

601
00:20:04,900 --> 00:20:06,400
最高优先级的这个

602
00:20:07,333 --> 00:20:08,466
TCB啊TCB

603
00:20:09,266 --> 00:20:09,766
同样道理

604
00:20:09,766 --> 00:20:10,766
我们也不说这个对

605
00:20:10,766 --> 00:20:12,199
对称多处理器的情形

606
00:20:12,400 --> 00:20:15,066
首先大家看它把这个啊

607
00:20:15,200 --> 00:20:16,333
这个priority

608
00:20:16,366 --> 00:20:17,299
q的beatmap

609
00:20:17,300 --> 00:20:19,333
保存到了这个临时变量beatmap中

610
00:20:19,733 --> 00:20:23,066
然后呢用一个Wil循环啊Wil循环啊

611
00:20:23,066 --> 00:20:25,099
Wil这个beat my不等于0的时候

612
00:20:25,100 --> 00:20:26,733
那然后用CLZ啊

613
00:20:26,733 --> 00:20:29,899
count leading zeros来获取最高的优先级啊

614
00:20:29,900 --> 00:20:31,333
priority然后呢

615
00:20:31,333 --> 00:20:33,266
针对这个获取来的最高的优先级

616
00:20:33,266 --> 00:20:34,199
来便利啊

617
00:20:34,200 --> 00:20:36,533
来便利那么把这个

618
00:20:37,266 --> 00:20:38,699
或所获得的这个

619
00:20:38,933 --> 00:20:40,766
lost task和TCB类型的指针

620
00:20:40,766 --> 00:20:42,133
放在这个new task里

621
00:20:42,200 --> 00:20:44,166
放在这个new task里啊

622
00:20:44,200 --> 00:20:45,200
然后呢

623
00:20:45,966 --> 00:20:46,766
大家看

624
00:20:46,800 --> 00:20:49,800
那我不是把这个new task获得了吗

625
00:20:49,800 --> 00:20:51,700
然后把这个new task从这个

626
00:20:51,766 --> 00:20:53,499
优先级队列中摘出啊

627
00:20:53,500 --> 00:20:54,500
如果成功的话

628
00:20:54,500 --> 00:20:57,600
那么我就go out返回这个new task

629
00:20:57,700 --> 00:20:59,100
我我选出来new task

630
00:20:59,100 --> 00:21:00,066
如果不成功的话

631
00:21:00,066 --> 00:21:02,533
那么我们再继续这个will循环啊

632
00:21:02,533 --> 00:21:03,499
继续这个will循环

633
00:21:04,266 --> 00:21:08,333
以上就是关于优先级队列的全部内容

634
00:21:08,966 --> 00:21:09,766
谢谢各位

