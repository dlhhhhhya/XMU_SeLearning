1
00:00:01,166 --> 00:00:03,333
好下面我们介绍

2
00:00:04,000 --> 00:00:06,066
Letos进程管理的

3
00:00:06,700 --> 00:00:09,533
进程控制的第二部分内容进程管理

4
00:00:09,800 --> 00:00:11,066
那么这部分内容呢

5
00:00:11,066 --> 00:00:12,466
主要给大家介绍

6
00:00:12,466 --> 00:00:14,966
Letos中两个非常重要的

7
00:00:15,300 --> 00:00:17,666
啊非常重要的几个进程

8
00:00:17,766 --> 00:00:19,066
他们分别是

9
00:00:21,133 --> 00:00:21,933
啊

10
00:00:22,300 --> 00:00:24,166
那么非常重要的三个进程啊

11
00:00:24,166 --> 00:00:25,533
以及他们的创建过程

12
00:00:25,900 --> 00:00:28,600
那么在Letos中有三个特殊的进程

13
00:00:29,100 --> 00:00:30,466
分别叫做分别

14
00:00:30,466 --> 00:00:32,333
它们的PID分别是2号进程

15
00:00:32,333 --> 00:00:35,066
也就是PID号为2的这个进程

16
00:00:35,366 --> 00:00:37,666
那么它叫k process

17
00:00:37,666 --> 00:00:39,166
那么从这个名字上

18
00:00:39,166 --> 00:00:41,199
你就可以知道是Kern process

19
00:00:41,366 --> 00:00:43,499
那么它就是为内核态

20
00:00:43,766 --> 00:00:45,199
内核态的根进程

21
00:00:45,566 --> 00:00:48,266
也就是说所有内核进程都是

22
00:00:48,600 --> 00:00:50,100
k Pro size的子孙

23
00:00:50,300 --> 00:00:52,333
那么它在启动过程中创建

24
00:00:53,300 --> 00:00:55,133
第二个进程是啊

25
00:00:55,133 --> 00:00:57,133
创建的第第二个非常重要的进程

26
00:00:57,133 --> 00:00:58,899
它的ID号是0号进程

27
00:00:59,300 --> 00:01:01,400
那么它是k IDO进程

28
00:01:01,400 --> 00:01:04,300
k IDO进程为内核泰的第二个进程

29
00:01:04,666 --> 00:01:05,899
那么它是干嘛的呢

30
00:01:05,900 --> 00:01:07,733
就是说每一个CPU啊

31
00:01:07,900 --> 00:01:10,733
都有一个与之相对应的k i斗进程

32
00:01:10,733 --> 00:01:11,966
那么它在run q里吧

33
00:01:11,966 --> 00:01:14,966
run q里我们可以看run q就有一个指向

34
00:01:15,466 --> 00:01:16,199
啊因为我们知道

35
00:01:16,200 --> 00:01:18,500
每一个核心都有有一个就绪队列啊

36
00:01:18,500 --> 00:01:20,266
有一个就绪队列就是priority q

37
00:01:20,466 --> 00:01:22,699
那这个priority q实际上是run q啊

38
00:01:22,700 --> 00:01:23,533
是一个run q

39
00:01:23,766 --> 00:01:25,533
是run q的一个子堆啊

40
00:01:25,800 --> 00:01:27,200
就是一个指针指向的

41
00:01:27,366 --> 00:01:29,299
那么这个run q呢

42
00:01:29,733 --> 00:01:32,499
还有一个指针指向就这个k idol

43
00:01:32,600 --> 00:01:34,266
那k idol的执行时机是什么呢

44
00:01:34,266 --> 00:01:35,333
就是当一个CPU

45
00:01:35,333 --> 00:01:37,466
核心没有任何任务可以执行的时

46
00:01:37,466 --> 00:01:39,133
候那么这时候呢

47
00:01:39,133 --> 00:01:41,733
CPU就执行啊这个run q中的k idol

48
00:01:42,266 --> 00:01:43,333
CADO进程

49
00:01:43,666 --> 00:01:45,666
那么第三个进程是1号进程

50
00:01:45,866 --> 00:01:46,999
叫做init进程

51
00:01:47,100 --> 00:01:49,700
这个init进程呢为用户态的跟进程

52
00:01:49,800 --> 00:01:51,200
那它是由什么

53
00:01:51,200 --> 00:01:54,100
系统触手化函数system init来创建的啊

54
00:01:54,600 --> 00:01:55,000
system

55
00:01:55,000 --> 00:01:57,400
elite那我们从这个

56
00:01:57,400 --> 00:01:59,400
当我们在Letos中运行这个touch

57
00:01:59,400 --> 00:02:00,000
命令的时候

58
00:02:00,000 --> 00:02:02,266
我们就可以看到在这个系统中运行的

59
00:02:02,266 --> 00:02:03,366
所有的这些

60
00:02:03,966 --> 00:02:05,133
啊所有的这些进程

61
00:02:05,133 --> 00:02:06,499
看到了所有的这些进程

62
00:02:06,700 --> 00:02:07,700
那我们找一下啊

63
00:02:07,700 --> 00:02:08,400
我们找一下

64
00:02:08,400 --> 00:02:10,100
你看在这个地方呢

65
00:02:10,100 --> 00:02:12,366
你看这个PID为一的进程是什么

66
00:02:12,366 --> 00:02:13,499
是一米的进程

67
00:02:13,800 --> 00:02:15,766
PID为2的这个进程是什么

68
00:02:15,766 --> 00:02:16,999
k Pro size进程

69
00:02:17,300 --> 00:02:18,100
看到了吧

70
00:02:18,300 --> 00:02:19,800
那好我们再往下看

71
00:02:19,800 --> 00:02:22,700
比如说我们看这个啊看这个这个进程

72
00:02:23,333 --> 00:02:24,133
那么

73
00:02:24,800 --> 00:02:27,066
嗯我看一下啊看一下

74
00:02:30,666 --> 00:02:32,299
啊对对

75
00:02:32,466 --> 00:02:33,766
那么我们看一下啊

76
00:02:33,766 --> 00:02:35,933
我们看一下这个进程是什么呢

77
00:02:35,933 --> 00:02:36,733
这个进程

78
00:02:36,800 --> 00:02:39,000
这个其实不是进程啊这是一个线程啊

79
00:02:39,000 --> 00:02:39,666
这是一个线程

80
00:02:39,666 --> 00:02:40,766
你看有个tid

81
00:02:40,766 --> 00:02:43,499
tid t是task啊task ID的

82
00:02:43,500 --> 00:02:46,666
那么这个表示每一个线程的线程号

83
00:02:47,133 --> 00:02:48,099
县城的县城号

84
00:02:48,266 --> 00:02:51,466
那么这个init的县城号是第20号

85
00:02:51,666 --> 00:02:53,099
那它是属于谁呢

86
00:02:53,100 --> 00:02:54,566
它是属于这个

87
00:02:54,800 --> 00:02:55,866
因为它是县城嘛

88
00:02:55,866 --> 00:02:58,266
所以它是属于这个1号进城的

89
00:02:58,366 --> 00:03:00,499
而1号进城就是这个init进城

90
00:03:00,733 --> 00:03:01,466
看到了吧

91
00:03:01,466 --> 00:03:02,899
那这个呢是什么呢

92
00:03:02,900 --> 00:03:04,800
这个是一个内核线程啊

93
00:03:04,800 --> 00:03:05,666
内核线程

94
00:03:05,766 --> 00:03:08,599
那它的PID是2也就是说它是啊

95
00:03:08,600 --> 00:03:12,600
它是属于这个k process下属的一个线程

96
00:03:12,866 --> 00:03:13,766
核心线程

97
00:03:14,266 --> 00:03:15,066
看到了吧

98
00:03:15,500 --> 00:03:16,300
啊

99
00:03:18,133 --> 00:03:20,266
那么在这个地方还有一个啊在

100
00:03:20,266 --> 00:03:22,399
这个地方你看在这个地方有一个县城

101
00:03:22,733 --> 00:03:24,199
有一个进程3号进程

102
00:03:24,200 --> 00:03:26,300
我们看这个3号进程是一个shall进程

103
00:03:26,700 --> 00:03:27,500
那这个shell进程

104
00:03:27,500 --> 00:03:29,066
显然是一个用户态进程

105
00:03:29,100 --> 00:03:31,400
那我们找看一下这个PPID

106
00:03:31,400 --> 00:03:32,800
这个PPID是什么呢

107
00:03:32,800 --> 00:03:34,600
就是它的附进程

108
00:03:34,600 --> 00:03:36,066
附进程parent PID

109
00:03:36,200 --> 00:03:37,300
它的附进程是一

110
00:03:37,300 --> 00:03:40,766
所以shell进程的附进程是一密

111
00:03:40,766 --> 00:03:41,399
看到了吧

112
00:03:41,400 --> 00:03:42,566
那底下这个是什么呢

113
00:03:42,566 --> 00:03:43,933
底下这个是线程号啊

114
00:03:43,933 --> 00:03:45,533
这个线程归属的进程

115
00:03:45,800 --> 00:03:46,700
这个线程归属的进程

116
00:03:46,700 --> 00:03:49,500
你看shell进程归属3号线进程

117
00:03:49,500 --> 00:03:50,533
还有shell task

118
00:03:50,533 --> 00:03:53,533
shell entry都属于3号进程的线程

119
00:03:53,900 --> 00:03:56,100
看到吧那这些都是内核线程

120
00:03:56,333 --> 00:03:57,266
那么在用户态下

121
00:03:57,266 --> 00:03:58,133
我们看在这里头

122
00:03:58,133 --> 00:04:00,566
你看在这里头有很多的这个线程

123
00:04:00,800 --> 00:04:04,466
内核线程都属于这个k Pro size的子线程

124
00:04:04,733 --> 00:04:05,533
这个进程

125
00:04:05,800 --> 00:04:06,933
进程的子线程

126
00:04:07,200 --> 00:04:08,000
啊

127
00:04:10,400 --> 00:04:12,533
那么晋城是家族式管理

128
00:04:12,533 --> 00:04:14,166
总体呢分为两大家族

129
00:04:14,166 --> 00:04:16,933
用户态家族和内核泰家族

130
00:04:17,533 --> 00:04:20,166
用户态的晋城是贫民阶层权力有限

131
00:04:20,166 --> 00:04:21,499
人数众多啊

132
00:04:21,500 --> 00:04:22,566
活动范围有限

133
00:04:23,366 --> 00:04:24,666
那么这个阶层呢

134
00:04:25,200 --> 00:04:27,466
有个共同的祖先就是什么呢

135
00:04:27,466 --> 00:04:29,866
就是g user unit process

136
00:04:29,866 --> 00:04:32,266
就是那个unit process也就是1号进程

137
00:04:32,533 --> 00:04:33,866
那么在这有个全局变量

138
00:04:33,900 --> 00:04:36,766
全局整形变量叫做g user unit process

139
00:04:36,766 --> 00:04:37,866
等于一啊

140
00:04:39,300 --> 00:04:43,133
那么内核内核态的进程呢是贵族层啊

141
00:04:43,133 --> 00:04:45,166
贵族阶层管理平民阶层

142
00:04:45,466 --> 00:04:46,899
拥有超级权限

143
00:04:47,133 --> 00:04:50,133
能访问整个空间和所有资源

144
00:04:50,366 --> 00:04:51,466
人数不多啊

145
00:04:51,466 --> 00:04:52,999
这个阶层的始祖是谁呢

146
00:04:53,000 --> 00:04:56,333
是g kernel一need process就是keep process

147
00:04:56,933 --> 00:04:59,466
那我们看他的这个ID号呢是2

148
00:05:01,700 --> 00:05:03,666
那么两两位始祖呢

149
00:05:03,666 --> 00:05:04,599
就是这两位

150
00:05:04,600 --> 00:05:05,700
这两个进程啊

151
00:05:05,700 --> 00:05:07,866
都不是通过fork来创建的

152
00:05:07,966 --> 00:05:08,699
而是什么呢

153
00:05:08,700 --> 00:05:11,366
在内核强制规定进程的ID号

154
00:05:11,766 --> 00:05:13,799
那么强制写此创建的啊

155
00:05:13,800 --> 00:05:15,400
强制写此创建后面怎么创建的

156
00:05:15,400 --> 00:05:16,200
我们会看

157
00:05:16,466 --> 00:05:20,133
且这两个阶层呢是不可以互相转换的

158
00:05:20,500 --> 00:05:25,266
lost process CB有专门的标签来啊

159
00:05:25,266 --> 00:05:27,166
就是这个标签叫做process mode

160
00:05:27,166 --> 00:05:28,099
来区分什么呢

161
00:05:28,100 --> 00:05:28,933
这两个阶层

162
00:05:29,766 --> 00:05:31,199
整个鸿蒙内核呢

163
00:05:31,333 --> 00:05:33,766
原码没有提供改变

164
00:05:33,766 --> 00:05:36,199
进程这个状态的这样的一个set函数

165
00:05:36,200 --> 00:05:38,300
因此一个进程如果出生出来

166
00:05:38,400 --> 00:05:39,933
它就是用户态的话

167
00:05:39,933 --> 00:05:41,199
那它就永远是用户态的

168
00:05:41,200 --> 00:05:43,600
如果要是内核态它就永远是内核态

169
00:05:44,200 --> 00:05:45,866
那么进程的这个状态呢

170
00:05:45,866 --> 00:05:47,266
我们用两个来表用

171
00:05:47,266 --> 00:05:48,466
用一个标志来表示

172
00:05:48,466 --> 00:05:50,299
就是PROS一一个项来表示啊

173
00:05:50,300 --> 00:05:51,733
就是process mode

174
00:05:51,800 --> 00:05:54,133
当process mode为OS科mode的时候

175
00:05:54,133 --> 00:05:55,866
它就是内核态进程

176
00:05:56,000 --> 00:05:59,700
如果它的process mode为OS user mode的话

177
00:05:59,700 --> 00:06:01,200
那么它就是用户态进程

178
00:06:01,666 --> 00:06:02,366
那么在这个地方

179
00:06:02,366 --> 00:06:06,066
你看它就判断process CB的process mode

180
00:06:06,066 --> 00:06:06,799
等不等于

181
00:06:06,800 --> 00:06:08,600
OS user mode如果等于user mode

182
00:06:08,600 --> 00:06:09,466
它就返回处

183
00:06:09,466 --> 00:06:11,366
表示这是一个用户模式进程

184
00:06:11,533 --> 00:06:13,666
否则的话它就返回false

185
00:06:15,333 --> 00:06:17,566
好那下面我们就来看一下这个

186
00:06:17,566 --> 00:06:19,466
这三个重要的进程啊

187
00:06:19,466 --> 00:06:21,733
这三个重要进程是怎么创建起来的

188
00:06:22,300 --> 00:06:22,700
啊

189
00:06:22,700 --> 00:06:25,366
那我们看2号进程为内核的老祖宗

190
00:06:25,366 --> 00:06:27,366
是内核创业的首个进程

191
00:06:27,600 --> 00:06:30,266
那么他们这个源代码创业的过程如下

192
00:06:30,266 --> 00:06:32,399
那么我们就省略了一些不相干的部分

193
00:06:32,766 --> 00:06:33,933
那么may是什么呢

194
00:06:33,933 --> 00:06:34,866
may may是什么呢

195
00:06:34,866 --> 00:06:36,266
就是当内核完成

196
00:06:36,333 --> 00:06:37,999
因为我们知道内核在初始化的时候

197
00:06:38,000 --> 00:06:39,900
一开始执行的是汇编语言

198
00:06:40,133 --> 00:06:42,533
那么当执行完汇编语言的时候呢

199
00:06:42,533 --> 00:06:44,199
首先然后完成第四跳转

200
00:06:44,200 --> 00:06:45,700
跳转到c语言的程序

201
00:06:45,800 --> 00:06:47,166
那就是这个may函数

202
00:06:47,500 --> 00:06:49,200
那在这个面函数里呢

203
00:06:49,200 --> 00:06:49,733
嗯

204
00:06:49,733 --> 00:06:52,733
做的第一件事情是调用这个OS面函数

205
00:06:52,900 --> 00:06:54,700
那我们看一下这个OS面函数

206
00:06:55,166 --> 00:06:56,066
OS面函数

207
00:06:56,166 --> 00:06:57,766
那OS面函数干嘛呢

208
00:06:57,766 --> 00:06:59,566
那中间我们省略了很多东西啊

209
00:06:59,566 --> 00:07:01,466
那OS面函数啊

210
00:07:01,466 --> 00:07:02,999
进行若干初始化之后

211
00:07:03,000 --> 00:07:05,866
它会调用这个OS system process grade

212
00:07:06,066 --> 00:07:06,733
通过这个名字

213
00:07:06,733 --> 00:07:08,333
我们就知道它用来创建什么呀

214
00:07:08,333 --> 00:07:09,933
你看创建什么

215
00:07:10,266 --> 00:07:11,766
创建系统进程了

216
00:07:11,766 --> 00:07:13,866
那么在这个函数中就完成了

217
00:07:14,066 --> 00:07:16,499
kernoprosise和Kerno IDO进程

218
00:07:16,600 --> 00:07:18,700
这两个进程的这个创建过程

219
00:07:19,133 --> 00:07:21,299
那么在完成这个系统创建过程之后呢

220
00:07:21,300 --> 00:07:22,266
他就进行什么呢

221
00:07:22,266 --> 00:07:23,399
系统初始化啊

222
00:07:23,400 --> 00:07:25,466
就是就是进行这个

223
00:07:25,900 --> 00:07:28,366
就是你看啊隐匿的扣啊隐秘的扣啊

224
00:07:28,500 --> 00:07:30,700
调用其他的一些内核模块啊

225
00:07:30,700 --> 00:07:31,900
注册的内核模块

226
00:07:32,166 --> 00:07:32,966
那么

227
00:07:33,466 --> 00:07:34,333
这个init用户

228
00:07:34,333 --> 00:07:36,499
它的init进程就在这个地方啊

229
00:07:36,500 --> 00:07:38,566
进行进行创建的啊

230
00:07:38,566 --> 00:07:39,199
进行创建的

231
00:07:39,200 --> 00:07:41,066
所以在这个OS enid扣

232
00:07:41,166 --> 00:07:43,399
我们上堂课给大家讲过这个

233
00:07:43,466 --> 00:07:44,166
讲过这个

234
00:07:44,166 --> 00:07:46,266
就是我全前面给大家讲过那个

235
00:07:46,266 --> 00:07:47,566
就是系统调用

236
00:07:47,700 --> 00:07:49,800
那系统调用也是通过这个enid扣

237
00:07:49,800 --> 00:07:51,066
我们前面知道

238
00:07:51,500 --> 00:07:53,200
那个系统调用通过什么呢

239
00:07:53,366 --> 00:07:54,166
模块注册

240
00:07:54,166 --> 00:07:56,266
把自己的初始化函数啊

241
00:07:56,266 --> 00:07:57,999
注册到一个read only data

242
00:07:58,066 --> 00:07:59,899
点以net的数据区啊

243
00:07:59,900 --> 00:08:01,666
那么这个OS int扣

244
00:08:01,666 --> 00:08:03,199
就是扫描那个数据区啊

245
00:08:03,200 --> 00:08:04,533
按照这个注册级别

246
00:08:04,533 --> 00:08:05,966
依次调用它的户卡函

247
00:08:05,966 --> 00:08:07,899
数啊调用它的户卡函数

248
00:08:08,466 --> 00:08:09,333
来实现的

249
00:08:09,333 --> 00:08:10,499
那由此可见

250
00:08:10,700 --> 00:08:12,066
我们刚才在这说的是什么

251
00:08:12,066 --> 00:08:13,366
我们在这说的是

252
00:08:13,366 --> 00:08:17,133
这个Emit进程是由system Emit来创建的

253
00:08:17,133 --> 00:08:18,966
所以这个system Emit就是什么呢

254
00:08:18,966 --> 00:08:21,199
就是这个互函数

255
00:08:21,366 --> 00:08:22,499
那么我们会看到啊

256
00:08:22,500 --> 00:08:24,700
我们会看到这个Sysmeet也是通过

257
00:08:25,200 --> 00:08:28,366
模块注册的方式啊来把自己放到那个

258
00:08:28,766 --> 00:08:32,199
read only data点以ET区间区域的啊

259
00:08:33,333 --> 00:08:34,533
好我们再来看啊

260
00:08:34,533 --> 00:08:37,066
剩下的看一下这些主要的数据结构啊

261
00:08:37,066 --> 00:08:37,866
这个是什么呢

262
00:08:37,866 --> 00:08:39,133
这个就是啊

263
00:08:39,533 --> 00:08:41,199
进程持数组啊

264
00:08:41,200 --> 00:08:42,900
进程持数组它是有什么意义呢

265
00:08:42,900 --> 00:08:43,800
就是我们知道

266
00:08:44,200 --> 00:08:47,000
啊在Letos中最多支持64个进程

267
00:08:47,066 --> 00:08:48,366
那么我前面说过了

268
00:08:48,366 --> 00:08:50,399
这64个进程实际上是什么

269
00:08:50,400 --> 00:08:51,733
就是一个数组

270
00:08:51,733 --> 00:08:52,699
一个结构体数组

271
00:08:52,700 --> 00:08:54,933
就是lost process CB的一个结构体数组

272
00:08:55,100 --> 00:08:56,733
那么这个结构体数组是从

273
00:08:56,733 --> 00:08:58,099
内核缓冲区中啊

274
00:08:58,100 --> 00:08:59,500
内核内核缓冲尺

275
00:08:59,600 --> 00:09:02,933
缓存缓冲池中啊内存池中申请的

276
00:09:03,366 --> 00:09:04,466
申请的催促单元

277
00:09:04,700 --> 00:09:05,500
那么

278
00:09:06,266 --> 00:09:08,466
这个指针就指向了这个数组的手力指

279
00:09:08,466 --> 00:09:11,866
啊那么g free process指的是什么呢

280
00:09:11,866 --> 00:09:12,899
是一个链表啊

281
00:09:12,900 --> 00:09:13,700
是个链表

282
00:09:13,733 --> 00:09:18,699
它指向的是啊这个瑞里可以使用的啊

283
00:09:18,700 --> 00:09:20,366
继承控制块结构体啊

284
00:09:20,366 --> 00:09:22,533
它构成的这么一个双向循环链表

285
00:09:23,266 --> 00:09:25,866
那么这process recyclist是什么呢

286
00:09:25,866 --> 00:09:28,466
就是需要回收的进程列表

287
00:09:28,666 --> 00:09:29,699
那么我们前面在讲

288
00:09:29,700 --> 00:09:30,966
这个进程状态的时候

289
00:09:30,966 --> 00:09:32,766
有一个状态叫做exist

290
00:09:32,800 --> 00:09:34,400
exist看到了吧exist

291
00:09:34,600 --> 00:09:36,300
那么如果一个进程退出

292
00:09:36,300 --> 00:09:38,100
那么退出的时候啊

293
00:09:38,166 --> 00:09:39,933
那么它就是属于这个

294
00:09:39,933 --> 00:09:42,299
我们就会把这个exist标志给

295
00:09:42,866 --> 00:09:44,566
给标志上啊在那个进程的

296
00:09:44,566 --> 00:09:46,399
PCB PCB给标志上

297
00:09:46,466 --> 00:09:47,466
那就说明什么呢

298
00:09:47,466 --> 00:09:49,766
这个进程可以回收了可以回收了

299
00:09:49,866 --> 00:09:52,533
所以这时候呢就是啊

300
00:09:52,533 --> 00:09:53,733
这时候他就处于这个

301
00:09:53,733 --> 00:09:54,166
这个进程

302
00:09:54,166 --> 00:09:55,133
这时候就处于这个

303
00:09:55,133 --> 00:09:57,566
g process recyclist这个列表里

304
00:09:57,700 --> 00:10:00,100
那么啊有后台有一个线程啊

305
00:10:00,100 --> 00:10:00,966
有一个内核线程

306
00:10:00,966 --> 00:10:02,899
专门是定期定负责什么

307
00:10:02,900 --> 00:10:07,133
定期从这个recyclist中把这个啊PCB

308
00:10:07,200 --> 00:10:10,533
转换到什么freely free process这个freelyse里

309
00:10:11,066 --> 00:10:11,699
好吧

310
00:10:11,700 --> 00:10:13,133
好那这三个是什么呢

311
00:10:13,133 --> 00:10:15,499
这三个就是这个标志啊标志

312
00:10:15,733 --> 00:10:18,199
那么这个是g user一粒的process

313
00:10:18,200 --> 00:10:19,866
那我们知道它表示的是什么

314
00:10:19,866 --> 00:10:20,766
1号进程

315
00:10:20,800 --> 00:10:22,900
但一开始的时候它是evaluate

316
00:10:22,900 --> 00:10:24,533
evaluate date value

317
00:10:24,700 --> 00:10:26,966
那么后面啊在初始化的时候

318
00:10:26,966 --> 00:10:27,699
在初始化的时候

319
00:10:27,700 --> 00:10:30,300
在对进程进行初始化的时候啊

320
00:10:30,300 --> 00:10:32,300
那么也就是说在这个函数里啊

321
00:10:32,300 --> 00:10:34,733
OS system process create这个函数里

322
00:10:34,866 --> 00:10:36,299
会对它进行修改

323
00:10:36,300 --> 00:10:38,700
把这个值设为一啊

324
00:10:38,700 --> 00:10:40,866
那么这一科no idle process呢

325
00:10:40,866 --> 00:10:42,766
也是一开始设置成一个无效值

326
00:10:42,766 --> 00:10:44,566
但是在那个函数里啊

327
00:10:44,566 --> 00:10:45,466
在那个system

328
00:10:45,700 --> 00:10:47,966
process create函数里会把它设置成2

329
00:10:48,466 --> 00:10:52,699
那么g科呢IDLE process呢会被设置成0啊

330
00:10:52,800 --> 00:10:55,300
g process Max number就是什么呢

331
00:10:55,300 --> 00:10:56,666
就是一个啊

332
00:10:56,666 --> 00:10:58,466
lightox支持的最大继承数啊

333
00:10:58,466 --> 00:11:00,966
那你看在这儿有个默认值啊是64

334
00:11:01,333 --> 00:11:02,966
那么process group是什么呢

335
00:11:02,966 --> 00:11:04,199
是一个全局指针啊

336
00:11:04,200 --> 00:11:06,466
全局指针它用来管理什么呢

337
00:11:06,466 --> 00:11:08,266
它用来管理所有进程组

338
00:11:08,500 --> 00:11:09,300
所有进程组

339
00:11:10,133 --> 00:11:12,266
那么面函数呢在开机之前呢

340
00:11:12,266 --> 00:11:15,133
开机之初在SC模式下创建

341
00:11:15,766 --> 00:11:17,999
嗯创创建啊也就是调用啊

342
00:11:18,000 --> 00:11:19,966
调用这不是创建调用的那

343
00:11:19,966 --> 00:11:21,499
么内核太老祖宗

344
00:11:21,733 --> 00:11:24,199
老祖宗进程的名字叫做k process

345
00:11:24,200 --> 00:11:25,566
那它的优先级非常高啊

346
00:11:25,566 --> 00:11:26,866
它的优先级是0号

347
00:11:26,866 --> 00:11:27,799
0号优先级

348
00:11:28,366 --> 00:11:30,866
那么keep process进程是长期活跃的

349
00:11:30,866 --> 00:11:33,399
很多重要的任务都会跑在旗下啊

350
00:11:33,400 --> 00:11:34,666
就像我们刚才看到的啊

351
00:11:34,666 --> 00:11:36,133
我们刚才看到的你看

352
00:11:36,366 --> 00:11:37,399
就是这个地方

353
00:11:38,266 --> 00:11:40,533
你看这这这这个地方你看有这是什么

354
00:11:40,533 --> 00:11:41,533
这是软时钟任务

355
00:11:41,533 --> 00:11:42,333
看到了吧

356
00:11:42,733 --> 00:11:43,333
看到了吧

357
00:11:43,333 --> 00:11:45,299
那这个呢是终端啊

358
00:11:45,300 --> 00:11:48,100
就是啊串口串口的任务

359
00:11:49,066 --> 00:11:50,699
啊等等等等这些任务啊

360
00:11:51,100 --> 00:11:52,100
那么这是什么呢

361
00:11:52,100 --> 00:11:55,266
这个是软软件时钟software TIMER task

362
00:11:55,266 --> 00:11:56,066
看到了吧

363
00:11:56,100 --> 00:11:56,933
那这个呢

364
00:11:56,933 --> 00:11:58,133
是内存啊

365
00:11:58,133 --> 00:11:59,366
内存内存

366
00:11:59,466 --> 00:12:01,166
内存管理内存的任务

367
00:12:01,266 --> 00:12:03,499
那这个呢是管理驱动的任务

368
00:12:03,500 --> 00:12:04,800
这个是管理网络的任务

369
00:12:04,800 --> 00:12:06,500
这个呢是管理创口的任务

370
00:12:06,800 --> 00:12:07,800
这个是Telenet任务

371
00:12:07,800 --> 00:12:09,500
这是以太网的中断任务

372
00:12:09,533 --> 00:12:11,933
那这是触摸屏任务这是USB任务啊

373
00:12:11,933 --> 00:12:12,366
看到了吧

374
00:12:12,366 --> 00:12:13,133
你从这些名字

375
00:12:13,133 --> 00:12:15,099
你会知道他们是什么样的任务

376
00:12:15,133 --> 00:12:17,166
那这些都是现成都是什么

377
00:12:17,166 --> 00:12:19,066
keep process下面的各个现成

378
00:12:19,266 --> 00:12:20,066
啊

379
00:12:20,566 --> 00:12:21,533
那么紧接着

380
00:12:21,700 --> 00:12:23,400
那么keeper size呢

381
00:12:23,566 --> 00:12:24,933
啊创建了啊

382
00:12:24,933 --> 00:12:26,366
不这个这个地方写错了

383
00:12:26,366 --> 00:12:27,566
这个地方不是folk了啊

384
00:12:27,566 --> 00:12:28,533
因为是这样

385
00:12:28,700 --> 00:12:31,500
那个这个随着这个版本的不同啊

386
00:12:31,500 --> 00:12:33,933
就是烂铜s也在这个不断的迭代啊

387
00:12:33,933 --> 00:12:34,966
也在不断的迭代

388
00:12:35,066 --> 00:12:36,966
那么在我们这个版本

389
00:12:36,966 --> 00:12:38,666
我们给你看这个版本里啊

390
00:12:38,666 --> 00:12:39,766
这个idol进程

391
00:12:39,800 --> 00:12:42,266
k k IDO进程是创也是创建出来的

392
00:12:42,266 --> 00:12:44,866
也是创建出来的并不是k process for出来

393
00:12:46,100 --> 00:12:47,900
那么内核钛党的讲到那的时候

394
00:12:47,900 --> 00:12:48,600
我们再说啊

395
00:12:48,600 --> 00:12:50,200
内核钛的所有进程呢

396
00:12:50,200 --> 00:12:53,100
都来自于2号进程子子孙孙代代相传

397
00:12:53,366 --> 00:12:54,533
形成一棵家族树

398
00:12:54,533 --> 00:12:56,699
和人类的传承有所不同啊

399
00:12:56,700 --> 00:12:58,300
他你看这个家族树是一样的

400
00:12:58,300 --> 00:13:00,000
但是和我们人类的传承有所不同

401
00:13:00,000 --> 00:13:00,933
他往往是什么呢

402
00:13:00,933 --> 00:13:02,466
白发人送黑发人

403
00:13:02,900 --> 00:13:05,000
紫禁城往往先于附近城退出

404
00:13:05,200 --> 00:13:08,566
由附近城呢为紫禁城处理退出后的

405
00:13:08,866 --> 00:13:10,799
退出的善后工作啊

406
00:13:10,800 --> 00:13:12,966
这是跟我们这个有相同点

407
00:13:12,966 --> 00:13:13,799
有不同点

408
00:13:15,666 --> 00:13:16,799
那我们具体来看一下

409
00:13:16,800 --> 00:13:19,266
下面我们具体来看一下这个k process

410
00:13:19,566 --> 00:13:21,099
被创建的过过程

411
00:13:21,333 --> 00:13:24,366
那么这就是这个OS system process Pro的函数

412
00:13:24,500 --> 00:13:25,866
那第一个它调用的函数

413
00:13:25,866 --> 00:13:26,799
这个函数非常重要

414
00:13:26,800 --> 00:13:28,733
就是OS process一逆的函数

415
00:13:28,800 --> 00:13:29,800
那这个函数干嘛呢

416
00:13:29,800 --> 00:13:31,933
就是初始化这些全局变量啊

417
00:13:31,933 --> 00:13:33,166
初始化这些全局变量

418
00:13:33,700 --> 00:13:35,800
然后呢看然后你看

419
00:13:36,000 --> 00:13:37,500
当他初始化这个全局变量的时候

420
00:13:37,500 --> 00:13:39,966
我们知道这个g科no init process

421
00:13:39,966 --> 00:13:41,166
在没有初始化的时候

422
00:13:41,166 --> 00:13:43,533
你看这一科no init process是一个无效值

423
00:13:44,066 --> 00:13:46,733
但是经过了这个OS process一met之后呢

424
00:13:46,733 --> 00:13:48,666
这个这个值就变成了啥呢

425
00:13:48,766 --> 00:13:50,333
这个值就变成了2啊

426
00:13:50,333 --> 00:13:51,999
2那么这这个红干嘛呢

427
00:13:52,000 --> 00:13:53,500
这个红就是从什么呢

428
00:13:53,733 --> 00:13:57,299
从这个啊从这个数组里啊g process CB啊

429
00:13:57,300 --> 00:13:58,133
瑞这个数组里

430
00:13:58,133 --> 00:14:00,866
把这个2号这个2号的PCB取来

431
00:14:00,933 --> 00:14:02,333
放到这个指针这儿啊

432
00:14:02,333 --> 00:14:04,666
所以kernel elite process指向了

433
00:14:04,966 --> 00:14:06,733
这个全局数组中呢

434
00:14:06,733 --> 00:14:10,333
第2号第二啊第2号这个啊

435
00:14:10,333 --> 00:14:11,699
第2号实体看到了吗

436
00:14:11,733 --> 00:14:13,499
获取进程池中的2号实体

437
00:14:13,500 --> 00:14:14,700
实体啊

438
00:14:14,700 --> 00:14:16,166
然后呢你看把这个

439
00:14:16,266 --> 00:14:17,899
这个实际上就是PCB对吧

440
00:14:17,900 --> 00:14:20,700
PCB然后你看它这个是mode看到了OS

441
00:14:20,700 --> 00:14:22,600
kernelmode所以这是什么意思呢

442
00:14:22,600 --> 00:14:24,566
然后它的名字叫做k process

443
00:14:24,566 --> 00:14:25,399
这是什么意思呢

444
00:14:25,400 --> 00:14:27,100
就是我获得了一个PCB

445
00:14:27,100 --> 00:14:29,366
然后呢我就怎么样用这个获得的PCB

446
00:14:29,366 --> 00:14:31,566
来初始化一个进程啊

447
00:14:31,566 --> 00:14:32,733
来创建一个进程

448
00:14:32,733 --> 00:14:33,899
来创建一个进程

449
00:14:34,066 --> 00:14:35,733
那么创建进程的时候呢

450
00:14:35,733 --> 00:14:36,866
你看把这个进程

451
00:14:37,133 --> 00:14:38,999
把这个进程的PCB传进来了

452
00:14:39,000 --> 00:14:40,200
把它的模式传进来了

453
00:14:40,200 --> 00:14:41,600
它是个内核模式的进程

454
00:14:41,766 --> 00:14:43,499
把这个进程的名字传进来了啊

455
00:14:43,500 --> 00:14:44,333
创建进程

456
00:14:44,900 --> 00:14:47,500
那么那么创建完了这个进程之后呢

457
00:14:47,500 --> 00:14:50,166
就把他的这个进程的状态看到了

458
00:14:50,166 --> 00:14:50,966
我创建完进程

459
00:14:50,966 --> 00:14:53,866
我这个进程状态就不再是一腻他了啊

460
00:14:53,866 --> 00:14:54,799
就不再是一腻他了

461
00:14:54,800 --> 00:14:57,266
看他把这个一腻他给去掉了

462
00:14:57,266 --> 00:14:58,399
看到了去掉了

463
00:14:58,533 --> 00:15:00,966
然后呢把这个进程看

464
00:15:01,533 --> 00:15:04,533
啊用这个进程初始化这个进程组啊

465
00:15:04,533 --> 00:15:05,399
进程组列表

466
00:15:06,100 --> 00:15:08,566
一个系统中包含很多的进程组啊

467
00:15:08,566 --> 00:15:09,699
很多的进程组

468
00:15:09,766 --> 00:15:12,099
那这些进程组呢构成了一个列表

469
00:15:12,100 --> 00:15:13,366
这个列表的手地值

470
00:15:13,400 --> 00:15:15,600
在这个全局变量g process group里

471
00:15:16,000 --> 00:15:17,766
就这个g process group啊

472
00:15:21,266 --> 00:15:21,933
好

473
00:15:21,933 --> 00:15:23,999
那么这是就是说

474
00:15:24,000 --> 00:15:25,766
首先你看他创建了一个进程

475
00:15:25,900 --> 00:15:27,600
然后呢把这个进程怎么样

476
00:15:27,600 --> 00:15:29,733
挂到全局的这个进程组里啊

477
00:15:29,733 --> 00:15:31,099
进程组列表列表里

478
00:15:31,100 --> 00:15:31,566
看到了吧

479
00:15:31,566 --> 00:15:33,999
这时这就完成了第一个工作

480
00:15:34,000 --> 00:15:36,400
第一个工作就是keep process啊

481
00:15:37,066 --> 00:15:38,499
k process的创建过程

482
00:15:38,500 --> 00:15:40,266
那创建完了k process之后呢

483
00:15:40,266 --> 00:15:41,366
你看他又创建谁

484
00:15:41,400 --> 00:15:43,600
他又开开始创建k idol

485
00:15:43,966 --> 00:15:45,166
k idol进程啊

486
00:15:45,166 --> 00:15:45,999
k idol进程

487
00:15:46,166 --> 00:15:46,766
那这个呢

488
00:15:46,766 --> 00:15:49,966
是首先是什么获得k idol进程的PCB

489
00:15:50,466 --> 00:15:53,866
然后呢对这个PCB进行初始化啊

490
00:15:53,866 --> 00:15:55,399
对这个PCB进行初始化

491
00:15:55,466 --> 00:15:56,266
看到了吧

492
00:15:57,000 --> 00:16:00,066
好然后呢把这个PCB呢你看啊

493
00:16:00,166 --> 00:16:01,199
把这个PCB

494
00:16:01,800 --> 00:16:03,933
你看啊我们看一下这个idol进程

495
00:16:04,100 --> 00:16:05,700
我们看下这idol进程

496
00:16:06,500 --> 00:16:07,333
idol进程

497
00:16:07,766 --> 00:16:09,133
啊idol进程

498
00:16:09,133 --> 00:16:11,666
没有啊这里头没有啊没有

499
00:16:13,266 --> 00:16:14,333
好我们看一下啊

500
00:16:14,333 --> 00:16:15,333
然后他怎么样呢

501
00:16:15,333 --> 00:16:17,899
你看你看啊他是这样的啊

502
00:16:18,166 --> 00:16:19,799
你看这是啥意思

503
00:16:19,800 --> 00:16:20,366
这是啥意思

504
00:16:20,366 --> 00:16:21,699
你看啊kernel

505
00:16:21,966 --> 00:16:24,299
你看idol进程的复进程号是谁

506
00:16:24,300 --> 00:16:24,500
你看

507
00:16:24,500 --> 00:16:27,066
这不是idol进程的parent process ID是谁

508
00:16:27,266 --> 00:16:30,466
是你看所以首先怎么样idol进程呢

509
00:16:30,566 --> 00:16:33,933
认谁认keeper size作为父亲啊

510
00:16:33,933 --> 00:16:34,733
作为父亲

511
00:16:34,766 --> 00:16:36,733
然后呢你看他就把这个什么

512
00:16:36,733 --> 00:16:38,966
你看他把这个idol进程通过

513
00:16:39,200 --> 00:16:41,666
slibing lease的这个指针挂到什么呢

514
00:16:41,666 --> 00:16:44,899
挂到这个他父亲的这个孩子列表里了

515
00:16:44,900 --> 00:16:45,400
因为什么

516
00:16:45,400 --> 00:16:46,566
因为你看我在这个地方

517
00:16:46,566 --> 00:16:49,966
你看idol进程任k process进程为负进程

518
00:16:49,966 --> 00:16:50,366
然后呢

519
00:16:50,366 --> 00:16:53,599
他就把自己挂到了这个啊kernel里啊

520
00:16:53,666 --> 00:16:56,299
就是这个k process的孩子进程列表里

521
00:16:56,766 --> 00:16:57,766
然后呢

522
00:16:58,466 --> 00:17:00,466
然后呢又处理一些组的信息

523
00:17:00,466 --> 00:17:02,199
看到了又处理处理一些组的信息

524
00:17:02,200 --> 00:17:03,966
进程组的信息啊

525
00:17:04,166 --> 00:17:06,866
然后呢最后呢就又处理一些共享数

526
00:17:06,866 --> 00:17:07,766
共享用户啊

527
00:17:07,766 --> 00:17:08,566
看到了吧

528
00:17:08,600 --> 00:17:10,466
这个呢是科no

529
00:17:10,600 --> 00:17:12,566
就是说你看这就是资源复制了

530
00:17:12,566 --> 00:17:13,766
为什么是资源复制呢

531
00:17:13,766 --> 00:17:15,266
这就是我们前面说的资源复制

532
00:17:15,266 --> 00:17:16,066
因为你看

533
00:17:16,600 --> 00:17:18,366
啊就是说尽管没有通过Fork

534
00:17:18,366 --> 00:17:20,366
但是呢你看它是通过这种显示的

535
00:17:20,366 --> 00:17:22,166
这个显性的这种写的方式

536
00:17:22,400 --> 00:17:23,200
让

537
00:17:23,700 --> 00:17:26,100
k process成为idol process的复进程

538
00:17:26,100 --> 00:17:27,500
然后呢是这样你看

539
00:17:27,666 --> 00:17:28,999
k process把自己的资源

540
00:17:29,000 --> 00:17:30,766
比如说用户资源还有文件资源

541
00:17:30,766 --> 00:17:31,999
复制给了这个

542
00:17:32,000 --> 00:17:34,266
看到了复制给了这个idol process

543
00:17:34,400 --> 00:17:36,766
然后呢把这样的话就完成这个

544
00:17:37,133 --> 00:17:40,366
就是PCB的一个PCB的一个完整初始化

545
00:17:40,366 --> 00:17:42,799
然后呢把这个PCB的process datas

546
00:17:43,533 --> 00:17:46,333
的这个init这个标志清空清除掉

547
00:17:46,333 --> 00:17:47,533
看到了吧清除掉

548
00:17:47,733 --> 00:17:51,499
然后呢就通过OS idoltosk create这个函数

549
00:17:51,500 --> 00:17:53,700
看到idoltosk create函数创建

550
00:17:53,966 --> 00:17:56,533
啊属于CPU的idol进程啊

551
00:17:56,533 --> 00:17:57,466
从此呢

552
00:17:58,100 --> 00:17:58,933
那这是什么意思

553
00:17:58,933 --> 00:18:00,733
这个实际上就是在这个函数里

554
00:18:00,733 --> 00:18:01,766
会什么呢

555
00:18:02,600 --> 00:18:03,533
在这个函数里呢

556
00:18:03,533 --> 00:18:07,699
会把这个呃idol函i k idol线程呢

557
00:18:07,700 --> 00:18:08,733
k idol进程呢

558
00:18:09,133 --> 00:18:11,666
设置到这个CPU的run q里啊

559
00:18:11,666 --> 00:18:12,599
CPU的run q里

560
00:18:12,600 --> 00:18:13,733
那这样的话呢

561
00:18:13,733 --> 00:18:15,366
就是说当CPU处于空闲的时候

562
00:18:15,366 --> 00:18:16,099
他就可以从run

563
00:18:16,100 --> 00:18:17,866
q里取出一个idol进程来运行

564
00:18:19,766 --> 00:18:20,866
好那么下面呢

565
00:18:20,866 --> 00:18:22,699
我们就重点看一下这些函数啊

566
00:18:22,700 --> 00:18:23,500
这些函数

567
00:18:23,900 --> 00:18:24,733
第一个函数是什么

568
00:18:24,733 --> 00:18:26,166
就是OS process in need

569
00:18:26,166 --> 00:18:27,999
就这个函数OS process in need

570
00:18:28,666 --> 00:18:29,599
那我们看一下啊

571
00:18:29,600 --> 00:18:30,733
首先你看啊

572
00:18:30,733 --> 00:18:33,866
它怎么样的g Pro size Max number它是什么呢

573
00:18:33,866 --> 00:18:35,499
这个是64

574
00:18:35,600 --> 00:18:36,200
也就是说

575
00:18:36,200 --> 00:18:40,000
整个这个系统支持的最大进程数是64

576
00:18:40,333 --> 00:18:41,666
然后呢size是什么呢

577
00:18:41,666 --> 00:18:43,999
就是你看我size of process CB

578
00:18:44,000 --> 00:18:44,400
就是说

579
00:18:44,400 --> 00:18:46,366
我怎么样申请这么大的一个内存空间

580
00:18:46,366 --> 00:18:48,766
就是64个PCB的内存空间

581
00:18:48,933 --> 00:18:50,466
然后从内存池中来

582
00:18:50,466 --> 00:18:52,899
怎么样获得一个连续内存空间

583
00:18:52,966 --> 00:18:54,766
然后让这个processcb

584
00:18:54,766 --> 00:18:56,733
呃锐这个指针指到了这个

585
00:18:56,966 --> 00:18:58,066
区间的手臂指

586
00:18:58,700 --> 00:19:00,066
啊这就是然后

587
00:19:00,066 --> 00:19:02,266
呢你看然后清除这个区间呢

588
00:19:02,400 --> 00:19:04,200
啊把这个区间清空

589
00:19:04,200 --> 00:19:04,866
看到了吧

590
00:19:04,866 --> 00:19:05,666
清空好

591
00:19:05,800 --> 00:19:08,300
然后呢初始化你看初始化这个这

592
00:19:08,800 --> 00:19:10,766
这这free process这是什么

593
00:19:10,766 --> 00:19:12,066
我们前面说这是一个什么

594
00:19:12,066 --> 00:19:14,933
DUAL link list的一个结构体对吧

595
00:19:14,933 --> 00:19:15,733
你看

596
00:19:16,066 --> 00:19:18,166
这是一个deor link list的结构体怎么样

597
00:19:18,166 --> 00:19:19,066
然后把它怎么样

598
00:19:19,066 --> 00:19:19,933
直空看到了吗

599
00:19:19,933 --> 00:19:21,266
直空初始化成什么呢

600
00:19:21,266 --> 00:19:22,299
初始化一个空表

601
00:19:22,466 --> 00:19:23,699
把这两个初始化空表

602
00:19:24,166 --> 00:19:24,733
然后呢

603
00:19:24,733 --> 00:19:27,499
你看通过一个four循环four 64次对吧

604
00:19:27,666 --> 00:19:30,899
每一个PCB的process ID都等于index

605
00:19:30,900 --> 00:19:32,133
然后呢你看它的标志

606
00:19:32,133 --> 00:19:34,866
每个PCB的process data都是没有用到的

607
00:19:34,866 --> 00:19:35,133
看到了吗

608
00:19:35,133 --> 00:19:36,399
on use的看到了

609
00:19:36,600 --> 00:19:37,066
然后呢

610
00:19:37,066 --> 00:19:39,866
把这些把每一个PCB通过它的Panda list

611
00:19:39,866 --> 00:19:41,399
连到了这个g free

612
00:19:41,866 --> 00:19:44,099
free process这个空列表里

613
00:19:44,100 --> 00:19:44,533
看到了吧

614
00:19:44,533 --> 00:19:46,299
那所以说这64个列表

615
00:19:46,866 --> 00:19:48,733
那么我们可以画一下啊

616
00:19:48,800 --> 00:19:50,166
那么你可以想象一下

617
00:19:50,166 --> 00:19:51,666
它就是这样的一个形状啊

618
00:19:51,666 --> 00:19:53,199
这就是一个数组

619
00:19:53,933 --> 00:19:55,299
PCB的数组看到了

620
00:19:55,300 --> 00:19:57,000
PCB的数组有64个一共

621
00:19:57,100 --> 00:19:57,900
看到了吧

622
00:19:57,900 --> 00:20:00,900
然后呢这个啊这个这个

623
00:20:01,966 --> 00:20:05,533
这个指针这个指针g process CBA re指向这

624
00:20:05,533 --> 00:20:06,266
看到了吧

625
00:20:06,266 --> 00:20:07,299
然后呢

626
00:20:07,366 --> 00:20:09,899
还有一个指针叫做g free process啊

627
00:20:09,900 --> 00:20:11,966
g for process这也是一个什么呢

628
00:20:11,966 --> 00:20:12,966
双向循环列表

629
00:20:13,133 --> 00:20:14,366
那这个指针指到哪呢

630
00:20:14,366 --> 00:20:16,099
指到第一个位置看到了吧

631
00:20:16,100 --> 00:20:17,733
然后怎么样咱们就

632
00:20:19,100 --> 00:20:21,166
啊一个一个的指这么指下来

633
00:20:21,666 --> 00:20:22,166
为什么呢

634
00:20:22,166 --> 00:20:24,466
因为在初始化的时候所有所有的这些

635
00:20:25,066 --> 00:20:27,333
PCB都是没有使用啊

636
00:20:27,333 --> 00:20:28,166
然后你再看

637
00:20:28,200 --> 00:20:30,666
那我们前面说过了啊我们前面说过了

638
00:20:30,666 --> 00:20:33,466
那么在在上一上一页啊

639
00:20:33,466 --> 00:20:34,899
在上一页你看在一开始的时候

640
00:20:34,900 --> 00:20:36,533
g user in need process

641
00:20:36,533 --> 00:20:39,333
g科no in process和g科no IDLE process

642
00:20:39,333 --> 00:20:40,333
他们的ID号

643
00:20:41,200 --> 00:20:42,066
都是什么呀

644
00:20:42,566 --> 00:20:43,699
都是无效之

645
00:20:43,700 --> 00:20:45,300
但是在这个初始化的过程中

646
00:20:45,300 --> 00:20:46,666
你看他是不是就把这个

647
00:20:46,800 --> 00:20:48,766
他们的ID号都给指成正确的

648
00:20:48,766 --> 00:20:50,866
看看idol进程的ID号就是02

649
00:20:51,200 --> 00:20:53,866
那么以need process的ID号就是一

650
00:20:54,600 --> 00:20:57,166
啊user盈利process的ID号是一

651
00:20:57,166 --> 00:20:59,299
kernel盈利process的ID号就是

652
00:20:59,566 --> 00:21:01,299
就是2 看到了吧

653
00:21:01,800 --> 00:21:04,666
啊这就完成了第一个函数的分析啊

654
00:21:05,066 --> 00:21:06,899
好那么下面我们干嘛呢

655
00:21:06,900 --> 00:21:08,733
下面我们就要分析这个OS Pro size

656
00:21:08,733 --> 00:21:09,899
Pro eight一net函数

657
00:21:09,900 --> 00:21:11,066
这个函数了

658
00:21:11,100 --> 00:21:12,066
当然还有一些这个

659
00:21:12,066 --> 00:21:13,299
你看这个这个也很简单

660
00:21:13,300 --> 00:21:15,166
这个成这个你看这个这个红

661
00:21:15,466 --> 00:21:16,299
这个红是啥呢

662
00:21:16,300 --> 00:21:19,933
就是说根据ID号来获得这个PCB指针

663
00:21:19,933 --> 00:21:20,366
看到了吧

664
00:21:20,366 --> 00:21:21,466
那这个就很简单了

665
00:21:21,466 --> 00:21:24,166
就是通过这个ID号来进行数度检索

666
00:21:24,766 --> 00:21:27,066
啊检索出来之后进行强制类型转换

667
00:21:27,300 --> 00:21:28,166
就可以了

668
00:21:28,566 --> 00:21:30,733
那好我们现在来看一下这个创建

669
00:21:31,133 --> 00:21:32,799
啊keep process的过程

670
00:21:33,333 --> 00:21:34,266
好那么

671
00:21:34,700 --> 00:21:36,533
我们看下这三个啊

672
00:21:36,766 --> 00:21:38,266
这个入口参数

673
00:21:38,333 --> 00:21:41,599
第一个是这个process的这个PCB结构体

674
00:21:41,866 --> 00:21:42,666
那第二个是什么

675
00:21:42,666 --> 00:21:45,366
第二个就是用户用户模式啊这个模式

676
00:21:45,400 --> 00:21:46,966
那我们知道这个k Pro size

677
00:21:46,966 --> 00:21:47,733
它是什么模式啊

678
00:21:47,733 --> 00:21:50,066
你看在这传的是一个内核模式对吧

679
00:21:50,100 --> 00:21:52,066
第三个是这个名字看到吧

680
00:21:52,133 --> 00:21:54,199
它首先用这三个变量

681
00:21:54,200 --> 00:21:56,966
用3这三个变量来初始化这个Pro

682
00:21:56,966 --> 00:21:58,533
size CB看到了吧

683
00:21:58,533 --> 00:22:01,599
触手袜这process b OSE的PCB看到了吧

684
00:22:01,700 --> 00:22:03,666
在这个地方你看在调用这个

685
00:22:03,700 --> 00:22:05,133
呃生成这个idol进程的时候

686
00:22:05,133 --> 00:22:07,199
也是首先调用这OSE的PCB

687
00:22:07,200 --> 00:22:08,000
看到了吧

688
00:22:08,000 --> 00:22:10,000
所以这个呢是对啊

689
00:22:10,100 --> 00:22:12,600
这个PCB进进程的PCB进行触手袜

690
00:22:13,066 --> 00:22:13,866
然后呢

691
00:22:14,100 --> 00:22:17,066
啊然后呢就是说啊再分配什么呢

692
00:22:17,066 --> 00:22:19,066
再分为这个文件系统啊

693
00:22:19,066 --> 00:22:21,099
为这个PCB分配一个什么呢

694
00:22:21,100 --> 00:22:23,566
文件指针啊文件类型那个数组吧

695
00:22:23,566 --> 00:22:24,899
或者说这是个数组

696
00:22:25,733 --> 00:22:27,966
啊就是比如说我们f open啊为什么呢

697
00:22:27,966 --> 00:22:28,933
因为每一个进程

698
00:22:28,933 --> 00:22:30,733
至少有三个打开的文件描述符

699
00:22:30,733 --> 00:22:32,899
分别是标准输入标准输出和

700
00:22:33,066 --> 00:22:34,333
错误输出啊

701
00:22:34,366 --> 00:22:36,999
所以这个文件呢得是一个数组啊

702
00:22:37,000 --> 00:22:37,800
得是个数组

703
00:22:38,366 --> 00:22:40,566
那么完成这个之后呢再怎么样呢

704
00:22:40,566 --> 00:22:43,966
再根据这个进程ID来创建一个什么呢

705
00:22:44,333 --> 00:22:45,999
进程组啊进程组

706
00:22:46,500 --> 00:22:48,733
然后呢再创建用户啊用户

707
00:22:48,733 --> 00:22:51,333
因为一个进程呢都属于一个用户啊

708
00:22:51,333 --> 00:22:52,133
创建用户

709
00:22:52,200 --> 00:22:54,166
那么啊我们主要看什么呢

710
00:22:54,166 --> 00:22:55,566
我们主要看一下这个PCB

711
00:22:55,566 --> 00:22:56,899
和文件部分啊

712
00:22:58,866 --> 00:23:01,299
首先我们看一下这个OS隐匿的PCB

713
00:23:01,933 --> 00:23:02,966
OS隐匿的PCB呢

714
00:23:02,966 --> 00:23:05,066
就是对process CB进行初始化

715
00:23:05,166 --> 00:23:07,199
首先我们看一下这个mode是什么呢

716
00:23:07,200 --> 00:23:09,000
就是这个用户模式啊

717
00:23:09,000 --> 00:23:10,133
用户它到底是什么

718
00:23:10,133 --> 00:23:11,766
用户模式还是内核模式

719
00:23:11,866 --> 00:23:13,733
所以你看它在这process CB

720
00:23:13,733 --> 00:23:15,499
process mode把这个复制好了

721
00:23:15,500 --> 00:23:16,866
看到了根据mode复值

722
00:23:17,400 --> 00:23:18,533
那么怎么样呢

723
00:23:18,533 --> 00:23:20,799
因为这个进程是初见阶段所以怎么样

724
00:23:20,800 --> 00:23:22,866
就是OS process datasinet

725
00:23:22,866 --> 00:23:24,733
表示进程的初始状态

726
00:23:25,333 --> 00:23:27,099
然后呢这个进程我们

727
00:23:27,100 --> 00:23:27,300
知道

728
00:23:27,300 --> 00:23:29,700
我们现在创建的这个进程是什么呢

729
00:23:30,166 --> 00:23:31,466
呃是keep

730
00:23:31,666 --> 00:23:32,899
当然这个是这样的啊

731
00:23:32,900 --> 00:23:33,966
这个process

732
00:23:33,966 --> 00:23:36,566
一开始在初始化任何进程PCB的时候

733
00:23:36,566 --> 00:23:38,499
它这个pirate process ID都是

734
00:23:38,500 --> 00:23:39,766
都是都是无效值的啊

735
00:23:39,766 --> 00:23:40,699
都是无效值的

736
00:23:40,800 --> 00:23:42,533
那么以后会随着这个

737
00:23:43,066 --> 00:23:45,966
就是以后会会会对这个直径修改啊

738
00:23:45,966 --> 00:23:47,099
会对这个直径修改

739
00:23:47,100 --> 00:23:49,400
当这个知道他的附近程是谁的时候

740
00:23:49,400 --> 00:23:51,566
就会对这parent process ID进行修改

741
00:23:52,100 --> 00:23:54,300
那么这个是线程组的ID

742
00:23:54,333 --> 00:23:55,133
线程组的ID是什么

743
00:23:55,133 --> 00:23:56,266
就是主线程的ID啊

744
00:23:56,266 --> 00:23:58,866
主线程的ID往往是这个进程的内函数

745
00:23:59,100 --> 00:23:59,900
根据这个

746
00:23:59,966 --> 00:24:01,966
这个线进程的内函数所创建的

747
00:24:01,966 --> 00:24:04,299
这个啊那个线程的ID啊

748
00:24:04,300 --> 00:24:05,100
线程的ID

749
00:24:05,966 --> 00:24:07,533
那么这个呢是野马啊

750
00:24:07,533 --> 00:24:08,599
timer ID啊

751
00:24:08,600 --> 00:24:11,966
timer ID这个进程相关的一些时间啊

752
00:24:11,966 --> 00:24:13,333
时间相关一些东西啊

753
00:24:13,666 --> 00:24:15,499
然后呢下面就是什么呢

754
00:24:15,500 --> 00:24:17,333
下面就是把这个进程啊

755
00:24:17,333 --> 00:24:19,533
插入到相应的这个队列里啊

756
00:24:19,533 --> 00:24:20,733
相应的队列里

757
00:24:20,733 --> 00:24:21,533
你看

758
00:24:21,533 --> 00:24:23,333
就是哎不是插入到相应的队列里

759
00:24:23,333 --> 00:24:25,133
因为我们知道这个进程有很多队列

760
00:24:25,133 --> 00:24:27,399
对吧比如说啊他这个

761
00:24:27,900 --> 00:24:30,266
他到底这个他的这个

762
00:24:30,600 --> 00:24:31,900
嗯初始化

763
00:24:31,933 --> 00:24:32,933
初始化孩子

764
00:24:33,000 --> 00:24:35,933
就是说这个进程有很多子子子县城

765
00:24:35,933 --> 00:24:37,933
一个进程包含很多子县城啊

766
00:24:38,300 --> 00:24:40,066
那么这是紫线程的列表

767
00:24:40,400 --> 00:24:42,300
那这个是紫进程的列表啊

768
00:24:42,300 --> 00:24:44,466
紫进程紫线程紫进程不一样啊

769
00:24:44,500 --> 00:24:46,400
那这个是退出进程啊

770
00:24:46,400 --> 00:24:48,366
他的紫进程的退出列表

771
00:24:48,533 --> 00:24:50,266
那这个呢是什么呢

772
00:24:50,300 --> 00:24:51,866
这个是等待列表啊

773
00:24:51,866 --> 00:24:52,666
等待列表

774
00:24:53,500 --> 00:24:55,566
就是说这个进程它有线程

775
00:24:55,600 --> 00:24:58,600
某一个线程调用了wait PID或者wait系

776
00:24:58,600 --> 00:25:01,866
统调用那么这个task strap就会挂载在

777
00:25:01,866 --> 00:25:03,399
挂在这个wait list里

778
00:25:03,400 --> 00:25:04,366
后面我们再讲wait

779
00:25:04,366 --> 00:25:06,599
系统调用的时候会提到这个事情啊

780
00:25:07,333 --> 00:25:08,999
提到这个事情好

781
00:25:09,166 --> 00:25:10,099
那么然后呢

782
00:25:10,100 --> 00:25:11,133
他会判断啊

783
00:25:11,133 --> 00:25:13,999
OS process is user mode它就会判断

784
00:25:14,133 --> 00:25:16,299
当前这个进程你看在这个地方不是

785
00:25:16,800 --> 00:25:17,600
这地方不有了吗

786
00:25:17,600 --> 00:25:18,800
对吧当前进程

787
00:25:18,800 --> 00:25:20,533
他的到底是一个内核态的

788
00:25:20,533 --> 00:25:21,666
还是用户态的

789
00:25:21,700 --> 00:25:24,466
所以他会判断当前进程是用户态的吗

790
00:25:24,466 --> 00:25:25,333
是用户态进程吗

791
00:25:25,333 --> 00:25:26,299
如果是的话

792
00:25:26,333 --> 00:25:28,533
那么就要创建用户空间啊

793
00:25:28,533 --> 00:25:29,733
用户进程空间

794
00:25:30,300 --> 00:25:32,533
啊或者是用户内存空间啊

795
00:25:32,733 --> 00:25:33,266
为什么呢

796
00:25:33,266 --> 00:25:34,866
因为我们前面说过了啊

797
00:25:34,866 --> 00:25:36,199
用户态的进程

798
00:25:36,200 --> 00:25:38,566
每一个进程都拥有自己独立的进程

799
00:25:38,566 --> 00:25:39,599
虚拟地主空间

800
00:25:39,900 --> 00:25:40,533
对吧

801
00:25:40,533 --> 00:25:43,133
那么内核否则的话你看所以你看

802
00:25:43,133 --> 00:25:43,699
所以如果

803
00:25:43,700 --> 00:25:45,666
要是创建的是一个用户态进程的话

804
00:25:45,666 --> 00:25:46,466
我就必须要

805
00:25:46,466 --> 00:25:48,499
为这个用户态进程创建一个独立的

806
00:25:49,000 --> 00:25:50,866
啊用户地质空间虚拟地质空间

807
00:25:50,866 --> 00:25:51,933
否则的话表示什么

808
00:25:51,933 --> 00:25:52,866
否则我现在创业

809
00:25:52,866 --> 00:25:54,366
这个进程是内核态进程

810
00:25:54,533 --> 00:25:55,766
那么内核态进程怎么样

811
00:25:55,766 --> 00:25:57,699
共享同一个内核空间

812
00:25:57,700 --> 00:26:00,366
所以在这lost get kernel VM space

813
00:26:00,366 --> 00:26:03,866
这就是所有内核进程共用的这个

814
00:26:03,966 --> 00:26:05,533
内核态的虚拟地质空间

815
00:26:06,466 --> 00:26:09,199
所以这就是啊最主要的这些东西啊

816
00:26:09,200 --> 00:26:10,133
最主要的东西

817
00:26:11,133 --> 00:26:11,933
那么

818
00:26:12,066 --> 00:26:14,333
剩下的嗯剩下的就没什么可说的啊

819
00:26:14,333 --> 00:26:15,299
剩下没有什么可说

820
00:26:15,300 --> 00:26:17,133
那在这个地方呢就是创建

821
00:26:17,466 --> 00:26:19,999
这个函数就是在这啊创建啊

822
00:26:20,000 --> 00:26:22,400
创建用户的这个虚拟地址空间

823
00:26:22,533 --> 00:26:23,299
那么创建

824
00:26:23,300 --> 00:26:25,066
怎么创建用户的虚拟地址空间呢

825
00:26:25,066 --> 00:26:27,099
因为我们知道用户的虚拟地址空间

826
00:26:27,133 --> 00:26:28,499
后面我们也会详细讲啊

827
00:26:28,500 --> 00:26:30,200
这个函数我们会展开详细讲

828
00:26:30,666 --> 00:26:31,199
啊讲一讲

829
00:26:31,200 --> 00:26:33,200
那么在这个地方我们简单说一下啊

830
00:26:33,200 --> 00:26:33,900
这是什么意思呢

831
00:26:33,900 --> 00:26:35,900
就是首先我要从内存缓冲

832
00:26:35,966 --> 00:26:38,666
内存池中啊申请一个lost VM space

833
00:26:38,666 --> 00:26:39,666
这个lost VM space

834
00:26:39,666 --> 00:26:41,866
这个也是个非常复杂的结构体啊

835
00:26:41,933 --> 00:26:44,533
它就表示用户的整个的一个虚拟空间

836
00:26:44,533 --> 00:26:45,666
既包含虚拟空间

837
00:26:45,666 --> 00:26:47,199
也包含虚实影射的列表

838
00:26:47,766 --> 00:26:48,866
啊趋势影车的列表

839
00:26:49,166 --> 00:26:51,133
然后呢就开始啊

840
00:26:51,133 --> 00:26:54,099
你看调用物理内存的这个分配函数

841
00:26:54,100 --> 00:26:55,566
那这个函数呢就会

842
00:26:56,066 --> 00:26:58,499
呃调用这个会调用采用什么呢

843
00:26:58,500 --> 00:27:00,133
采用我们说的这个

844
00:27:00,133 --> 00:27:01,866
就是那叫伙伴算法啊

845
00:27:01,866 --> 00:27:03,499
分配一些连续的页

846
00:27:03,700 --> 00:27:06,133
一个页大概是4K来保存一些页表

847
00:27:06,166 --> 00:27:07,699
看到了吧保存一些页表

848
00:27:08,166 --> 00:27:10,866
然后呢对用户空间进行初始化啊

849
00:27:10,866 --> 00:27:12,499
对用户空间进行初始化

850
00:27:12,766 --> 00:27:14,366
然后呢建立什么呢

851
00:27:14,600 --> 00:27:15,533
然后怎么样

852
00:27:16,100 --> 00:27:18,366
建立一些虚实影射啊等等等等

853
00:27:18,500 --> 00:27:21,300
那如果要是失败的话就失败了啊

854
00:27:21,300 --> 00:27:23,100
就怎么样返回错误

855
00:27:23,166 --> 00:27:24,866
否则的话呢就把这个

856
00:27:25,200 --> 00:27:27,566
成功的建立的这个space指针啊

857
00:27:27,566 --> 00:27:28,899
space指针返回来

858
00:27:29,000 --> 00:27:29,600
那就表示

859
00:27:29,600 --> 00:27:30,200
这个进程

860
00:27:30,200 --> 00:27:32,800
已经拥有了自己独立的内扣空间啊

861
00:27:32,800 --> 00:27:34,300
用户空间啊用户空间

862
00:27:34,500 --> 00:27:35,300
那这个

863
00:27:35,866 --> 00:27:39,599
啊loss get KVM space呢这是什么意思

864
00:27:39,600 --> 00:27:40,566
你看这就很简单

865
00:27:40,566 --> 00:27:42,466
因为所有的用户

866
00:27:42,466 --> 00:27:44,966
所有的内核进程呢都具有相同的

867
00:27:45,400 --> 00:27:45,933
地质空间

868
00:27:45,933 --> 00:27:47,666
所以他这个这个地质空间呢

869
00:27:47,666 --> 00:27:49,899
在系统初始化的时候就已经创建了啊

870
00:27:49,933 --> 00:27:51,366
系统初始化的时候就已经

871
00:27:51,400 --> 00:27:53,366
创建好了这个内核的地质空间

872
00:27:53,566 --> 00:27:55,366
那么并且把这个内核的地质空间

873
00:27:55,366 --> 00:27:56,499
保存到这个

874
00:27:57,100 --> 00:27:57,666
内核虚拟

875
00:27:57,666 --> 00:27:59,666
技术空间把保存在这个全局变量

876
00:27:59,666 --> 00:28:01,366
叫做g current VM

877
00:28:01,400 --> 00:28:03,700
space里所以说对于内核进程

878
00:28:03,700 --> 00:28:05,566
我只要返回这个全局变量就可以了

879
00:28:07,700 --> 00:28:09,400
好我们再看一下下一个是什么呢

880
00:28:09,400 --> 00:28:10,933
这个是初始化啊

881
00:28:10,933 --> 00:28:12,533
初始化PCB对吧PCB

882
00:28:12,766 --> 00:28:13,699
那下一个是什么

883
00:28:13,700 --> 00:28:16,400
下一个是未进程分配文件

884
00:28:16,500 --> 00:28:18,666
那我们知道啊你看我们现在怎么样呢

885
00:28:19,466 --> 00:28:20,766
对于进程来讲

886
00:28:20,933 --> 00:28:21,466
我们说

887
00:28:21,466 --> 00:28:24,599
进程在Letos中是资源拥有的基本单位

888
00:28:24,600 --> 00:28:27,300
那最最重要的两类资源是什么

889
00:28:27,300 --> 00:28:29,566
一类是内存资源一类就是文件资源

890
00:28:29,666 --> 00:28:30,533
那我们刚才

891
00:28:30,566 --> 00:28:33,166
给大家稍微简单介绍一下内内存资源

892
00:28:33,300 --> 00:28:35,366
那现在我们再说一下这个文件资源

893
00:28:35,700 --> 00:28:37,666
那么文件资源是通过alog FILES

894
00:28:37,666 --> 00:28:38,699
这个函数来

895
00:28:38,766 --> 00:28:40,566
嗯来来分配的啊

896
00:28:40,700 --> 00:28:42,066
首先我们来看一下啊

897
00:28:42,066 --> 00:28:43,866
那么首先我们看一下

898
00:28:43,866 --> 00:28:45,999
那这有一个files strock的结构体

899
00:28:46,000 --> 00:28:47,700
看到了files strock结构体

900
00:28:47,766 --> 00:28:48,699
那这个是什么呢

901
00:28:48,700 --> 00:28:49,733
这个就是啊

902
00:28:49,733 --> 00:28:50,466
这个是什么呢

903
00:28:50,466 --> 00:28:52,266
这个就是一个文件描述符表

904
00:28:52,866 --> 00:28:54,766
那么我们看这个文件描述符表中

905
00:28:54,766 --> 00:28:55,866
最重要的是什么呢

906
00:28:55,866 --> 00:29:00,099
就是f d table filed discriptor table啊这个指针

907
00:29:00,100 --> 00:29:01,100
看到了这个指针

908
00:29:01,166 --> 00:29:01,799
所以你看啊

909
00:29:01,800 --> 00:29:02,800
在这个地方啊

910
00:29:02,800 --> 00:29:05,200
它首先是分配了一个从啊

911
00:29:05,200 --> 00:29:05,900
内存池中

912
00:29:05,900 --> 00:29:07,700
分配了一个FILES strap的结构体

913
00:29:07,700 --> 00:29:08,866
给这个FILES指针

914
00:29:09,500 --> 00:29:10,800
看到了吧files指针

915
00:29:11,066 --> 00:29:12,299
然后呢我们再看

916
00:29:12,366 --> 00:29:16,266
然后它又通过i look file descript table啊

917
00:29:16,400 --> 00:29:18,600
然后number open default这也是个红

918
00:29:18,600 --> 00:29:20,200
这也是个红表示啊

919
00:29:20,333 --> 00:29:21,666
那你看这是一个指针

920
00:29:21,700 --> 00:29:22,533
这又是一个指针

921
00:29:22,533 --> 00:29:23,166
看到了吧

922
00:29:23,166 --> 00:29:24,099
那这个指针呢

923
00:29:24,100 --> 00:29:25,266
指向了一个这样的一个结

924
00:29:25,266 --> 00:29:26,499
构体在这个结构体里

925
00:29:26,500 --> 00:29:28,566
有一个指针指向了一个数组啊

926
00:29:28,566 --> 00:29:29,366
只剩一个数组

927
00:29:29,366 --> 00:29:31,499
那这个数组的个数是这样确定的

928
00:29:31,500 --> 00:29:33,600
那下面我看一下i look FD

929
00:29:34,166 --> 00:29:36,399
啊i look FD table这个函数

930
00:29:36,400 --> 00:29:39,300
这numbers就是这个数组中所包含的

931
00:29:39,300 --> 00:29:40,400
项数啊

932
00:29:40,400 --> 00:29:42,200
比如说1020之类的

933
00:29:42,300 --> 00:29:44,100
表示啊表示什么呢

934
00:29:44,100 --> 00:29:45,900
我这个这个我们可以具体看一下

935
00:29:45,900 --> 00:29:47,400
待会我们可以具体看一下这个

936
00:29:47,400 --> 00:29:49,133
在线下的课程中我们可以看一下

937
00:29:49,333 --> 00:29:51,666
他到底那个默认值是多少啊

938
00:29:51,666 --> 00:29:52,399
那表示什么呢

939
00:29:52,400 --> 00:29:53,366
表示这个

940
00:29:53,366 --> 00:29:56,099
一个进程最多可以打开的文件数啊

941
00:29:56,100 --> 00:29:58,066
一个进程最多的可以打开的文件数

942
00:29:58,400 --> 00:29:59,900
那我们看一下这个i look

943
00:30:00,266 --> 00:30:01,733
FD table是什么意思啊

944
00:30:01,866 --> 00:30:03,699
首先你看i look FD table

945
00:30:03,700 --> 00:30:05,166
有一个这个指针啊

946
00:30:05,166 --> 00:30:08,666
有一这个结构题叫做FILES file table杠s

947
00:30:08,966 --> 00:30:11,066
啊file table杠s啊

948
00:30:11,133 --> 00:30:13,899
这个就是file table杠s的这么一个

949
00:30:14,733 --> 00:30:15,766
啊这么一个结构体

950
00:30:15,766 --> 00:30:16,866
这么一个结构体

951
00:30:17,066 --> 00:30:18,699
然后呢每一个结构体呢

952
00:30:18,700 --> 00:30:20,466
你看啊他申请了多少个呢

953
00:30:20,466 --> 00:30:23,133
从内存池中申请了numbers

954
00:30:23,133 --> 00:30:25,866
就是这个numbers乘以这么多的一个

955
00:30:26,000 --> 00:30:26,933
这么多啊

956
00:30:27,266 --> 00:30:29,066
那么申请这么一多的一个data

957
00:30:29,066 --> 00:30:30,733
然后把这个data付给他了

958
00:30:30,766 --> 00:30:32,333
然后呢你看啊哎

959
00:30:32,333 --> 00:30:33,466
最最重要在这呢

960
00:30:33,466 --> 00:30:34,766
看到最重要在这呢

961
00:30:34,900 --> 00:30:36,500
然后你看他哎

962
00:30:36,500 --> 00:30:38,300
放给这个付给付

963
00:30:38,300 --> 00:30:40,066
把这个data付给他之后呢

964
00:30:40,066 --> 00:30:40,699
那大家看

965
00:30:40,700 --> 00:30:42,533
data实际上就是一个数组对吧

966
00:30:42,533 --> 00:30:43,299
然后你看啊

967
00:30:43,300 --> 00:30:46,766
他对这个DI个这个数组的DI个节点呢

968
00:30:46,766 --> 00:30:51,666
SYSFD看到了SYSFD这个

969
00:30:52,733 --> 00:30:54,799
这个原组啊赋予了-1

970
00:30:54,800 --> 00:30:56,000
啊赋赋予了-1

971
00:30:56,000 --> 00:30:58,000
这是什么叫做系统文件描述符

972
00:30:58,100 --> 00:30:59,533
那我们前面这个叫什么呢

973
00:30:59,533 --> 00:31:02,366
前面叫做process进程文件描述符

974
00:31:02,566 --> 00:31:05,899
这个i啊是由这个i实际上是

975
00:31:06,466 --> 00:31:09,366
进程啊process file descriptor

976
00:31:09,533 --> 00:31:10,799
而而这个

977
00:31:11,000 --> 00:31:11,866
而这个是什么

978
00:31:11,866 --> 00:31:15,166
还有一个个叫做system file file descriptor

979
00:31:15,166 --> 00:31:16,466
那么它俩有什么区别呢

980
00:31:16,466 --> 00:31:18,899
后面我们也会给大家介绍啊

981
00:31:18,900 --> 00:31:20,566
后面也会给大家进行介绍

982
00:31:21,200 --> 00:31:23,600
然后呢你看但是-1是一个无效值啊

983
00:31:23,600 --> 00:31:25,733
他在在这初始化完了之后都是什么

984
00:31:25,733 --> 00:31:26,566
都是无效值

985
00:31:26,566 --> 00:31:26,966
看到了吗

986
00:31:26,966 --> 00:31:28,966
都是无效值

987
00:31:31,366 --> 00:31:32,566
啊都是无效纸

988
00:31:32,666 --> 00:31:34,499
我看一下啊这是

989
00:31:35,800 --> 00:31:38,166
啊然后呢你看啊我们说过了啊

990
00:31:38,166 --> 00:31:39,599
对于这个文件描述符

991
00:31:39,600 --> 00:31:41,400
有三个值是非常重要的

992
00:31:41,400 --> 00:31:43,300
所以一个是第一个位置

993
00:31:43,300 --> 00:31:45,300
第0个位置第一个位置和第2个位置

994
00:31:45,400 --> 00:31:46,166
所以你看啊

995
00:31:46,166 --> 00:31:49,133
他对这三个位置单独调用了l和STD

996
00:31:49,133 --> 00:31:50,299
f d这个函数

997
00:31:50,666 --> 00:31:53,499
分别对这个啊012这三个位置

998
00:31:53,500 --> 00:31:54,733
你看这个FT

999
00:31:55,333 --> 00:31:59,166
FDS这个012的三个位置分别赋予了012

1000
00:31:59,166 --> 00:32:00,766
啊这个是什么原因呢

1001
00:32:00,766 --> 00:32:03,166
我们我们在线下课程给大家进行介绍

1002
00:32:03,166 --> 00:32:03,966
啊

1003
00:32:06,000 --> 00:32:07,500
那最后一部分是什么呢

1004
00:32:07,500 --> 00:32:08,900
最后一部分就是说你看

1005
00:32:08,933 --> 00:32:09,899
我们现在怎么样

1006
00:32:09,900 --> 00:32:11,300
你看我们整个创建的过程

1007
00:32:11,300 --> 00:32:12,500
我们这进程创建过程

1008
00:32:12,500 --> 00:32:14,200
首先是对PCB进行初始化

1009
00:32:14,366 --> 00:32:14,899
然后呢

1010
00:32:14,900 --> 00:32:17,800
在这个地方对它的内存啊赋予它内存

1011
00:32:18,066 --> 00:32:19,333
然后内存空间

1012
00:32:19,333 --> 00:32:20,899
然后呢对文件进行初始化

1013
00:32:20,900 --> 00:32:21,700
最后一部分呢

1014
00:32:21,700 --> 00:32:25,133
就是把这个进程挂到某一个进程组里

1015
00:32:25,333 --> 00:32:27,266
啊那这个呢就是把这个进程

1016
00:32:27,500 --> 00:32:29,066
挂到了某一个进程组里

1017
00:32:29,066 --> 00:32:30,099
或者是以这个进程

1018
00:32:30,100 --> 00:32:32,500
为进程组的组长来创建一个进程组

1019
00:32:33,066 --> 00:32:33,899
啊你看在这呢

1020
00:32:33,900 --> 00:32:36,366
就是首先就是说他创建了一个进程组

1021
00:32:36,366 --> 00:32:36,966
看到了吧

1022
00:32:36,966 --> 00:32:38,599
你看申请了一个process group

1023
00:32:38,600 --> 00:32:39,900
的这么一个数据结构

1024
00:32:40,166 --> 00:32:40,966
看到了吧

1025
00:32:41,133 --> 00:32:43,466
然后呢把这个进程的PID啊

1026
00:32:43,466 --> 00:32:46,199
作为这个group ID的这个进程组的组长

1027
00:32:46,300 --> 00:32:48,666
然后初始化这个进程组的两个

1028
00:32:49,300 --> 00:32:49,466
啊

1029
00:32:49,466 --> 00:32:52,766
初始化这个进程组的这个两个指针啊

1030
00:32:52,766 --> 00:32:53,566
两个指针

1031
00:32:54,466 --> 00:32:56,266
然后呢把这个进程啊

1032
00:32:56,266 --> 00:32:58,299
放到这个进程组里作为一个

1033
00:32:58,333 --> 00:33:01,566
作为首你看啊这是tail啊tail insert

1034
00:33:01,666 --> 00:33:02,933
看到了tail insert

1035
00:33:02,966 --> 00:33:04,999
把这个进程通过subordinate

1036
00:33:05,066 --> 00:33:06,199
格入police的这个指针

1037
00:33:06,200 --> 00:33:08,400
挂到这个进程组列表里啊

1038
00:33:08,600 --> 00:33:09,066
也就是说

1039
00:33:09,066 --> 00:33:11,799
这个进程组下辖多少个进程啊

1040
00:33:11,966 --> 00:33:13,166
它本身就是一个

1041
00:33:13,866 --> 00:33:16,866
然后呢自己把自己标识成

1042
00:33:16,866 --> 00:33:18,533
因为他是创建这个进程组的

1043
00:33:18,533 --> 00:33:19,566
所以他把自己

1044
00:33:19,566 --> 00:33:21,599
标识成是这个进程组的leader

1045
00:33:21,600 --> 00:33:22,400
看到了吗

1046
00:33:22,466 --> 00:33:23,666
这个进程组的leader

1047
00:33:26,300 --> 00:33:29,266
那么这就是整个的这个

1048
00:33:30,300 --> 00:33:31,800
整个的一个这个

1049
00:33:31,900 --> 00:33:35,366
我们再看一下这个OS system process create啊

1050
00:33:36,333 --> 00:33:36,999
啊你看

1051
00:33:37,000 --> 00:33:39,500
当我们调用完了这个函数之后啊

1052
00:33:39,500 --> 00:33:41,566
你看这是这个这个函数

1053
00:33:41,733 --> 00:33:42,533
这个函数

1054
00:33:43,533 --> 00:33:46,099
我看一下啊啊啊

1055
00:33:46,100 --> 00:33:47,666
这个函数看这

1056
00:33:47,666 --> 00:33:49,066
因为我我们隔太远了

1057
00:33:49,066 --> 00:33:50,866
所以我们把这个又超过来了啊

1058
00:33:50,866 --> 00:33:51,533
那这个地方

1059
00:33:51,533 --> 00:33:54,299
我们就怎么样通过这个OS process create

1060
00:33:54,533 --> 00:33:56,733
的函数就完成了这个创建的过程

1061
00:33:56,966 --> 00:33:59,333
创建完了之后呢你看啊这这就是这个

1062
00:34:00,400 --> 00:34:00,866
啊

1063
00:34:00,866 --> 00:34:01,799
完成创建过程之后

1064
00:34:01,800 --> 00:34:04,766
我们就怎么样清除这个process datas in it

1065
00:34:04,766 --> 00:34:06,666
这个标标志啊

1066
00:34:06,666 --> 00:34:07,899
标志然后呢

1067
00:34:07,900 --> 00:34:10,266
因为现在这个我们创建的是这个

1068
00:34:10,266 --> 00:34:12,666
corner process它是第一个未创建的进程

1069
00:34:13,100 --> 00:34:13,866
所以怎么样呢

1070
00:34:13,866 --> 00:34:16,066
就把这个它的group

1071
00:34:16,200 --> 00:34:18,700
这个指针付给了这个g process group

1072
00:34:18,900 --> 00:34:19,300
为什么呢

1073
00:34:19,300 --> 00:34:20,300
因为它是第一个创建的

1074
00:34:20,300 --> 00:34:21,600
而且它是group leader

1075
00:34:21,666 --> 00:34:24,933
所以这个整个系统的这个进程组

1076
00:34:25,300 --> 00:34:28,600
啊就以这个进程组为第一个节点啊

1077
00:34:28,600 --> 00:34:29,600
为第一个节点

1078
00:34:31,133 --> 00:34:31,933
好

1079
00:34:34,066 --> 00:34:35,366
那么到目前为止呢

1080
00:34:35,366 --> 00:34:37,599
我们就完成了第一个就是

1081
00:34:37,766 --> 00:34:40,699
caprsize进程的创建的讲解

1082
00:34:40,866 --> 00:34:43,533
那下面我们来介绍一下这个第二个

1083
00:34:43,666 --> 00:34:44,866
被创建的进程

1084
00:34:45,066 --> 00:34:48,999
也就是第0号进程也就是OS idotask idotos

1085
00:34:49,166 --> 00:34:50,566
那么这个iotos哥呢

1086
00:34:50,566 --> 00:34:52,533
我们我们前面再看一下这代码啊

1087
00:34:52,533 --> 00:34:53,666
再看一下这代码

1088
00:34:53,766 --> 00:34:54,533
那么你看啊

1089
00:34:54,533 --> 00:34:56,799
我创建完了corner process之后呢

1090
00:34:56,800 --> 00:34:58,666
这个idle process

1091
00:34:58,666 --> 00:35:01,266
我已经完成这个TCB的这么一个

1092
00:35:01,266 --> 00:35:02,333
PCB的初始化

1093
00:35:02,866 --> 00:35:04,599
这个PCB初始化对于科process

1094
00:35:04,600 --> 00:35:07,000
都在这个OS process create里完成了

1095
00:35:07,000 --> 00:35:10,200
对吧但是它在这个地方对idle process呢

1096
00:35:10,200 --> 00:35:11,800
它单独做了这个

1097
00:35:11,800 --> 00:35:14,333
然后呢又把它插到各个这个列表里了

1098
00:35:14,333 --> 00:35:16,599
看到吧把这插到各个列表里了

1099
00:35:16,600 --> 00:35:18,566
然后也共享资源看到了吧

1100
00:35:18,566 --> 00:35:22,499
那最后呢通过这个OS idol process create

1101
00:35:22,966 --> 00:35:23,699
来怎么样呢

1102
00:35:23,700 --> 00:35:24,600
我们看一下这个

1103
00:35:25,666 --> 00:35:27,699
看一下这个这个函数干嘛了啊

1104
00:35:27,700 --> 00:35:28,733
这个函数干嘛了

1105
00:35:28,900 --> 00:35:29,933
那我们知道啊

1106
00:35:29,933 --> 00:35:31,999
就是说这个idle process呢你看啊

1107
00:35:32,000 --> 00:35:32,966
它干嘛了呢

1108
00:35:33,200 --> 00:35:34,000
它

1109
00:35:34,366 --> 00:35:36,066
啊创建了一个task啊

1110
00:35:36,066 --> 00:35:37,566
他创建了一个task啊

1111
00:35:37,566 --> 00:35:39,333
啊他创建一个idol task

1112
00:35:39,466 --> 00:35:40,733
在创建IDO task的时候

1113
00:35:40,733 --> 00:35:43,666
也就是说大家想一想这个idol idol进程

1114
00:35:43,966 --> 00:35:46,699
idol进程比较比较有意思啊他

1115
00:35:46,700 --> 00:35:47,133
是什么呢

1116
00:35:47,133 --> 00:35:48,599
他是在内核怎么样

1117
00:35:48,600 --> 00:35:50,733
他是在内核空闲的时候执行的任务

1118
00:35:50,766 --> 00:35:52,366
那也就说提到了执行

1119
00:35:52,366 --> 00:35:54,566
那执行的话就肯定要执行代码是不是

1120
00:35:54,566 --> 00:35:56,133
执行代码好我们看一下啊

1121
00:35:56,133 --> 00:35:57,766
那执行代码就是计算

1122
00:35:57,900 --> 00:35:59,166
计算具有什么来完成

1123
00:35:59,166 --> 00:36:00,533
是由task来完成的对吧

1124
00:36:00,533 --> 00:36:02,166
所以你看他在这个地方呢

1125
00:36:02,300 --> 00:36:03,866
首先申请了一个

1126
00:36:04,366 --> 00:36:06,333
申请了一个就是啊

1127
00:36:06,500 --> 00:36:09,100
这有一个局部变量叫task e need parameter

1128
00:36:09,166 --> 00:36:11,333
那这个就是任务初始化参数

1129
00:36:11,333 --> 00:36:13,166
看到了吧这样的一个数据结构体

1130
00:36:13,300 --> 00:36:13,866
然后呢

1131
00:36:13,866 --> 00:36:15,933
我根据然后你看它在这个地方

1132
00:36:15,933 --> 00:36:16,766
对task个结构体

1133
00:36:16,766 --> 00:36:18,933
首先对这个task一need parameter

1134
00:36:18,933 --> 00:36:20,266
这个结构体怎么样

1135
00:36:20,266 --> 00:36:21,066
清空

1136
00:36:21,100 --> 00:36:23,133
然后清空之后你看啊在这怎么样

1137
00:36:23,566 --> 00:36:26,766
function啊function task entry等于这个

1138
00:36:26,766 --> 00:36:27,299
那这是什么

1139
00:36:27,300 --> 00:36:29,466
这就是要欠要进行啊

1140
00:36:29,466 --> 00:36:31,499
要运行现成的一个入口函数啊

1141
00:36:31,500 --> 00:36:32,300
入口函数

1142
00:36:32,333 --> 00:36:34,133
那也就是说比如说现在踏

1143
00:36:34,266 --> 00:36:36,199
比如说现在呢内存啊

1144
00:36:36,200 --> 00:36:39,066
比如说现在呢CPU处于空闲了

1145
00:36:39,133 --> 00:36:42,466
要要idle idle任务来运行它运行什么

1146
00:36:42,466 --> 00:36:43,599
它就运行这个函数

1147
00:36:44,066 --> 00:36:46,133
懂了吧所以这个非常简单啊

1148
00:36:46,133 --> 00:36:46,766
这个非常简单

1149
00:36:46,766 --> 00:36:48,299
你让你要想让核心

1150
00:36:48,500 --> 00:36:49,933
内核线程运行什么函数

1151
00:36:49,933 --> 00:36:51,166
你就把这个函数编好

1152
00:36:51,266 --> 00:36:52,866
然后这样这样写好

1153
00:36:52,866 --> 00:36:53,399
把这个

1154
00:36:53,400 --> 00:36:56,333
把这个函数名付给这个PFN task entry

1155
00:36:56,333 --> 00:36:57,066
就可以了

1156
00:36:57,066 --> 00:36:58,099
他就可以运行这个了

1157
00:36:58,100 --> 00:36:58,900
好吧

1158
00:36:58,933 --> 00:36:59,733
那这个是什么呢

1159
00:36:59,733 --> 00:37:01,499
这个就是内核站的大小啊

1160
00:37:01,500 --> 00:37:04,133
内核内核站的大小啊我们不说了吗

1161
00:37:04,266 --> 00:37:06,699
就是说啊对于用户胎的

1162
00:37:07,200 --> 00:37:07,933
县城啊

1163
00:37:07,933 --> 00:37:09,666
对于用户他的县城他有什么呢

1164
00:37:09,666 --> 00:37:11,933
他有用户站和内核站

1165
00:37:12,000 --> 00:37:14,100
但是爱豆县城是一什么是

1166
00:37:14,100 --> 00:37:15,366
一个内核县城

1167
00:37:15,766 --> 00:37:16,499
内核线程的话

1168
00:37:16,500 --> 00:37:17,900
它只有一个什么内核站

1169
00:37:17,900 --> 00:37:18,766
那这个就是啊

1170
00:37:18,766 --> 00:37:19,533
你看这个地方

1171
00:37:19,533 --> 00:37:22,166
就是我把这个内核站的大小付给这个

1172
00:37:22,200 --> 00:37:25,066
参数那在这个task create only这个函数里

1173
00:37:25,066 --> 00:37:27,666
就可以用这个值从内存值中去分配

1174
00:37:27,966 --> 00:37:30,199
啊分配一个两k大小的一个内核站

1175
00:37:30,200 --> 00:37:32,066
所以大家看在idol IS中这内核站呢

1176
00:37:32,066 --> 00:37:32,699
还是很小的

1177
00:37:32,700 --> 00:37:33,500
只有两k

1178
00:37:33,866 --> 00:37:36,066
那这个是这个爱豆名字看到了吧

1179
00:37:36,066 --> 00:37:37,799
它的policy呢就是它的这个

1180
00:37:37,800 --> 00:37:38,933
这是它的这个

1181
00:37:38,933 --> 00:37:41,066
那个就是调度的策略

1182
00:37:41,366 --> 00:37:43,766
有round有有有RR就是round

1183
00:37:43,766 --> 00:37:46,499
招聘就是分时实践片调度啊

1184
00:37:46,500 --> 00:37:47,666
实践片轮准调度

1185
00:37:47,766 --> 00:37:49,099
这个呢是一种

1186
00:37:49,300 --> 00:37:50,700
这也是一种idol调度

1187
00:37:50,700 --> 00:37:51,900
还有就是什么调度呢

1188
00:37:51,900 --> 00:37:53,966
还有就是那个FIFO调度

1189
00:37:54,200 --> 00:37:57,266
那这个是Letos支持的这些调度方法

1190
00:37:57,300 --> 00:37:58,533
那我们有一个project

1191
00:37:58,533 --> 00:37:59,933
就是专门让你修改

1192
00:37:59,933 --> 00:38:02,166
或者添加一个新的调度策略

1193
00:38:02,266 --> 00:38:03,699
那你就可以在这个地方啊

1194
00:38:03,700 --> 00:38:05,333
增加一个调度策略啊

1195
00:38:05,333 --> 00:38:06,399
也要添加一个红

1196
00:38:07,000 --> 00:38:07,333
啊

1197
00:38:07,333 --> 00:38:09,066
那么我们知道爱豆策略

1198
00:38:09,066 --> 00:38:09,866
它的优先级怎么样

1199
00:38:09,866 --> 00:38:10,499
是最低的

1200
00:38:10,500 --> 00:38:12,533
所以你看这个爱豆爱豆task

1201
00:38:12,766 --> 00:38:14,799
把它的设设置的优先级是最低的

1202
00:38:14,800 --> 00:38:15,566
看到了吧

1203
00:38:15,566 --> 00:38:17,266
然后呢这个task

1204
00:38:17,300 --> 00:38:17,866
我们知道

1205
00:38:17,866 --> 00:38:20,899
每一个task都隶属于某一个附近城PID

1206
00:38:21,066 --> 00:38:22,366
所以你看这个是什么

1207
00:38:22,566 --> 00:38:25,933
get idle process ID就把0返回来给它

1208
00:38:26,100 --> 00:38:26,766
所以

1209
00:38:26,766 --> 00:38:29,699
呃这个也就是用这个函数创建的任务

1210
00:38:29,766 --> 00:38:33,166
它的附进程就是这个附进程是这个啊

1211
00:38:34,666 --> 00:38:36,766
然后呢嗯然后呢

1212
00:38:36,766 --> 00:38:37,566
通过这个

1213
00:38:37,566 --> 00:38:38,466
你看我把这个

1214
00:38:38,466 --> 00:38:40,866
我把这个参数啊这个设置好之后呢

1215
00:38:40,866 --> 00:38:41,666
我就可以把这个

1216
00:38:41,666 --> 00:38:43,899
参数传进来啊传进来

1217
00:38:43,933 --> 00:38:45,799
然后呢这个touch和create only

1218
00:38:45,800 --> 00:38:47,733
就利用这些参数来创建县城

1219
00:38:47,766 --> 00:38:48,999
那这些参数干嘛用呢

1220
00:38:49,000 --> 00:38:50,900
用来初始化这个县城的啊

1221
00:38:50,900 --> 00:38:52,800
这个县城的TCB啊TCB

1222
00:38:53,600 --> 00:38:54,666
这就是这个

1223
00:38:54,766 --> 00:38:56,666
然后完成这个线程创建以后呢

1224
00:38:56,666 --> 00:38:57,266
我们就哎

1225
00:38:57,266 --> 00:38:58,366
你看完成创建

1226
00:38:58,400 --> 00:39:00,400
这个创一旦完成创建了

1227
00:39:00,400 --> 00:39:03,266
那么这个idol啊一旦完成创建了

1228
00:39:03,266 --> 00:39:05,866
你看这个idol task ID就有有意义了

1229
00:39:06,100 --> 00:39:10,200
然后你看OS TCB from from TCB tid

1230
00:39:10,266 --> 00:39:11,299
就是从这个tid

1231
00:39:11,300 --> 00:39:13,900
怎么样把这个把这个idotask取出来

1232
00:39:14,333 --> 00:39:17,166
把idotask的TCB取出来付给这个idotask

1233
00:39:17,166 --> 00:39:17,966
看到了吧

1234
00:39:18,000 --> 00:39:18,800
然后呢

1235
00:39:18,800 --> 00:39:21,933
你看这个idotask的status设置成什么呢

1236
00:39:21,933 --> 00:39:23,933
设置成系统啊system task

1237
00:39:24,266 --> 00:39:25,733
然后呢你看然后干嘛

1238
00:39:25,866 --> 00:39:26,499
然后干嘛

1239
00:39:26,500 --> 00:39:30,266
这个OS OS guide run q idle init啊

1240
00:39:30,466 --> 00:39:31,466
这是用来干嘛

1241
00:39:31,500 --> 00:39:33,166
用来初始化这个

1242
00:39:33,900 --> 00:39:36,300
这个这个运行队列的这个爱豆线程

1243
00:39:36,300 --> 00:39:38,366
那你看在这呢在这他干嘛呢

1244
00:39:38,366 --> 00:39:40,366
你看他首先是啊

1245
00:39:40,500 --> 00:39:42,766
取得当前CPU的这个runq

1246
00:39:42,766 --> 00:39:43,666
看到了runq

1247
00:39:43,933 --> 00:39:45,333
run q嘛对吧run q

1248
00:39:45,466 --> 00:39:47,499
然后把这个idol task的ID

1249
00:39:47,500 --> 00:39:49,133
付给这个run q的task ID

1250
00:39:49,266 --> 00:39:50,933
那我们知道就像我刚才说的呀

1251
00:39:50,933 --> 00:39:52,866
你看这就是这个每一个CPU啊

1252
00:39:52,866 --> 00:39:55,133
每一个CPU都有一个啥呢

1253
00:39:55,133 --> 00:39:56,066
你看这个是什么呢

1254
00:39:56,066 --> 00:39:56,866
这个就是获得

1255
00:39:56,866 --> 00:39:59,733
你看这不就获取当前CPU的ID

1256
00:39:59,733 --> 00:40:00,566
然后给这个ID

1257
00:40:00,566 --> 00:40:02,266
获得这个CPU所对应的run q

1258
00:40:02,666 --> 00:40:03,599
看到了吗run q

1259
00:40:03,966 --> 00:40:04,766
run

1260
00:40:05,100 --> 00:40:07,966
q这就是整个的这么一个过程

1261
00:40:09,666 --> 00:40:11,466
好那么我们刚才给大家说完

1262
00:40:11,466 --> 00:40:11,999
了什么呢

1263
00:40:12,000 --> 00:40:13,200
说完了这个

1264
00:40:13,933 --> 00:40:15,766
啊idol进程的创建过程

1265
00:40:15,766 --> 00:40:17,266
下面我们再说一下1号进程

1266
00:40:17,266 --> 00:40:19,366
就是这个以net进程的一个创建过程

1267
00:40:19,666 --> 00:40:21,866
那么1号进程为用户态的老祖宗

1268
00:40:21,866 --> 00:40:22,966
创建过程如下

1269
00:40:23,166 --> 00:40:25,766
那么第一它的源头和内核

1270
00:40:26,333 --> 00:40:28,699
内核态老祖宗一样都是OS may

1271
00:40:28,966 --> 00:40:29,766
那么第二呢

1272
00:40:29,766 --> 00:40:32,766
是通过创建一个分离模式啊

1273
00:40:32,933 --> 00:40:36,533
那么优先级为10的系统任务啊

1274
00:40:36,533 --> 00:40:37,899
system elite来完成

1275
00:40:38,066 --> 00:40:40,499
那么任务的入口函数是这个system elite

1276
00:40:40,500 --> 00:40:42,000
啊elite函数

1277
00:40:42,133 --> 00:40:43,199
那么它的实现呢

1278
00:40:43,200 --> 00:40:45,366
由平台集成商来确定啊

1279
00:40:45,466 --> 00:40:48,266
所以这个得看全量代代码才能获得啊

1280
00:40:49,133 --> 00:40:51,699
那我们看一下啊他是怎么做的啊

1281
00:40:51,700 --> 00:40:52,866
首先呢是这样的啊

1282
00:40:52,866 --> 00:40:55,666
你看我们说过了这个OS啊

1283
00:40:55,666 --> 00:40:57,999
这个OS system minit是一个什么呢

1284
00:40:58,000 --> 00:41:01,066
是一个活跃函数啊是一个回调函数

1285
00:41:01,166 --> 00:41:02,133
这个回调函数呢

1286
00:41:02,133 --> 00:41:04,966
你看是通过这个模块注册方式啊

1287
00:41:05,066 --> 00:41:07,799
注册啊注册到那个read only data

1288
00:41:07,800 --> 00:41:09,400
点delete那个数据区的

1289
00:41:09,400 --> 00:41:10,200
看到了吗

1290
00:41:10,200 --> 00:41:12,166
所以它是这样注册数据区的

1291
00:41:12,166 --> 00:41:14,699
那么我们再回忆一下在OS man函数啊

1292
00:41:14,700 --> 00:41:15,533
在这个函数

1293
00:41:18,500 --> 00:41:19,200
看一下啊

1294
00:41:19,200 --> 00:41:20,333
在这个函数的末尾

1295
00:41:20,333 --> 00:41:21,799
你看这是不是OS main的末

1296
00:41:21,800 --> 00:41:23,566
末尾是不是调到了这个函数对吧

1297
00:41:23,566 --> 00:41:26,766
你看你注意这就是loss init level

1298
00:41:27,133 --> 00:41:28,799
kernelmodial task

1299
00:41:29,200 --> 00:41:29,700
啊

1300
00:41:29,700 --> 00:41:31,400
你再看在这地方的注册

1301
00:41:32,133 --> 00:41:32,766
这个注册

1302
00:41:32,766 --> 00:41:33,133
你看

1303
00:41:33,133 --> 00:41:37,133
这个注册函数也是loss init level kernmodile task

1304
00:41:37,200 --> 00:41:38,000
看到了吧

1305
00:41:38,000 --> 00:41:40,000
所以当运行这个函数的时候

1306
00:41:40,000 --> 00:41:41,933
OS man函数的时候它就到这个

1307
00:41:42,166 --> 00:41:42,499
这个函数

1308
00:41:42,500 --> 00:41:45,000
主要是把这个函数注册到那个read only

1309
00:41:45,066 --> 00:41:46,766
data点ED的区域那

1310
00:41:46,766 --> 00:41:48,933
这个函数主要是扫描那个区

1311
00:41:48,933 --> 00:41:50,933
然后执行那里的每个函数

1312
00:41:50,933 --> 00:41:53,066
那当然就会执行到这个函数

1313
00:41:53,066 --> 00:41:54,999
那执行的这个函数它就会运行对吧

1314
00:41:55,000 --> 00:41:57,066
它会就那这个函数很简单就运行了

1315
00:41:57,066 --> 00:41:58,999
这个o s s mini task create

1316
00:41:59,500 --> 00:41:59,933
看到了吧

1317
00:41:59,933 --> 00:42:01,499
unit task great create

1318
00:42:01,700 --> 00:42:02,466
那就是这个函数

1319
00:42:02,466 --> 00:42:04,499
在这个函数里你看它就创建了谁

1320
00:42:04,900 --> 00:42:07,200
你看它就创建了这个system unit

1321
00:42:07,366 --> 00:42:09,999
这个你看他是不是创建了一个

1322
00:42:10,000 --> 00:42:13,300
就像刚才创建idol idol idol idol

1323
00:42:13,900 --> 00:42:15,200
啊科罗idol任务一样

1324
00:42:15,200 --> 00:42:18,566
你看啊他在这里头也是啊也是啊

1325
00:42:18,566 --> 00:42:20,099
申请这么一个什么

1326
00:42:20,133 --> 00:42:22,499
也也申请了这么一个strap的结构体啊

1327
00:42:22,500 --> 00:42:23,366
这个结构体

1328
00:42:23,766 --> 00:42:25,466
然后呢对这个结果进行复制

1329
00:42:25,466 --> 00:42:26,166
看到了吧

1330
00:42:26,166 --> 00:42:28,533
这个函数你看这个入口函数的名字

1331
00:42:28,533 --> 00:42:29,166
看到了吧

1332
00:42:29,166 --> 00:42:30,333
等等等等啊等等等等

1333
00:42:30,966 --> 00:42:32,466
然后呢创建这个任务

1334
00:42:32,600 --> 00:42:33,366
创建这个任务

1335
00:42:33,366 --> 00:42:34,066
看到了吧

1336
00:42:34,066 --> 00:42:36,999
那好我们现在来看一下这个CSM elite啊

1337
00:42:37,000 --> 00:42:38,400
这CSM elite长啥样呢

1338
00:42:38,400 --> 00:42:39,733
这个地方它长这样

1339
00:42:40,133 --> 00:42:40,533
看到了吧

1340
00:42:40,533 --> 00:42:40,999
那当然

1341
00:42:41,000 --> 00:42:43,566
它主要是出初始化一些板级支持包

1342
00:42:43,566 --> 00:42:45,133
比如说啊USB啊

1343
00:42:45,266 --> 00:42:46,966
什么乱七八糟的这些系统啊

1344
00:42:46,966 --> 00:42:48,666
这些东西都是跟硬件相关的

1345
00:42:48,700 --> 00:42:50,333
在最后啊它在在这

1346
00:42:50,333 --> 00:42:53,699
你看e o s 1MID process啊啊

1347
00:42:53,733 --> 00:42:56,333
就是说这在这个函数里就创建了这个

1348
00:42:56,866 --> 00:42:59,066
用户态下的这个10组程序

1349
00:42:59,066 --> 00:43:00,766
就是init init进程

1350
00:43:01,700 --> 00:43:05,100
好我们来看一下这个OS user init process

1351
00:43:05,366 --> 00:43:08,799
那么OS init process啊首先是怎么样呢

1352
00:43:08,800 --> 00:43:11,400
你看首先是调用这个

1353
00:43:11,400 --> 00:43:14,200
因为我们知道这个g user init process得

1354
00:43:14,366 --> 00:43:15,966
得几啊得

1355
00:43:17,400 --> 00:43:18,266
得一对吧

1356
00:43:18,266 --> 00:43:19,066
得一那

1357
00:43:19,066 --> 00:43:19,699
这样的话呢

1358
00:43:19,700 --> 00:43:22,800
我就把这个啊根据这个一取得这个PCB

1359
00:43:22,800 --> 00:43:23,200
看到了吧

1360
00:43:23,200 --> 00:43:25,966
然后通过这个OS process create的函数

1361
00:43:26,100 --> 00:43:27,000
那我们在讲

1362
00:43:27,166 --> 00:43:29,066
k process的创建过程的时候

1363
00:43:29,066 --> 00:43:29,999
已经讲过这个函数了

1364
00:43:30,000 --> 00:43:32,566
那也就是那它用同样的方式啊

1365
00:43:32,566 --> 00:43:34,266
来创建这个啊

1366
00:43:34,266 --> 00:43:35,199
引力的进程

1367
00:43:35,266 --> 00:43:36,133
引力的进程

1368
00:43:36,766 --> 00:43:37,533
看到了吧

1369
00:43:37,533 --> 00:43:40,999
那么然后呢就是OS load user一net啊

1370
00:43:41,000 --> 00:43:41,766
执行这个函数

1371
00:43:41,766 --> 00:43:45,699
最后呢是o s user一net Stack Analog啊

1372
00:43:45,700 --> 00:43:47,733
那么大家想一想这个是什么呢

1373
00:43:47,733 --> 00:43:49,766
我们讲一讲这这几个函数啊

1374
00:43:49,766 --> 00:43:50,566
这几个函数

1375
00:43:50,600 --> 00:43:51,266
那我们知道

1376
00:43:51,266 --> 00:43:52,566
我们现在这个银翼的函数

1377
00:43:52,566 --> 00:43:54,099
是一个用户态的进程

1378
00:43:54,200 --> 00:43:55,966
那我们知道这个用户态进程呢

1379
00:43:55,966 --> 00:43:57,299
它包括两个站

1380
00:43:57,366 --> 00:43:58,299
一个站是什么

1381
00:43:58,300 --> 00:44:00,600
用户站一个站是内核站对吧

1382
00:44:00,600 --> 00:44:02,300
内核站那这个地方呢

1383
00:44:02,300 --> 00:44:03,966
你通过这个名字就可以知道它

1384
00:44:03,966 --> 00:44:04,899
这个是什么呀

1385
00:44:05,466 --> 00:44:08,299
啊对什么用户站进行初始化

1386
00:44:08,300 --> 00:44:09,500
对用户站进行初始化

1387
00:44:09,500 --> 00:44:10,500
那初始化完了之后

1388
00:44:10,500 --> 00:44:12,300
用户用户站的指针啊

1389
00:44:12,300 --> 00:44:14,266
就被保存在这个Stack变量里

1390
00:44:14,333 --> 00:44:15,499
然后你再看这个地方

1391
00:44:15,500 --> 00:44:17,666
你看然后这个parameter又是什么

1392
00:44:17,666 --> 00:44:19,066
你看它现在怎么样呢

1393
00:44:19,066 --> 00:44:21,266
要启动这个init进程

1394
00:44:21,566 --> 00:44:22,966
要启动这个引力的进程

1395
00:44:23,100 --> 00:44:24,300
那要启动引力的进程

1396
00:44:24,300 --> 00:44:25,666
这就是用户态进程

1397
00:44:25,800 --> 00:44:27,400
用户态进程呢包括两个站

1398
00:44:27,400 --> 00:44:28,866
一个是内核站一个是用户站

1399
00:44:28,866 --> 00:44:31,533
你看这个Stack就是user SP pointer

1400
00:44:31,566 --> 00:44:34,133
user Stack pointer看到了吧用户站

1401
00:44:34,800 --> 00:44:36,266
这这样这那这个是什么呢

1402
00:44:36,266 --> 00:44:37,666
这个就是用户态代码

1403
00:44:37,700 --> 00:44:38,566
它的这个

1404
00:44:39,000 --> 00:44:40,100
起始的这个地址

1405
00:44:40,200 --> 00:44:41,566
就类似于内函数一样啊

1406
00:44:41,566 --> 00:44:43,133
内函数那这个表示什么

1407
00:44:43,133 --> 00:44:43,699
这个是表示一

1408
00:44:43,700 --> 00:44:44,566
个链接地址啊

1409
00:44:44,566 --> 00:44:46,899
这是链接器规定了一个链接地址

1410
00:44:49,133 --> 00:44:49,866
然后呢你看

1411
00:44:49,866 --> 00:44:52,933
就调这个函数来启动刚才创建的这个

1412
00:44:53,333 --> 00:44:54,866
啊创建的这个进程

1413
00:44:56,533 --> 00:44:57,766
那这个是

1414
00:44:58,000 --> 00:44:59,300
好我们挨个儿看一下啊

1415
00:44:59,300 --> 00:45:01,933
这个OS load的user以net这个干嘛呢

1416
00:45:01,933 --> 00:45:03,766
这个是因为我们知道啊

1417
00:45:03,766 --> 00:45:06,799
现在我们创建的是一个用户态进程

1418
00:45:07,133 --> 00:45:08,566
那么既然创建用户态进程的话

1419
00:45:08,566 --> 00:45:10,199
这个用户态进程一定在内存

1420
00:45:10,200 --> 00:45:12,766
在硬盘中有这个相应的应用程序

1421
00:45:12,933 --> 00:45:14,699
所以从这个名字上就可以看到

1422
00:45:14,700 --> 00:45:15,500
他就是把

1423
00:45:15,700 --> 00:45:18,700
隐匿他这个程序啊在硬盘上的影像

1424
00:45:18,800 --> 00:45:19,700
硬盘影像

1425
00:45:19,900 --> 00:45:20,266
怎么样

1426
00:45:20,266 --> 00:45:23,133
装入到什么这个进程的地址空间中

1427
00:45:23,766 --> 00:45:24,866
啊装到这个地质空间中

1428
00:45:24,866 --> 00:45:26,999
我们通过在这个地方创建了一个

1429
00:45:27,300 --> 00:45:28,366
创建了一个进程

1430
00:45:28,366 --> 00:45:29,899
并且给他有了一个地质空间

1431
00:45:29,900 --> 00:45:31,466
那好现在我要往这个地质

1432
00:45:31,466 --> 00:45:32,999
地质空间中装入啊

1433
00:45:33,000 --> 00:45:34,666
物理装入这个

1434
00:45:34,866 --> 00:45:36,966
装这个数据啊代码啊什么的

1435
00:45:36,966 --> 00:45:38,999
你看他在这个地方主要就是

1436
00:45:39,466 --> 00:45:41,366
你看啊他在这个地方我看一下啊

1437
00:45:41,600 --> 00:45:43,900
你看他在这个地方有用户的代码段

1438
00:45:43,900 --> 00:45:44,300
看到了吧

1439
00:45:44,300 --> 00:45:46,300
代码段的起始位置看到了吧

1440
00:45:46,566 --> 00:45:48,733
然后呢为这个代码段申申请

1441
00:45:48,733 --> 00:45:50,166
然后还有时候为啊

1442
00:45:50,400 --> 00:45:52,366
叫做BSS段看到了吧

1443
00:45:52,600 --> 00:45:53,400
看到了吧

1444
00:45:53,800 --> 00:45:54,266
等等等等

1445
00:45:54,266 --> 00:45:56,933
你看啊将代码段的代码拷贝到刚刚

1446
00:45:56,933 --> 00:45:58,933
然后怎么样为代码段申请内存

1447
00:45:59,100 --> 00:46:02,333
首先是确定啊代码段的这个地址啊

1448
00:46:02,333 --> 00:46:04,699
代码段的地址然后呢

1449
00:46:06,133 --> 00:46:08,733
然后呢确定代码段的虚拟地址对吧

1450
00:46:08,800 --> 00:46:11,766
然后呢为代码段申请物理地址空间

1451
00:46:11,933 --> 00:46:13,566
然后呢把什么

1452
00:46:14,166 --> 00:46:14,566
把

1453
00:46:14,566 --> 00:46:16,733
把数据啊拷贝到这个

1454
00:46:17,166 --> 00:46:18,799
把数据拷贝到那个

1455
00:46:18,800 --> 00:46:20,933
就是刚刚申请的这个你

1456
00:46:20,933 --> 00:46:21,899
看这是地址吗

1457
00:46:21,900 --> 00:46:22,533
物理地址

1458
00:46:22,533 --> 00:46:24,133
申请到的这个物理地址页面里

1459
00:46:24,133 --> 00:46:24,599
看到了吧

1460
00:46:24,600 --> 00:46:26,566
物理地址页面里好

1461
00:46:26,666 --> 00:46:28,866
然后呢建立什么呢啊

1462
00:46:28,866 --> 00:46:30,933
为代码段建立虚页表下啊

1463
00:46:30,933 --> 00:46:32,499
进行虚实影射啊

1464
00:46:33,066 --> 00:46:33,866
进行虚拟映射

1465
00:46:33,866 --> 00:46:34,499
那这样的话呢

1466
00:46:34,500 --> 00:46:36,000
就可以访问这个代码段了

1467
00:46:36,733 --> 00:46:38,066
啊以后运行的时候你看

1468
00:46:38,066 --> 00:46:39,766
运行的时候就就可以了

1469
00:46:39,800 --> 00:46:40,866
所以这个主要是什么呢

1470
00:46:40,866 --> 00:46:44,533
就是啊未把代码段装入到内存中啊

1471
00:46:44,533 --> 00:46:46,733
装入到虚拟地址空进程的地质虚拟

1472
00:46:47,133 --> 00:46:49,133
地啊进程地质虚拟空间中

1473
00:46:49,133 --> 00:46:51,366
所以在这start的时候有东西可以start

1474
00:46:52,266 --> 00:46:52,966
啊

1475
00:46:52,966 --> 00:46:55,199
然后这个是初始化那个

1476
00:46:55,600 --> 00:46:57,166
初始化用户站啊

1477
00:46:57,166 --> 00:46:59,066
用户站那怎么样初始化呢

1478
00:46:59,066 --> 00:47:01,266
因为用户站也在内存空间中啊

1479
00:47:01,300 --> 00:47:03,066
所以你看他在这分配了一段

1480
00:47:03,366 --> 00:47:04,733
虚拟地址空间

1481
00:47:05,366 --> 00:47:07,399
迅离空间就是VM region啊

1482
00:47:07,400 --> 00:47:11,100
VM region你看在这呢VM map region VR VM map region

1483
00:47:11,466 --> 00:47:12,066
然后呢

1484
00:47:12,066 --> 00:47:14,166
把这个地方因为占空间是匿名的啊

1485
00:47:14,166 --> 00:47:15,299
匿名的所以叫

1486
00:47:15,600 --> 00:47:17,733
怎么样把它设置成匿名影射啊

1487
00:47:17,733 --> 00:47:18,533
匿名影射

1488
00:47:18,566 --> 00:47:20,599
然后设置标记看Stack标记

1489
00:47:24,000 --> 00:47:26,200
然后呢我们看一下啊

1490
00:47:27,133 --> 00:47:28,599
然后就开始运行了对吧

1491
00:47:28,600 --> 00:47:29,166
开始运行了

1492
00:47:29,166 --> 00:47:31,699
你看OSUC need process start看到了吧

1493
00:47:31,966 --> 00:47:32,899
那么怎么运行呢

1494
00:47:32,900 --> 00:47:34,366
因为还是还是那句话

1495
00:47:34,366 --> 00:47:37,533
就是说你进程实际上是不能运行的啊

1496
00:47:37,533 --> 00:47:39,666
运行的是进程下面的一个线程

1497
00:47:39,766 --> 00:47:41,799
所以你看我们在前头啊

1498
00:47:41,800 --> 00:47:42,966
在这初始化了

1499
00:47:42,966 --> 00:47:45,499
在这个地方啊初始化了这个

1500
00:47:46,533 --> 00:47:47,133
啊

1501
00:47:47,133 --> 00:47:48,066
在这个地方

1502
00:47:48,766 --> 00:47:50,199
在这个地方啊初始化了

1503
00:47:50,200 --> 00:47:51,400
你看初始化的这个

1504
00:47:51,400 --> 00:47:53,200
这个线程要运行的函数啊

1505
00:47:53,400 --> 00:47:54,933
看一下啊在哪初始化

1506
00:47:58,466 --> 00:48:00,533
啊在这个地方在这个地方你看在

1507
00:48:00,533 --> 00:48:02,366
这个地方我初始画好了啊

1508
00:48:02,366 --> 00:48:04,733
我我初始画了一些东西看到了吗

1509
00:48:05,700 --> 00:48:07,100
啊然后呢

1510
00:48:07,100 --> 00:48:09,066
我看一下啊我看一下这是怎么做的

1511
00:48:09,266 --> 00:48:10,066
啊

1512
00:48:10,400 --> 00:48:13,766
然后呢你看啊它OS create user task啊

1513
00:48:13,933 --> 00:48:15,399
调这个函数来创建啊

1514
00:48:15,400 --> 00:48:17,500
后面我会详细说这个函数啊

1515
00:48:17,500 --> 00:48:18,066
相信会说

1516
00:48:18,066 --> 00:48:20,466
这个函数来创建一个隐秘的线程

1517
00:48:20,466 --> 00:48:21,299
那线程

1518
00:48:21,466 --> 00:48:23,799
然后呢把这个线程设置好优先级

1519
00:48:23,800 --> 00:48:24,266
看到了吧

1520
00:48:24,266 --> 00:48:26,999
然后呢用用这个调度器啊

1521
00:48:27,000 --> 00:48:29,266
调度器来调度这个线程来运行

1522
00:48:29,500 --> 00:48:30,300
看到了吧

1523
00:48:30,333 --> 00:48:31,133
嗯

1524
00:48:32,400 --> 00:48:33,400
那好我们看一下啊

1525
00:48:33,400 --> 00:48:34,200
在这个地方是

1526
00:48:34,200 --> 00:48:35,966
看一下这个县城是怎么创建起来的

1527
00:48:35,966 --> 00:48:38,133
就是隐匿的县城是怎么创建起来的

1528
00:48:38,400 --> 00:48:39,766
那么在这个地方呢

1529
00:48:39,766 --> 00:48:41,699
我们看一下啊create user

1530
00:48:41,700 --> 00:48:43,600
那我们看这就又是一个什么

1531
00:48:43,600 --> 00:48:45,800
这又是一个县县城创业的参数集

1532
00:48:45,800 --> 00:48:46,600
看到了吧

1533
00:48:47,133 --> 00:48:48,566
参数集首先呢

1534
00:48:48,566 --> 00:48:49,533
对这些参数呢

1535
00:48:49,533 --> 00:48:51,866
入口参数进行一下合理性检测

1536
00:48:51,966 --> 00:48:53,366
那我们注意看一下啊

1537
00:48:53,366 --> 00:48:55,599
这个Parometer里包含什么东西呢

1538
00:48:55,766 --> 00:48:57,999
这Parometer里包含的就是什么

1539
00:48:58,066 --> 00:48:59,799
我们回过头来看一下这个

1540
00:49:00,100 --> 00:49:01,500
Parometer里包含的是什么

1541
00:49:01,500 --> 00:49:03,466
这个Parometer包含的都是一些什么

1542
00:49:03,466 --> 00:49:04,266
比如说

1543
00:49:04,266 --> 00:49:05,066
啊

1544
00:49:05,733 --> 00:49:07,266
呃这个现成的

1545
00:49:07,400 --> 00:49:10,166
现成的这个指针对吧现成的指针

1546
00:49:10,333 --> 00:49:13,966
还有就是啊用户太下这个站的啊

1547
00:49:13,966 --> 00:49:16,666
这个站的站顶指就是这个站的指针

1548
00:49:16,666 --> 00:49:17,799
站指针看到了吧

1549
00:49:18,066 --> 00:49:20,166
站指针还有这个站的大小啊

1550
00:49:20,166 --> 00:49:22,266
主要是一些用户太东西啊

1551
00:49:22,400 --> 00:49:23,933
首先检测一下这个用户太

1552
00:49:23,933 --> 00:49:25,366
这些合合不合理

1553
00:49:25,533 --> 00:49:27,299
那么然后怎么样这个是什么

1554
00:49:27,300 --> 00:49:29,400
这是内核太内核站的大小

1555
00:49:29,400 --> 00:49:31,366
看到了内核站的大小啊

1556
00:49:31,366 --> 00:49:32,899
这是内核任务的优先级

1557
00:49:32,900 --> 00:49:33,700
看到了吗

1558
00:49:34,200 --> 00:49:35,566
内核任务的优先级

1559
00:49:36,400 --> 00:49:36,966
啊

1560
00:49:36,966 --> 00:49:39,366
那么这个是内核这个线程的调

1561
00:49:39,366 --> 00:49:40,199
调度策略

1562
00:49:40,200 --> 00:49:41,200
看到了调度策略

1563
00:49:41,200 --> 00:49:42,766
因为我们现在要创建线程

1564
00:49:43,300 --> 00:49:44,300
要创建线程

1565
00:49:46,200 --> 00:49:48,266
那么这个呢表示呃

1566
00:49:48,266 --> 00:49:51,299
if process ID等于这个就是表示这个线程

1567
00:49:51,600 --> 00:49:53,500
啊当然我们现在不是这样了

1568
00:49:53,500 --> 00:49:55,100
因为process ID已经有了

1569
00:49:55,100 --> 00:49:56,600
因为init嘛是init对吧

1570
00:49:56,600 --> 00:49:57,500
所以我们走的是这个

1571
00:49:57,500 --> 00:49:58,166
else

1572
00:49:58,166 --> 00:50:00,866
说明这个进程已经创建起来了对吧

1573
00:50:00,866 --> 00:50:01,699
已经创建起来了

1574
00:50:01,700 --> 00:50:03,966
所以这时候这个线程有自己的父亲

1575
00:50:04,100 --> 00:50:05,466
所以用这个PID来

1576
00:50:05,933 --> 00:50:07,766
来来表示所以我们走的是这个

1577
00:50:07,933 --> 00:50:09,799
然后把这个现成的这个console ID

1578
00:50:09,800 --> 00:50:10,566
设置成0

1579
00:50:10,566 --> 00:50:12,499
然后再调这个lost task create

1580
00:50:13,166 --> 00:50:13,966
用这个

1581
00:50:14,066 --> 00:50:16,766
设置好的这个来设置好的这个参数来

1582
00:50:16,766 --> 00:50:17,999
来创建这个线程

1583
00:50:18,100 --> 00:50:19,066
那好我们注意啊

1584
00:50:19,066 --> 00:50:21,099
在这点要注意两点要注意

1585
00:50:21,100 --> 00:50:22,133
要注意一点什么呢

1586
00:50:22,133 --> 00:50:23,899
就是说在这个隐匿的parameter里

1587
00:50:23,900 --> 00:50:25,933
已经包含了两个战指针

1588
00:50:26,000 --> 00:50:27,566
一个是用户探下的战指针

1589
00:50:27,566 --> 00:50:28,466
一个是什么

1590
00:50:28,766 --> 00:50:31,133
一个是用户态啊一个是内核态对吧

1591
00:50:31,133 --> 00:50:33,299
那这个参数就是内核态

1592
00:50:33,766 --> 00:50:34,566
内核态

1593
00:50:35,133 --> 00:50:36,299
而这个参数

1594
00:50:37,300 --> 00:50:40,300
user Stack pointer是用户态啊用户态

1595
00:50:40,300 --> 00:50:41,100
所以你看

1596
00:50:41,333 --> 00:50:42,799
有两个指针啊

1597
00:50:42,933 --> 00:50:43,799
有两个指针

1598
00:50:44,200 --> 00:50:45,866
所以在这个地方我们就说啊

1599
00:50:45,933 --> 00:50:49,166
那么当我们创建一个用户县城的时候

1600
00:50:49,166 --> 00:50:50,899
用户啊用户进城的时候

1601
00:50:51,133 --> 00:50:53,299
那么这个用户进城下辖的这个任

1602
00:50:53,300 --> 00:50:54,800
每一个任务都拥有两个指针

1603
00:50:54,800 --> 00:50:56,766
一个是内核态指针一个是

1604
00:50:57,600 --> 00:50:59,566
啊一个是用户产用户站指针

1605
00:50:59,700 --> 00:51:02,000
那在我们后面给大家介绍的内容里

1606
00:51:02,000 --> 00:51:03,766
主要用的是这个内核站指针

1607
00:51:03,766 --> 00:51:04,599
内核站指针

1608
00:51:04,800 --> 00:51:07,200
那么用户站指针基本上我们不会讲

1609
00:51:07,200 --> 00:51:07,733
为什么呢

1610
00:51:07,733 --> 00:51:09,533
啊我们会在虚实映射

1611
00:51:09,600 --> 00:51:11,866
不会在这个缺异常的时候会讲啊

1612
00:51:11,866 --> 00:51:14,599
用户太指针copyright之类的这些东西

1613
00:51:14,700 --> 00:51:16,933
啊这些东西的时候会讲啊

1614
00:51:17,533 --> 00:51:20,499
好以上就是那个就是

1615
00:51:20,800 --> 00:51:21,600
啊

1616
00:51:21,866 --> 00:51:25,066
Letos中进程管理的啊主要内容

