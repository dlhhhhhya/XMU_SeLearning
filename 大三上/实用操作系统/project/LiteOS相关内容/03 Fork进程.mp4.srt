1
00:00:00,933 --> 00:00:02,166
各位同学大家好

2
00:00:02,166 --> 00:00:05,199
我们现在开始介绍进程的创建

3
00:00:05,200 --> 00:00:06,600
也就是fork进程

4
00:00:10,000 --> 00:00:10,800
fork

5
00:00:11,100 --> 00:00:12,000
进程最大

6
00:00:12,100 --> 00:00:15,400
fork最大的特点是一次调用返回两次

7
00:00:15,666 --> 00:00:15,899
那么

8
00:00:15,900 --> 00:00:18,700
这足以颠覆同学们以往对函数的认知

9
00:00:19,166 --> 00:00:21,766
父进程调用一次fork

10
00:00:22,000 --> 00:00:24,900
那么父子进程各返回一次

11
00:00:25,266 --> 00:00:25,699
而且呢

12
00:00:25,700 --> 00:00:28,566
只能通过返回值来判断是哪个进程的

13
00:00:28,566 --> 00:00:30,599
返回错误是什么

14
00:00:31,066 --> 00:00:32,933
外部如何正确使用它

15
00:00:33,500 --> 00:00:35,300
为什么要用fork这种设计

16
00:00:35,300 --> 00:00:37,400
fork的本质和好处是什么

17
00:00:37,666 --> 00:00:39,066
那怎么做到的

18
00:00:39,333 --> 00:00:43,099
调用fork使得父子进城各返回一次

19
00:00:43,366 --> 00:00:45,699
怎么做到返回两次的

20
00:00:45,733 --> 00:00:47,499
其中到底发生了什么

21
00:00:48,366 --> 00:00:51,566
为什么PID等于0代表了子进程的返回

22
00:00:51,766 --> 00:00:54,566
为什么附进程不需要返回0

23
00:00:55,000 --> 00:00:55,933
这些问题呢

24
00:00:55,933 --> 00:00:59,366
大家在后面的听讲中要注意啊

25
00:00:59,366 --> 00:01:00,166
要注意听

26
00:01:02,400 --> 00:01:03,766
首先我们看一个例子

27
00:01:03,933 --> 00:01:04,799
fork是什么

28
00:01:04,800 --> 00:01:06,700
外部如何正确使用它

29
00:01:07,333 --> 00:01:09,999
我们看到在这里呢有一个面函数啊

30
00:01:10,000 --> 00:01:11,733
在面函数中定义了一个PID

31
00:01:11,733 --> 00:01:13,133
一个message啊

32
00:01:13,366 --> 00:01:15,366
然后呢在这定义了一个什么呢

33
00:01:15,366 --> 00:01:16,933
for fork啊

34
00:01:17,400 --> 00:01:18,766
调用fork系统调用

35
00:01:18,900 --> 00:01:21,866
把fork系统调用的返回值呢付给了PID

36
00:01:22,133 --> 00:01:23,399
在这儿有一个if语句

37
00:01:23,400 --> 00:01:25,566
if pid小于0显然是错误

38
00:01:25,800 --> 00:01:27,600
if PID等于0啊

39
00:01:27,600 --> 00:01:29,533
PID等于0表示这是子进程

40
00:01:29,733 --> 00:01:30,933
子进程l

41
00:01:31,133 --> 00:01:34,366
也就是说PID不大是个大于0的数

42
00:01:34,366 --> 00:01:36,599
那么就是这是复进程

43
00:01:36,600 --> 00:01:40,400
复进程然后呢把子进程的n复制成6

44
00:01:40,400 --> 00:01:42,300
把复进程的n复制成3

45
00:01:42,900 --> 00:01:44,566
然后呢用一个four循环

46
00:01:44,566 --> 00:01:47,199
如果大家看如果因为我们在紫禁城

47
00:01:47,200 --> 00:01:48,200
n被设置成6了

48
00:01:48,200 --> 00:01:50,300
所以如果要是紫禁城的话

49
00:01:50,466 --> 00:01:53,366
那么它就会打印6条信息6条message

50
00:01:53,366 --> 00:01:54,533
那这个message是什么呢

51
00:01:54,533 --> 00:01:55,799
this is the child

52
00:01:56,100 --> 00:01:57,900
那么如果它是附近城的话

53
00:01:57,900 --> 00:01:59,000
那它会打印n等于三

54
00:01:59,000 --> 00:02:01,933
三条信息打印的是this is the parent

55
00:02:02,333 --> 00:02:03,999
所以而且是sleep

56
00:02:04,000 --> 00:02:06,400
一表示休每每隔一秒钟打一次

57
00:02:06,500 --> 00:02:09,266
return 0 所以大家看啊我们在这儿看

58
00:02:09,300 --> 00:02:12,333
当fork的小于0的时候表示fork失败啊

59
00:02:12,333 --> 00:02:14,799
当FOG的返回值pid小于0的时候

60
00:02:15,133 --> 00:02:16,666
表示FOG失败

61
00:02:16,666 --> 00:02:19,299
当PID等于0的时候表示FOG成功

62
00:02:19,333 --> 00:02:22,299
那么当前是当前所处的是子进程

63
00:02:22,666 --> 00:02:25,266
当pid大于0的时候表示FOG成功

64
00:02:25,266 --> 00:02:28,133
当前所处的这个进程也是复进程

65
00:02:28,466 --> 00:02:30,333
fork的返回值啊

66
00:02:30,333 --> 00:02:32,599
是这样规定是有道理的

67
00:02:32,600 --> 00:02:34,533
fork在紫禁城中返回0

68
00:02:34,533 --> 00:02:37,766
紫禁城仍可以调用盖的PID函数

69
00:02:37,766 --> 00:02:39,533
得到自己的进程ID

70
00:02:40,133 --> 00:02:41,266
也可以调用get

71
00:02:41,466 --> 00:02:44,099
PP ID函数得到附进程的ID

72
00:02:44,366 --> 00:02:46,699
在附进程中用getpid

73
00:02:46,933 --> 00:02:49,166
可以得到自己的进程ID

74
00:02:49,200 --> 00:02:51,733
然而要想得到子进程的ID

75
00:02:52,333 --> 00:02:55,466
只有将fork的返回值记录下来啊

76
00:02:55,466 --> 00:02:57,333
没有别无他法

77
00:02:58,366 --> 00:03:01,299
紫禁城并没有真正执行fork

78
00:03:01,466 --> 00:03:04,766
而是内核用了一个巧妙的方法

79
00:03:05,333 --> 00:03:06,366
获得了反馈值

80
00:03:06,366 --> 00:03:08,333
那么后面我们会知道

81
00:03:08,333 --> 00:03:09,533
这个巧妙的方法是什么呢

82
00:03:09,533 --> 00:03:12,399
就是啊就是设置内核站啊

83
00:03:12,400 --> 00:03:13,200
设置内核站

84
00:03:13,600 --> 00:03:16,900
并且将返回时硬生生的改写成了r啊

85
00:03:16,900 --> 00:03:17,800
改写成了0

86
00:03:17,800 --> 00:03:19,200
那这个什么叫硬生生改写0

87
00:03:19,200 --> 00:03:20,866
就是我我设置这个

88
00:03:20,966 --> 00:03:21,966
我设置内核战

89
00:03:21,966 --> 00:03:22,699
然后内核战

90
00:03:22,700 --> 00:03:23,100
我们知道

91
00:03:23,100 --> 00:03:25,533
那个内核战实际上是task contacts的结

92
00:03:25,533 --> 00:03:26,333
构体

93
00:03:26,566 --> 00:03:29,066
那么函数的返回值就是这个R0寄存器

94
00:03:29,100 --> 00:03:32,100
所以我只要修改内核站的内核呃

95
00:03:32,100 --> 00:03:35,000
内核站也就是task contacts结构体的R0

96
00:03:35,266 --> 00:03:37,799
属性把那个属性改成0就可以了

97
00:03:38,266 --> 00:03:39,099
那么这样呢

98
00:03:39,100 --> 00:03:40,000
这个是什么呢

99
00:03:40,000 --> 00:03:42,366
这个我就认为我们认为这是Falk

100
00:03:42,566 --> 00:03:44,299
Falk实现的最精彩的部分

101
00:03:44,533 --> 00:03:45,299
那么我们看一下

102
00:03:45,300 --> 00:03:46,566
这个程序的运行结果呢

103
00:03:46,566 --> 00:03:47,999
也正如我们所期望的这样

104
00:03:48,000 --> 00:03:49,766
你看Parrot被打印了3次

105
00:03:49,800 --> 00:03:53,966
child被打印了123456被打印了6次

106
00:03:55,900 --> 00:03:57,166
那么这是一个

107
00:03:57,200 --> 00:03:59,133
这个整个程序的一个运行图啊

108
00:03:59,133 --> 00:04:00,966
整个程序运行图我们看一下

109
00:04:01,266 --> 00:04:01,999
那么在这呢

110
00:04:02,000 --> 00:04:04,333
附近程运行运行运行到这的时候

111
00:04:04,800 --> 00:04:07,566
那么啊再往下父子进程就分开了啊

112
00:04:07,566 --> 00:04:08,533
父子进程就分开了

113
00:04:08,533 --> 00:04:10,366
你可以认为在fork的时候呢

114
00:04:10,366 --> 00:04:11,799
就产生了一个新的进程

115
00:04:12,166 --> 00:04:13,899
那么新的进程根据返回值啊

116
00:04:13,900 --> 00:04:15,066
他俩都会判断

117
00:04:15,100 --> 00:04:16,533
PID如果小于0就不对

118
00:04:16,566 --> 00:04:18,366
那这是子进程PID等于0

119
00:04:18,366 --> 00:04:20,333
返回PID等于0他就执行这个啊

120
00:04:20,333 --> 00:04:22,999
执行这个然后不执行LS执行for循环

121
00:04:23,066 --> 00:04:24,299
而复进程呢

122
00:04:24,366 --> 00:04:26,899
首先PID不等于呃

123
00:04:26,933 --> 00:04:28,199
PID是一个大于0数啊

124
00:04:28,200 --> 00:04:29,466
所以这两个判断都不对

125
00:04:29,466 --> 00:04:31,566
所以执行l然后再执行for循环

126
00:04:32,766 --> 00:04:34,566
那么Fork呢是一个系统调用

127
00:04:34,566 --> 00:04:37,266
因此会切换到SVC模式运行

128
00:04:37,400 --> 00:04:39,600
在SVC战中啊

129
00:04:39,600 --> 00:04:40,800
也就是内核战

130
00:04:40,900 --> 00:04:42,566
附近城复制出一个紫禁城

131
00:04:42,566 --> 00:04:43,799
这个非常重要啊

132
00:04:43,866 --> 00:04:46,299
后面我们会看Fork系统调用的实现

133
00:04:46,300 --> 00:04:47,600
那主要就是看一下

134
00:04:47,600 --> 00:04:48,866
主要研究一下啊

135
00:04:48,866 --> 00:04:51,499
紫禁城是怎么复制出附近城的

136
00:04:51,933 --> 00:04:53,966
紫禁城和附近城和紫禁

137
00:04:53,966 --> 00:04:55,499
城的PCB信息相同

138
00:04:55,766 --> 00:04:58,299
用户态代码和数据也相同啊

139
00:04:58,300 --> 00:04:59,400
这个也很重要啊

140
00:04:59,466 --> 00:05:01,099
为什么他们执行的代码都相同呢

141
00:05:01,100 --> 00:05:01,866
因为他们的用户

142
00:05:01,866 --> 00:05:03,399
态的代码和数据也相同

143
00:05:03,400 --> 00:05:06,000
为什么就是因为附近城啊

144
00:05:06,000 --> 00:05:07,933
复制了一份给子进程把

145
00:05:07,933 --> 00:05:09,899
把复进程的所有数据都复制了一份

146
00:05:09,900 --> 00:05:10,700
给子进程

147
00:05:10,866 --> 00:05:12,899
那么从案例的执行上可以看出

148
00:05:12,900 --> 00:05:16,133
form之后的代码复子进程都会执行

149
00:05:16,333 --> 00:05:19,299
即代码段指向啊

150
00:05:19,300 --> 00:05:20,700
PC寄存器是一样的

151
00:05:20,700 --> 00:05:22,900
大家看因为这个还是我们上次说的啊

152
00:05:22,900 --> 00:05:24,000
还是我们刚才说的

153
00:05:24,100 --> 00:05:26,566
这个PC寄存器实际上保存在内核站中

154
00:05:26,566 --> 00:05:27,266
内核站

155
00:05:27,266 --> 00:05:29,266
那么因为紫禁城复制了一份内核站

156
00:05:29,266 --> 00:05:30,733
所以他们在返回的时候

157
00:05:30,733 --> 00:05:31,733
整个这个

158
00:05:31,766 --> 00:05:33,933
后面的代码段执行是一样的啊

159
00:05:34,166 --> 00:05:35,366
实际上fork

160
00:05:35,966 --> 00:05:37,799
只被附近城调入了一次

161
00:05:37,800 --> 00:05:39,533
紫禁城并没有执行fork

162
00:05:39,666 --> 00:05:42,266
但是却获得了一个返回值PID等于0

163
00:05:42,266 --> 00:05:43,533
这个很重要啊

164
00:05:43,666 --> 00:05:45,699
那么也是我们后面讲述的重点

165
00:05:46,066 --> 00:05:47,299
从执行结果上看

166
00:05:47,300 --> 00:05:50,066
附近城打印了3次this is the parent

167
00:05:50,100 --> 00:05:51,000
因为n等于3

168
00:05:51,000 --> 00:05:53,566
紫禁城打印了6次this is the child

169
00:05:53,600 --> 00:05:54,666
因为n等于6

170
00:05:54,933 --> 00:05:59,066
紫禁城是从PID等于fork后开始执行的

171
00:05:59,066 --> 00:06:00,733
大家看这个地方是灰色的

172
00:06:00,733 --> 00:06:02,533
表示紫禁城并没有执行这段代码

173
00:06:02,533 --> 00:06:03,899
而是从这个地方开始

174
00:06:04,166 --> 00:06:05,599
开始执行这个代码的

175
00:06:06,700 --> 00:06:09,566
按理他不会在新任务战中

176
00:06:09,666 --> 00:06:10,899
出现这些变量

177
00:06:10,900 --> 00:06:11,800
而实际上

178
00:06:11,900 --> 00:06:14,200
后面又顺利的使用了这些变量

179
00:06:14,200 --> 00:06:16,200
说明附近城当前任务

180
00:06:16,300 --> 00:06:17,300
的用户态数据

181
00:06:17,300 --> 00:06:19,166
也复制了一份给紫禁城的

182
00:06:19,166 --> 00:06:19,999
新的任务站

183
00:06:20,800 --> 00:06:22,100
啊新的任务站

184
00:06:22,100 --> 00:06:23,700
那么这个说法不准确啊

185
00:06:23,700 --> 00:06:24,566
这个说法不准确

186
00:06:24,566 --> 00:06:27,266
它并不是复制啊它是共用而在

187
00:06:27,733 --> 00:06:29,599
而在如果要是进行写操作的时候

188
00:06:29,600 --> 00:06:32,133
也就是在这比如说把3复给n把6复给

189
00:06:32,600 --> 00:06:33,800
紫禁城把6负给n

190
00:06:33,800 --> 00:06:35,566
附近城把3负给n的时候

191
00:06:35,566 --> 00:06:37,666
那么这这时候发生了copyright

192
00:06:37,700 --> 00:06:40,100
那么我们我们在线下课程中将

193
00:06:40,133 --> 00:06:41,533
详细的来介绍这一点

194
00:06:44,533 --> 00:06:46,799
那么被放成功的紫禁城

195
00:06:47,366 --> 00:06:50,999
跑的首条代码指令是PID等于0啊

196
00:06:51,000 --> 00:06:51,866
PID等于0

197
00:06:52,000 --> 00:06:55,166
那这里0是返回值存放在20计算器中

198
00:06:55,166 --> 00:06:57,266
说明附近城的任务上下文

199
00:06:57,300 --> 00:06:58,866
也进行了一次拷贝

200
00:06:59,333 --> 00:07:01,999
附近程从内核态回到用户态时

201
00:07:02,000 --> 00:07:04,366
恢复的上下文和此进程任务

202
00:07:04,366 --> 00:07:05,599
上下文是一样的

203
00:07:05,600 --> 00:07:08,300
即PC寄存器指向是一样的

204
00:07:08,766 --> 00:07:09,299
如此

205
00:07:09,300 --> 00:07:12,266
才能够确保在代码段相同的位置执行

206
00:07:12,600 --> 00:07:15,600
那么执行这个a点out文件后

207
00:07:15,866 --> 00:07:17,866
那么第一条打印的是this is the child

208
00:07:17,866 --> 00:07:20,399
说明fork中发生了一次调度

209
00:07:20,600 --> 00:07:23,733
CPU切换到了紫禁城的任务执行

210
00:07:23,733 --> 00:07:24,933
sleep一的本质

211
00:07:25,000 --> 00:07:27,366
是任务主动放弃CPU的使用权

212
00:07:27,366 --> 00:07:28,366
将自己挂入

213
00:07:28,933 --> 00:07:30,533
任务等待列表中

214
00:07:30,866 --> 00:07:33,699
由此呢再一次发生了任务调度啊

215
00:07:33,700 --> 00:07:35,766
CPU切换到复进程执行

216
00:07:35,766 --> 00:07:38,966
那么才有了第二条打印this is the parent

217
00:07:39,133 --> 00:07:41,199
复进程的sleep呢又切换到紫进程

218
00:07:41,200 --> 00:07:42,866
如此往复一直到n等于0

219
00:07:43,100 --> 00:07:44,600
那么结束复子进程

220
00:07:45,266 --> 00:07:46,866
但这个例子呢

221
00:07:46,866 --> 00:07:49,566
只是FOLK是什么的使用说明书啊

222
00:07:49,566 --> 00:07:52,066
并猜测其中做了什么做了些什么

223
00:07:52,066 --> 00:07:53,933
并没有说明为什么要这样做

224
00:07:53,933 --> 00:07:55,466
和代码是怎样实现的

225
00:07:55,666 --> 00:07:56,799
那么我们下面呢

226
00:07:56,800 --> 00:07:59,700
就结合代码的鸿蒙的代码来说明清

227
00:07:59,700 --> 00:08:02,133
楚为什么和怎么做这两个问题

228
00:08:03,166 --> 00:08:05,099
首先我们来看一下为什么是fork啊

229
00:08:05,100 --> 00:08:06,133
为什么要进行fork

230
00:08:06,266 --> 00:08:07,933
那么fork函数的特点

231
00:08:08,100 --> 00:08:10,300
概括起来就是调用一次返回两次

232
00:08:10,500 --> 00:08:12,566
在复进程中调用一次

233
00:08:12,566 --> 00:08:15,199
在复进程和子进程中各返回一次

234
00:08:15,566 --> 00:08:17,299
那么从上面我们那个

235
00:08:17,933 --> 00:08:19,333
执行流程可以看出

236
00:08:19,366 --> 00:08:21,466
一开始是一个控制流

237
00:08:21,866 --> 00:08:24,899
控制流程调用fork之后就分叉了

238
00:08:25,000 --> 00:08:26,533
变成两个控制流程

239
00:08:26,666 --> 00:08:28,566
也就是说fork也就是分叉

240
00:08:28,566 --> 00:08:30,099
这就是这个fork分叉的由来

241
00:08:30,100 --> 00:08:32,733
你看一开始只有这一个一个流程

242
00:08:32,800 --> 00:08:34,600
但是当完调用完fork之后呢

243
00:08:34,600 --> 00:08:37,333
你看就分分解成两个调两个流程了

244
00:08:38,466 --> 00:08:41,166
一个程序运行起来就需要各种资源

245
00:08:41,166 --> 00:08:42,866
比如说内存文件啊

246
00:08:43,133 --> 00:08:45,799
啊进程间通信机制监控信息等等

247
00:08:46,100 --> 00:08:48,566
资源就需要管理

248
00:08:48,566 --> 00:08:51,133
进程就是资源管理的容器啊

249
00:08:51,133 --> 00:08:52,299
管理资源的容器

250
00:08:52,500 --> 00:08:55,266
这些资源相当于干活需要的各种工具

251
00:08:55,666 --> 00:08:57,566
那么干活的工具都差不多啊

252
00:08:57,566 --> 00:09:00,299
实在是没有必要走流程一一申请

253
00:09:00,533 --> 00:09:03,566
而且申请下来会后呢会发现啊

254
00:09:04,566 --> 00:09:06,266
别我们手里的工具和别人

255
00:09:06,266 --> 00:09:07,666
手里的工具都是一样的

256
00:09:07,766 --> 00:09:09,299
那么别人如果这样的话呢

257
00:09:09,300 --> 00:09:12,133
别人有我们就直接拿过来用就可以了

258
00:09:12,133 --> 00:09:13,766
所以呢最方便的办法呢

259
00:09:13,766 --> 00:09:15,699
就是让附近城直接

260
00:09:15,900 --> 00:09:17,666
拷贝一份资源给紫禁城

261
00:09:18,066 --> 00:09:20,366
这样只需要专心做好啊

262
00:09:20,366 --> 00:09:23,166
紫禁城只要干专心干好活就可以了啊

263
00:09:23,600 --> 00:09:26,400
fork因此fork的本质就是copy

264
00:09:26,400 --> 00:09:28,366
那么下面我们看一下具体的代码

265
00:09:30,100 --> 00:09:31,200
那么大家看啊

266
00:09:31,200 --> 00:09:32,133
当我们调用fork

267
00:09:32,133 --> 00:09:34,266
在应用程序中调用fork调用的

268
00:09:34,266 --> 00:09:35,899
当调用fork库函数的时候

269
00:09:35,900 --> 00:09:36,933
我们已经学过了啊

270
00:09:36,933 --> 00:09:38,133
这个系统调用是怎么回事

271
00:09:38,133 --> 00:09:39,866
你头脑中就马上想到啊

272
00:09:39,866 --> 00:09:41,199
这些系统调用的流程

273
00:09:41,533 --> 00:09:41,899
那么

274
00:09:41,900 --> 00:09:44,500
与fork这个库函数对应的系统调用

275
00:09:44,500 --> 00:09:47,000
内核的调用就是sys fork

276
00:09:47,066 --> 00:09:49,666
那sys fork调用就是克隆函数啊

277
00:09:49,666 --> 00:09:50,499
克隆函数

278
00:09:50,866 --> 00:09:52,599
那么这个地方首先克隆函数呢

279
00:09:52,600 --> 00:09:54,566
设置一些标记啊设置一些标记

280
00:09:54,666 --> 00:09:56,166
那比如说我们后面会讲这个

281
00:09:56,166 --> 00:09:59,333
比如克隆parent啊在克隆spread啊

282
00:09:59,333 --> 00:10:00,766
克隆VM懂了吧

283
00:10:00,966 --> 00:10:01,866
那么这个什么意思

284
00:10:01,866 --> 00:10:04,499
就是说你可以啊你可以自己通过设置

285
00:10:04,900 --> 00:10:06,533
但是在这里你看我们看鸿蒙

286
00:10:06,533 --> 00:10:07,199
它并没有设置

287
00:10:07,200 --> 00:10:09,966
它直接是所有现场啊所有紫禁城都是

288
00:10:10,466 --> 00:10:12,966
跟附近城克隆的都是一样的东西啊

289
00:10:13,133 --> 00:10:14,199
那这是克隆标记

290
00:10:14,200 --> 00:10:17,000
表示的是紫禁城到底克隆啊

291
00:10:17,000 --> 00:10:19,133
克隆克隆附进程是哪些东西

292
00:10:19,133 --> 00:10:20,799
就是复制复进程哪些东西

293
00:10:20,933 --> 00:10:21,799
那我们看一下啊

294
00:10:21,800 --> 00:10:23,766
我们看一下你在这可以修改一下啊

295
00:10:23,900 --> 00:10:26,666
然后通过调用OS copy process啊

296
00:10:26,666 --> 00:10:27,966
来创建紫禁城

297
00:10:28,266 --> 00:10:29,066
创建自己城

298
00:10:29,200 --> 00:10:31,566
那么由此可见啊这些东西都属于资源

299
00:10:31,566 --> 00:10:34,933
比如说你看这个啊这个这个这个VM啊

300
00:10:34,933 --> 00:10:37,066
VM啊就是虚拟内存对吧

301
00:10:37,066 --> 00:10:40,266
文件系统啊不是这是虚拟内存对吧

302
00:10:40,333 --> 00:10:42,999
对吧那么这个是任务啊

303
00:10:43,000 --> 00:10:44,366
这个是啊

304
00:10:44,400 --> 00:10:46,000
是carry的是谁啊

305
00:10:47,400 --> 00:10:48,933
好那我们来看一下这个

306
00:10:48,933 --> 00:10:51,166
具体看一下这个copy process copy process

307
00:10:51,166 --> 00:10:53,899
大家看那我现在呢要创建紫禁城了

308
00:10:53,900 --> 00:10:54,866
首先我要干嘛呢

309
00:10:54,866 --> 00:10:56,666
我首先要怎么样呢

310
00:10:56,766 --> 00:10:59,866
要啊获取当前进程的PCB

311
00:10:59,966 --> 00:11:00,499
然后呢

312
00:11:00,500 --> 00:11:02,333
因为我要现在创建一个新的进程

313
00:11:02,333 --> 00:11:03,599
所以我从这个

314
00:11:03,900 --> 00:11:04,700
啊

315
00:11:04,933 --> 00:11:07,733
这个这我们说我们我们在刚

316
00:11:07,733 --> 00:11:09,533
才讲了啊进程有一个什么呢

317
00:11:09,533 --> 00:11:11,599
所有PCB保存在一个数组里对吧

318
00:11:11,600 --> 00:11:13,700
那我们从这个数组里获得一个什么呢

319
00:11:13,700 --> 00:11:16,066
空闲的PCB放在这个chaos里

320
00:11:16,666 --> 00:11:17,466
啊或者是child

321
00:11:17,666 --> 00:11:19,666
然后每一个PCB都有一个缩影

322
00:11:19,666 --> 00:11:22,666
这个缩影ID就是这个进程ID啊进程ID

323
00:11:22,766 --> 00:11:25,399
然后呢调用OS fork以逆的PCB

324
00:11:25,400 --> 00:11:27,766
对紫禁城进行初始化啊

325
00:11:27,766 --> 00:11:28,799
对紫禁城进行处罚

326
00:11:28,800 --> 00:11:30,166
这个是非常重要的函数

327
00:11:30,166 --> 00:11:31,533
这就回答了我们前面啊

328
00:11:31,533 --> 00:11:32,999
那个PC是怎么设置的

329
00:11:33,000 --> 00:11:35,366
就是实际上就是把附近城的内核站

330
00:11:35,400 --> 00:11:37,666
复制给了紫禁城的内核站啊

331
00:11:37,766 --> 00:11:38,966
那这样的话呢

332
00:11:39,900 --> 00:11:41,266
这样的话呢就是说啊

333
00:11:41,266 --> 00:11:42,866
还有就是虚拟地址空间呢等等

334
00:11:42,866 --> 00:11:43,499
这个是实际上

335
00:11:43,500 --> 00:11:45,066
这个是最重要的一个函数啊

336
00:11:45,266 --> 00:11:47,733
那么呃就是这样的话呢

337
00:11:47,733 --> 00:11:49,933
就设置的这个PID等于0啊

338
00:11:49,933 --> 00:11:51,666
PID等于0那个那个东西

339
00:11:51,866 --> 00:11:53,166
然后呢把这个各种资源

340
00:11:53,166 --> 00:11:54,799
包括什么讯地址空间啊

341
00:11:54,800 --> 00:11:58,166
文件啊锁用户啊这个我忘了啊

342
00:11:58,166 --> 00:11:59,866
这个具体什么都有待会再看

343
00:12:00,100 --> 00:12:01,200
然后呢把这些资源

344
00:12:01,200 --> 00:12:03,100
附近城的资源复制给紫禁城

345
00:12:03,466 --> 00:12:04,366
然后这个呢是什么呢

346
00:12:04,366 --> 00:12:06,466
这个东西就是说我现在你看

347
00:12:06,466 --> 00:12:07,899
紫禁城的PCB弄好了

348
00:12:07,900 --> 00:12:09,566
资源也弄好了也复制好了

349
00:12:09,566 --> 00:12:10,566
那现在干嘛呢

350
00:12:10,600 --> 00:12:13,600
把紫禁城加入到相应的group里啊

351
00:12:13,700 --> 00:12:14,566
进程组里

352
00:12:14,666 --> 00:12:16,533
然后呢把这个紫禁城

353
00:12:16,966 --> 00:12:18,166
他的使那个

354
00:12:18,166 --> 00:12:20,666
主主线程加入到这个任务的右

355
00:12:20,666 --> 00:12:23,133
就是调度队列里啊调度队列里

356
00:12:23,133 --> 00:12:24,533
然后加入到调度队列里

357
00:12:24,533 --> 00:12:25,866
之后就可以通过调度

358
00:12:25,866 --> 00:12:28,933
然后让这个就是这个进程开始运行了

359
00:12:28,966 --> 00:12:30,733
那更准确的说应该是让这个紫禁

360
00:12:30,733 --> 00:12:32,799
程的主线程啊开始运行了

361
00:12:34,333 --> 00:12:36,966
好我们现在来看一下这个OS fork

362
00:12:36,966 --> 00:12:38,566
以need PCB这个函数

363
00:12:39,000 --> 00:12:40,533
那么这个函数是干嘛呢

364
00:12:40,533 --> 00:12:42,066
这个函数呢是

365
00:12:42,100 --> 00:12:45,000
首先看初始化了这个紫禁城啊

366
00:12:45,566 --> 00:12:46,799
啊用用这些啊

367
00:12:46,800 --> 00:12:49,500
附近城给他传递过来的就是这个

368
00:12:49,500 --> 00:12:50,100
进程模式

369
00:12:50,100 --> 00:12:51,600
比如说附近城是用户态

370
00:12:51,600 --> 00:12:53,100
那他紫禁城就是用户态

371
00:12:53,100 --> 00:12:55,466
附近城是内核态紫禁城就是内核态

372
00:12:55,466 --> 00:12:57,733
还有就是这个紫禁城的名字

373
00:12:58,000 --> 00:13:00,900
那么来初始化这个紫禁城的PCB

374
00:13:01,266 --> 00:13:02,966
然后呢再copy

375
00:13:03,266 --> 00:13:07,066
调用OS copy parent OS copy task这两个函数啊

376
00:13:07,066 --> 00:13:10,333
来复制一些啊复进程的一些基本信息

377
00:13:11,000 --> 00:13:13,100
首先我们看一下这个OS copy parent

378
00:13:13,100 --> 00:13:14,533
它的意思啊

379
00:13:14,666 --> 00:13:15,466
它的意思

380
00:13:15,466 --> 00:13:18,199
那首先我们看这里这个传入参数

381
00:13:18,200 --> 00:13:21,066
red process CB就是附近程的PCB

382
00:13:21,900 --> 00:13:24,566
Chao的process CB就是紫禁城的PC

383
00:13:24,566 --> 00:13:26,866
还PCB还有一些标记

384
00:13:27,000 --> 00:13:27,933
那首先大家看

385
00:13:27,933 --> 00:13:30,533
第一步是把附近城的PCB呢

386
00:13:30,933 --> 00:13:33,199
啊把附近城的PCB付给谁呢

387
00:13:33,366 --> 00:13:35,699
这里的局部变量叫做Paran process CB

388
00:13:35,700 --> 00:13:37,700
这个这个这个很容易理解

389
00:13:37,900 --> 00:13:39,133
那为什么要这么设置呢

390
00:13:39,133 --> 00:13:41,966
大家看那么现在啊紫禁城的

391
00:13:41,966 --> 00:13:43,699
你看紫禁城有一个

392
00:13:43,700 --> 00:13:45,166
紫禁城PCB里有一个

393
00:13:45,566 --> 00:13:48,266
呃属性叫做parent process ID

394
00:13:48,400 --> 00:13:49,266
那么大家看

395
00:13:49,266 --> 00:13:51,799
那我就把parent process CB的parent

396
00:13:51,800 --> 00:13:54,733
process ID付给这个parent process ID

397
00:13:54,733 --> 00:13:55,299
看到了吗

398
00:13:55,300 --> 00:13:57,666
这个是附近成的ID

399
00:13:57,666 --> 00:13:59,199
那我付给紫禁城的

400
00:13:59,200 --> 00:14:01,100
parent process ID这个资本

401
00:14:01,333 --> 00:14:02,866
然后呢把紫禁城

402
00:14:02,866 --> 00:14:05,466
你看这是紫禁城的sliping list

403
00:14:05,600 --> 00:14:09,466
把紫禁城通过sliping list添加到这个

404
00:14:09,700 --> 00:14:13,066
附近城的children list里这个列表里啊

405
00:14:13,566 --> 00:14:15,399
那么然后呢

406
00:14:15,466 --> 00:14:19,533
然后呢获得啊获得附近城的group附

407
00:14:19,533 --> 00:14:22,699
获得附近城的就是附近城所处的这个

408
00:14:23,100 --> 00:14:25,400
进城组那那么紫禁城也

409
00:14:25,400 --> 00:14:27,666
也也跟附近城在同一个进城组中

410
00:14:27,666 --> 00:14:28,199
看到了吧

411
00:14:28,200 --> 00:14:29,566
紫禁城也在跟附近城

412
00:14:29,566 --> 00:14:30,766
指向同一个进城组

413
00:14:31,066 --> 00:14:33,333
然后呢把子进程通过

414
00:14:34,133 --> 00:14:37,566
subordinate grouplice的这个指针添加到啊

415
00:14:37,566 --> 00:14:39,899
附进程所在的那个进程组列表中

416
00:14:40,266 --> 00:14:41,199
进城组列表中

417
00:14:41,366 --> 00:14:43,466
附近城所在的进城组列表中

418
00:14:43,733 --> 00:14:44,699
然后呢把

419
00:14:45,466 --> 00:14:46,966
附近城的用户信息

420
00:14:46,966 --> 00:14:48,899
拷贝到紫禁城的用户信息

421
00:14:48,933 --> 00:14:50,866
比如说到底是谁创建的啊等等

422
00:14:50,866 --> 00:14:53,066
用户名是谁啊什么的这些东西啊

423
00:14:53,733 --> 00:14:55,699
好我们再来看一下第下一个函数

424
00:14:55,700 --> 00:14:57,466
叫做OS copytask

425
00:14:57,566 --> 00:14:59,066
那么这个就是我们刚才说的

426
00:14:59,066 --> 00:15:00,133
非常关键的地方啊

427
00:15:00,133 --> 00:15:01,166
非常关键的地方

428
00:15:01,333 --> 00:15:02,399
它呢你看

429
00:15:02,733 --> 00:15:03,766
首先判断

430
00:15:04,300 --> 00:15:05,766
紫禁城是不是用户模式

431
00:15:05,766 --> 00:15:07,299
如果是用户模式的话呢

432
00:15:07,300 --> 00:15:09,400
它就把附近城的这个

433
00:15:10,066 --> 00:15:11,166
他就把这个附近程

434
00:15:11,166 --> 00:15:13,299
在用户探下的一些一些内容

435
00:15:13,300 --> 00:15:14,333
复制过来了啊

436
00:15:14,333 --> 00:15:14,966
复制过来了

437
00:15:14,966 --> 00:15:18,066
复制到这个这个task parameter里了

438
00:15:18,066 --> 00:15:20,166
那为什么要复制到task parameter里呢

439
00:15:20,166 --> 00:15:22,699
因为在这个地方会调用task parameter only

440
00:15:22,933 --> 00:15:24,299
那么把这个task parameter

441
00:15:24,300 --> 00:15:25,400
这task parameter

442
00:15:25,466 --> 00:15:27,933
记录的都是附近城的一些基本信息

443
00:15:28,200 --> 00:15:29,266
那么把这个记录

444
00:15:29,266 --> 00:15:30,699
附近城的记录本信息呢

445
00:15:30,700 --> 00:15:31,300
传递过来

446
00:15:31,300 --> 00:15:34,800
那么在创建紫紫禁城的主线城的时候

447
00:15:34,800 --> 00:15:36,666
就利用附近城的这些基本信息

448
00:15:36,666 --> 00:15:38,399
来创建紫禁城的主线城

449
00:15:39,733 --> 00:15:40,999
啊那比如说包括什么呢

450
00:15:41,000 --> 00:15:42,600
就是说附近城啊

451
00:15:43,100 --> 00:15:46,600
附近城主线城的这个入口函数啊

452
00:15:46,600 --> 00:15:49,733
附近城附近城主

453
00:15:49,733 --> 00:15:51,933
线城的内核站的大小啊

454
00:15:51,933 --> 00:15:54,933
还有就是附近城在用户空间中的啊

455
00:15:54,933 --> 00:15:56,299
在用户空间中的一些

456
00:15:56,300 --> 00:15:57,266
比如说站的

457
00:15:57,733 --> 00:15:59,899
站的位置站顶的位置啊

458
00:15:59,900 --> 00:16:02,500
再比如说嗯用户态的占底

459
00:16:02,866 --> 00:16:06,299
还有就是用户站的大小啊等等等等啊

460
00:16:06,666 --> 00:16:07,499
那这个是什么呢

461
00:16:07,500 --> 00:16:11,966
这个是内核内核态的这个入口地址

462
00:16:12,133 --> 00:16:13,866
还有就是内核站的大小啊

463
00:16:13,866 --> 00:16:14,899
内核站的大小

464
00:16:14,900 --> 00:16:15,866
那这个是什么呢

465
00:16:15,866 --> 00:16:16,366
这个就是说

466
00:16:16,366 --> 00:16:18,933
如果当前我创建的用户站的话啊

467
00:16:18,933 --> 00:16:21,533
用户态进程的时候要把用户

468
00:16:21,666 --> 00:16:23,533
用户态的一些信息拷贝过来

469
00:16:23,533 --> 00:16:25,466
如果是内核内核

470
00:16:25,900 --> 00:16:26,933
内核进程的话

471
00:16:26,933 --> 00:16:29,166
内核进程的话或者内核进程的话

472
00:16:29,166 --> 00:16:30,899
那我只需要拷贝这两个就可以了

473
00:16:30,900 --> 00:16:32,466
因为内核进程他没有

474
00:16:32,666 --> 00:16:34,366
没有用户站啊没有用户站

475
00:16:35,166 --> 00:16:36,766
啊然后呢

476
00:16:37,166 --> 00:16:40,733
嗯然后呢就然后呢再怎么样呢

477
00:16:40,733 --> 00:16:42,733
在这是这是内核站的一些信息了

478
00:16:42,733 --> 00:16:44,866
你看这是内核站的一些信息啊

479
00:16:44,866 --> 00:16:46,699
这是用用户态的一些信息

480
00:16:46,700 --> 00:16:48,166
这是内核站的一些信息

481
00:16:48,366 --> 00:16:49,699
那内核站的信息是什么呢

482
00:16:49,700 --> 00:16:50,866
比如说这个

483
00:16:51,266 --> 00:16:53,733
啊这个这个调度的这个策略对吧

484
00:16:53,733 --> 00:16:58,133
然后那个附近城主线城的优先级啊

485
00:16:58,300 --> 00:16:59,066
这个是什么呢

486
00:16:59,066 --> 00:17:01,399
就是嗯紫禁城的

487
00:17:02,100 --> 00:17:04,000
PCB的ID啊付给这个ID

488
00:17:04,166 --> 00:17:05,966
然后这样的话我用这些信息

489
00:17:05,966 --> 00:17:06,466
为什么呢

490
00:17:06,466 --> 00:17:09,766
因为我现在要创建的是内核呃紫禁城

491
00:17:10,066 --> 00:17:12,366
紫禁城主线城紫禁城的主线城

492
00:17:12,533 --> 00:17:13,399
紫禁城主线城

493
00:17:13,400 --> 00:17:15,200
需要一个指针来指向这个

494
00:17:15,200 --> 00:17:17,700
这个紫禁城所属的这个禁城

495
00:17:17,900 --> 00:17:18,900
所以说他要把

496
00:17:19,066 --> 00:17:21,399
紫禁城的p i d也传递过来啊

497
00:17:21,400 --> 00:17:22,933
那么这个函数我们在讲

498
00:17:22,966 --> 00:17:24,066
任务的时候会讲

499
00:17:24,066 --> 00:17:25,899
那么根据这些内容你看啊

500
00:17:25,966 --> 00:17:26,866
它传递了一些

501
00:17:26,866 --> 00:17:27,333
什么信息呢

502
00:17:27,333 --> 00:17:28,999
它传递了一些用户态的信息

503
00:17:29,000 --> 00:17:30,600
传递了一些内核态的信息

504
00:17:30,733 --> 00:17:32,699
那么这个子县城通过这些信息

505
00:17:32,700 --> 00:17:34,166
就可以创建出来一个任务

506
00:17:34,166 --> 00:17:35,099
一个新的任务

507
00:17:35,266 --> 00:17:36,966
那创建完了任务干嘛呢

508
00:17:37,400 --> 00:17:38,900
那创建完了任务之后呢

509
00:17:38,900 --> 00:17:39,966
就开始怎么样呢

510
00:17:39,966 --> 00:17:42,066
你看那我就怎么样根据任务

511
00:17:42,166 --> 00:17:43,266
任务的task ID

512
00:17:43,266 --> 00:17:44,799
把这个任务的控制块起来

513
00:17:44,800 --> 00:17:46,300
就TCP取来了

514
00:17:46,366 --> 00:17:50,966
然后呢然后呢把这个TCB啊把当前

515
00:17:51,266 --> 00:17:54,133
当前就是把附近城啊

516
00:17:54,133 --> 00:17:56,533
附近城主线城的这个任务状态

517
00:17:56,533 --> 00:17:58,899
复制到这个新生成的这个p TCB

518
00:17:59,166 --> 00:18:00,866
就比如说刚才我们说那个

519
00:18:00,866 --> 00:18:02,299
我们刚才给大家举那个例子

520
00:18:02,300 --> 00:18:04,266
例当前的任务

521
00:18:04,333 --> 00:18:07,733
当前当前进程的主线程是running状态

522
00:18:07,766 --> 00:18:10,199
所以他也会把这个task Strak

523
00:18:11,100 --> 00:18:13,900
task status设置成这个啊

524
00:18:13,900 --> 00:18:15,266
设置成这个状态啊

525
00:18:15,266 --> 00:18:16,099
同步状态

526
00:18:16,766 --> 00:18:20,166
然后呢进行啊然后进行修改啊

527
00:18:20,166 --> 00:18:21,733
然后进行参数更新

528
00:18:21,733 --> 00:18:23,399
看到了这是参数更新啊

529
00:18:23,400 --> 00:18:25,266
用这个parameter来对这个子线

530
00:18:25,566 --> 00:18:28,899
子线程子进程主线程进行更更新

531
00:18:28,966 --> 00:18:30,099
但是你在这注意

532
00:18:30,166 --> 00:18:30,933
同一时刻

533
00:18:30,933 --> 00:18:32,699
系统中如果要是一个CPU的话

534
00:18:32,700 --> 00:18:34,166
不能同时存在两个状

535
00:18:34,166 --> 00:18:35,666
run running状态的线程

536
00:18:35,733 --> 00:18:36,699
所以你看他在这

537
00:18:36,700 --> 00:18:39,066
如果子线程的状态是running的话

538
00:18:39,066 --> 00:18:40,199
我会把这个子线程

539
00:18:40,300 --> 00:18:42,000
他的running改成什么

540
00:18:42,400 --> 00:18:44,366
给给他去掉看到了吗给他去掉

541
00:18:45,200 --> 00:18:48,566
去掉然后呢判断啊判断啊

542
00:18:48,566 --> 00:18:51,499
就是当前这个紫禁城是否为用户进城

543
00:18:51,500 --> 00:18:53,533
如果是用户进城的话我就要怎么样

544
00:18:53,533 --> 00:18:54,966
我就要克隆这个

545
00:18:55,466 --> 00:18:56,599
啊我要我要怎么样呢

546
00:18:56,600 --> 00:19:00,066
我要克隆这个这个这个战啊克隆战

547
00:19:00,133 --> 00:19:01,533
那么我们看一下这个o

548
00:19:01,533 --> 00:19:03,066
s user克隆Paran Stack

549
00:19:03,066 --> 00:19:03,933
这个就是我们说的

550
00:19:03,933 --> 00:19:05,133
最核心的这个部分

551
00:19:05,366 --> 00:19:07,966
OS user克隆Paran Stack干嘛呢

552
00:19:08,000 --> 00:19:12,333
就是取得当前啊取得附近城的主线城

553
00:19:12,733 --> 00:19:14,766
啊取得附近城的主线城

554
00:19:15,066 --> 00:19:18,299
然后呢你看在这你看他把这个这个

555
00:19:18,666 --> 00:19:20,299
啊我们看一下啊这个

556
00:19:20,966 --> 00:19:22,866
嗯我们看一下啊

557
00:19:24,466 --> 00:19:25,866
啊然后怎么样呢

558
00:19:25,866 --> 00:19:27,199
这个克隆stack是什么呢

559
00:19:27,200 --> 00:19:30,700
这个克隆stack就是附近城的啊站顶

560
00:19:30,933 --> 00:19:32,499
附近城内核站的站顶

561
00:19:32,600 --> 00:19:33,966
那这个是这个

562
00:19:33,966 --> 00:19:36,066
你看他task contact的看到了吧

563
00:19:36,066 --> 00:19:36,566
TA

564
00:19:36,566 --> 00:19:39,466
tas和contact啊占底说错了是占底占底

565
00:19:39,933 --> 00:19:42,066
然后呢然后怎么样呢

566
00:19:42,066 --> 00:19:45,166
然后这是TA复制一个task contacts的

567
00:19:45,166 --> 00:19:47,466
我们知道这个task contacts保存着R0

568
00:19:47,466 --> 00:19:48,533
还保存着PC

569
00:19:48,533 --> 00:19:50,499
看到了它把这个玩意儿复制到哪儿了

570
00:19:50,533 --> 00:19:53,366
复制到child Stack的task contacts这么多

571
00:19:53,800 --> 00:19:54,900
然后最后怎么样呢

572
00:19:54,900 --> 00:19:56,266
如果你要是不修改的话

573
00:19:56,266 --> 00:19:58,166
那这个220是任何一个数对吧

574
00:19:58,166 --> 00:19:59,666
任何一个数是个随机数

575
00:19:59,733 --> 00:20:00,866
那么如果你要是修改

576
00:20:00,866 --> 00:20:02,966
你看他把这个子线城内核

577
00:20:03,200 --> 00:20:06,700
就是他把子进城主线城内核站的

578
00:20:06,966 --> 00:20:08,066
220寄存器

579
00:20:08,566 --> 00:20:10,099
改成了2改成了0

580
00:20:10,133 --> 00:20:11,766
所以这时候返回的时候怎么样

581
00:20:11,766 --> 00:20:13,766
返回的时候按照按照什么呢

582
00:20:13,766 --> 00:20:15,533
子线程的这个

583
00:20:16,100 --> 00:20:19,466
按照子线呈内核站的这个PC返回

584
00:20:19,566 --> 00:20:21,866
那我们知道这时候因为大家想一想啊

585
00:20:21,866 --> 00:20:23,266
因为因为这时候

586
00:20:23,666 --> 00:20:24,533
紫禁城啊

587
00:20:24,533 --> 00:20:27,066
紫禁城复制的是主禁城的这个PC值

588
00:20:27,066 --> 00:20:28,299
所以它俩都指向这

589
00:20:28,566 --> 00:20:29,533
看都指向这

590
00:20:29,600 --> 00:20:31,300
但是我们修改了R0

591
00:20:31,366 --> 00:20:33,566
R0是它什么FOLK的防卫值就是这个PID

592
00:20:33,566 --> 00:20:34,466
PID不一样

593
00:20:34,533 --> 00:20:35,533
紫禁城的PID是0

594
00:20:35,533 --> 00:20:37,799
而主近程的PID是个大于0的数啊

595
00:20:37,800 --> 00:20:39,300
大于0的数啊

596
00:20:39,300 --> 00:20:40,400
所以说呢

597
00:20:40,733 --> 00:20:42,466
这个就是这个

598
00:20:42,600 --> 00:20:43,766
它的区别啊

599
00:20:43,900 --> 00:20:44,733
它的区别

600
00:20:45,100 --> 00:20:46,600
那这样的返回大家看啊

601
00:20:46,600 --> 00:20:48,066
在系统电话中说过

602
00:20:48,066 --> 00:20:51,133
返回值就是存放在220寄存器中

603
00:20:51,533 --> 00:20:53,899
那么返回值呢指认R0数据啊

604
00:20:53,900 --> 00:20:55,600
读到什么值呢就是

605
00:20:55,866 --> 00:20:57,133
就是什么返回值

606
00:20:57,333 --> 00:21:00,566
而R0寄存器的值呢等于0啊

607
00:21:00,566 --> 00:21:02,566
等同于获得返回值0

608
00:21:02,900 --> 00:21:05,566
那么而RLR寄存器啊

609
00:21:06,566 --> 00:21:08,866
所指向的指令是什么呢

610
00:21:08,866 --> 00:21:10,899
这个这个是链接链接计算器啊

611
00:21:10,900 --> 00:21:11,733
链接计算器

612
00:21:11,733 --> 00:21:12,266
链接计算器

613
00:21:12,266 --> 00:21:14,366
实际上返回值啊就是返回值计算器

614
00:21:14,466 --> 00:21:15,533
它指的是什么呢

615
00:21:15,533 --> 00:21:16,499
指的是这个

616
00:21:17,266 --> 00:21:18,966
就是PID等于Fork啊

617
00:21:18,966 --> 00:21:19,766
那么SP

618
00:21:20,333 --> 00:21:24,466
寄存器记录了战中的开始计算的位置

619
00:21:24,466 --> 00:21:26,899
那么如此完全还原了

620
00:21:26,900 --> 00:21:29,100
因此呢就完全还原了Fork调

621
00:21:29,900 --> 00:21:31,366
fuck附近啊

622
00:21:31,366 --> 00:21:33,366
fuck附近程调fuck前的运行场景

623
00:21:33,366 --> 00:21:34,166
唯一的区别呢

624
00:21:34,166 --> 00:21:36,099
就是改变了20纪存希的值

625
00:21:36,300 --> 00:21:37,800
所以才有了这个啊

626
00:21:37,800 --> 00:21:40,400
FPID等于0表示啊这是紫禁城

627
00:21:40,666 --> 00:21:42,966
如果不等于0的话就是附禁城

628
00:21:43,133 --> 00:21:46,899
由此呢确保了这是紫禁城的返回啊

629
00:21:47,566 --> 00:21:50,133
这是fuck呢最精彩精彩的一部分啊

630
00:21:50,133 --> 00:21:51,866
一定要好好的理解啊

631
00:21:52,066 --> 00:21:54,666
附近城返回的是啊

632
00:21:54,700 --> 00:21:56,166
附近城返回的是什么呢

633
00:21:56,166 --> 00:21:59,199
就是刚刚创建的紫禁城的PI

634
00:21:59,466 --> 00:22:01,766
刚刚创建的紫禁城的id啊

635
00:22:01,766 --> 00:22:03,499
那么而任何紫禁城的ID呢

636
00:22:03,500 --> 00:22:04,600
都不可能等于0啊

637
00:22:04,600 --> 00:22:05,700
成功了只能大于0

638
00:22:05,700 --> 00:22:07,933
所以呢失败了就是负数啊

639
00:22:07,933 --> 00:22:10,866
负数所以附近城啊啊对对对

640
00:22:10,866 --> 00:22:11,866
这个呢你看

641
00:22:12,000 --> 00:22:12,933
在这个地方啊

642
00:22:12,933 --> 00:22:16,699
这个这个这个R0呢是是是等于0被

643
00:22:16,700 --> 00:22:17,700
直接修改了

644
00:22:17,700 --> 00:22:19,766
但是在附近城执行到最后的时候

645
00:22:19,766 --> 00:22:20,999
Falk系统返回的时候

646
00:22:21,000 --> 00:22:23,200
他会把这个R0设置成什么呢

647
00:22:23,200 --> 00:22:25,533
设置成刚刚Falk出来的紫禁城的ID值

648
00:22:25,533 --> 00:22:27,266
啊紫禁城的ID值

649
00:22:28,400 --> 00:22:30,333
我们看一下有没有啊

650
00:22:32,066 --> 00:22:33,266
我看一下啊

651
00:22:37,333 --> 00:22:39,666
那么这个大家可以自己去找一下啊

652
00:22:39,666 --> 00:22:40,466
找一下

653
00:22:41,666 --> 00:22:42,133
好

654
00:22:42,133 --> 00:22:44,766
那么完成了这个紫禁城的创建之后呢

655
00:22:44,766 --> 00:22:45,933
这也是最精彩的部分

656
00:22:45,933 --> 00:22:46,799
那剩下的干嘛呢

657
00:22:46,800 --> 00:22:48,166
我们再回顾一下啊

658
00:22:48,366 --> 00:22:48,966
再回顾一下

659
00:22:48,966 --> 00:22:52,166
你看这个是创建了紫禁城的主线城

660
00:22:53,100 --> 00:22:55,366
啊然后呢并且把它插入到啊

661
00:22:55,566 --> 00:22:56,599
紫禁城的主线城

662
00:22:56,600 --> 00:22:58,000
这时候还没有把这个主线城

663
00:22:58,000 --> 00:22:59,700
插入到这个就绪队列里

664
00:22:59,933 --> 00:23:00,666
那现在干嘛呢

665
00:23:00,666 --> 00:23:02,499
现在就要拷贝各种资源对吧

666
00:23:02,500 --> 00:23:04,266
然后呢就把这个紫线城

667
00:23:04,300 --> 00:23:05,900
就是在这创建出来的主

668
00:23:05,900 --> 00:23:06,900
紫禁城的主线城

669
00:23:06,900 --> 00:23:08,400
插入到就绪队列里

670
00:23:08,400 --> 00:23:09,666
然后进调度啊

671
00:23:09,666 --> 00:23:10,666
这就这四步

672
00:23:11,066 --> 00:23:12,299
好那现代是干嘛呢

673
00:23:12,300 --> 00:23:14,000
现代就是要拷贝各种资源

674
00:23:14,000 --> 00:23:15,800
那你看主要资源有三类

675
00:23:15,966 --> 00:23:16,699
第一类是什么

676
00:23:16,700 --> 00:23:18,900
第一类是内存资源第二类是文件资源

677
00:23:18,900 --> 00:23:20,466
第三类是锁资源

678
00:23:20,466 --> 00:23:20,933
看到了吗

679
00:23:20,933 --> 00:23:22,266
锁资源还有一些安全

680
00:23:22,666 --> 00:23:25,099
那么这个呢是拷贝什么呢

681
00:23:25,166 --> 00:23:26,499
啊内存资源

682
00:23:26,500 --> 00:23:29,466
那拷贝内存资源主要是通过调用loss VM

683
00:23:29,466 --> 00:23:30,299
space克隆

684
00:23:30,500 --> 00:23:31,866
那么这个呢是一个

685
00:23:32,066 --> 00:23:32,299
这个

686
00:23:32,300 --> 00:23:34,600
就是整个这个进程的虚拟地址空间

687
00:23:34,700 --> 00:23:37,700
那么这主要是一棵二叉树啊二叉树啊

688
00:23:38,133 --> 00:23:40,466
那么这就是vs space克隆啊

689
00:23:40,466 --> 00:23:41,099
space克隆

690
00:23:41,100 --> 00:23:44,266
它首先呢是把这个一些比如说啊

691
00:23:44,366 --> 00:23:46,566
比如说在这儿啊影射区啊

692
00:23:46,666 --> 00:23:49,399
堆区啊战区啊等等这些东西拷贝

693
00:23:49,766 --> 00:23:52,299
把这些东西拷贝到这个这个这个VM

694
00:23:52,300 --> 00:23:53,200
space数组里

695
00:23:53,200 --> 00:23:55,166
那最主要的这个地方是一个什么呢

696
00:23:55,166 --> 00:23:56,566
scan是一个便利啊

697
00:23:56,566 --> 00:23:58,366
便利这个你看r b tree嘛

698
00:23:58,700 --> 00:24:00,900
r b red blue red blue tree tree

699
00:24:01,400 --> 00:24:03,600
那么这个我们在这个讲缺异常的时候

700
00:24:03,600 --> 00:24:04,933
会重点去讲

701
00:24:04,966 --> 00:24:06,766
那么整个这个就是边辩例

702
00:24:06,766 --> 00:24:08,099
一边辩例一边复制

703
00:24:08,100 --> 00:24:08,600
复进程

704
00:24:08,600 --> 00:24:10,900
把自己的整个虚拟地址空间的这个

705
00:24:11,333 --> 00:24:14,333
啊整个虚拟地址空间的RB数怎么样

706
00:24:14,333 --> 00:24:15,866
复制给紫禁城一份啊

707
00:24:15,866 --> 00:24:18,133
复制给了紫禁城一份那么

708
00:24:19,466 --> 00:24:20,866
复制给了紫禁城一份

709
00:24:21,700 --> 00:24:22,600
啊然后呢

710
00:24:22,600 --> 00:24:25,100
把自己的页表也复制给了紫禁城一份

711
00:24:25,100 --> 00:24:26,000
啊紫禁城一份

712
00:24:26,000 --> 00:24:28,166
但是这还涉及到一个copyright机制啊

713
00:24:28,166 --> 00:24:28,966
copyright机制

714
00:24:28,966 --> 00:24:30,666
那我们在线下课的时候也会

715
00:24:30,666 --> 00:24:32,866
我们在线下课的时候给大家画图解释

716
00:24:33,933 --> 00:24:35,566
然后呢就是copy file

717
00:24:35,566 --> 00:24:36,499
copy file是干嘛呢

718
00:24:36,500 --> 00:24:39,266
它调用最核心的函数就是这个copy file

719
00:24:39,300 --> 00:24:40,700
调用了谁呢

720
00:24:41,266 --> 00:24:43,733
啊调用了duplicate FD啊

721
00:24:43,733 --> 00:24:45,166
这就是duplicate FD

722
00:24:45,266 --> 00:24:47,266
那我们在前面讲了这个file啊

723
00:24:47,266 --> 00:24:48,866
在讲PCB的时候讲过了这个file

724
00:24:48,866 --> 00:24:50,799
file食指上是一个什么

725
00:24:50,800 --> 00:24:52,600
食指上是一个指认数组

726
00:24:52,666 --> 00:24:54,866
指向一个system FD的一个

727
00:24:55,100 --> 00:24:56,700
就是system FD的一个数组

728
00:24:56,700 --> 00:24:57,766
那么在这个地方呢

729
00:24:57,766 --> 00:25:00,199
就是把这个数组啊进行复制啊

730
00:25:00,200 --> 00:25:03,666
复制这个数组看到了吧也是ilock FD table

731
00:25:03,700 --> 00:25:06,166
就这个FD table就是这数组对吧

732
00:25:06,333 --> 00:25:07,066
然后复制

733
00:25:07,066 --> 00:25:08,266
然后进行复制一份

734
00:25:09,366 --> 00:25:10,733
那么最后的部分是什么呢

735
00:25:10,733 --> 00:25:12,099
最后的部分就是把

736
00:25:12,100 --> 00:25:13,166
新创建的进程

737
00:25:13,166 --> 00:25:15,199
加入到相应的这个进程组中

738
00:25:15,466 --> 00:25:16,599
并且把

739
00:25:16,600 --> 00:25:19,533
这个紫进程的主线程加入到就绪队列

740
00:25:19,533 --> 00:25:22,999
中啊那这个函数就是set processgroup ID

741
00:25:23,166 --> 00:25:23,699
这个函数

742
00:25:23,700 --> 00:25:24,866
就是把这个紫进程

743
00:25:24,866 --> 00:25:27,266
添加到相应的这个进程组中

744
00:25:27,466 --> 00:25:29,399
然后呢撤销掉啊

745
00:25:29,400 --> 00:25:31,566
把这个禁这个紫禁城的1NIT

746
00:25:31,733 --> 00:25:33,399
1NIT进程态给撤销掉

747
00:25:33,533 --> 00:25:34,766
然后呢你看这个是什么呢

748
00:25:34,766 --> 00:25:36,199
就是把这个紫禁城

749
00:25:36,366 --> 00:25:38,933
紫禁城的主线城添加到就绪队列中啊

750
00:25:38,933 --> 00:25:40,533
这就完成了就绪队列添加

751
00:25:41,000 --> 00:25:43,566
那么完成对就区队列添加之后呢

752
00:25:43,566 --> 00:25:44,933
在这个地方你看这个地方

753
00:25:44,933 --> 00:25:45,666
添加完就区队列

754
00:25:45,666 --> 00:25:47,366
然后紧接着进行调度

755
00:25:47,366 --> 00:25:48,166
进行进程调度

756
00:25:48,166 --> 00:25:50,466
那这样的话这个紫禁城就运行起来了

757
00:25:50,900 --> 00:25:52,700
那么我们在这再看一下什么呢

758
00:25:52,700 --> 00:25:53,500
这个地方

759
00:25:53,733 --> 00:25:54,266
把

760
00:25:54,266 --> 00:25:55,899
紫禁城新创建的紫禁城

761
00:25:55,900 --> 00:25:57,666
加入到这个禁城组中啊

762
00:25:57,666 --> 00:25:58,766
和着禁城组中

763
00:25:58,933 --> 00:26:00,099
那么这是什么呢

764
00:26:00,100 --> 00:26:01,966
这个就是紫禁城的PID

765
00:26:01,966 --> 00:26:04,366
这个就是就是说我要加入的那个

766
00:26:04,500 --> 00:26:06,766
我要把这个紫禁城加入到那个组

767
00:26:07,066 --> 00:26:08,933
进程组的ID啊组的ID

768
00:26:09,133 --> 00:26:11,399
首先呢判断进程紫禁城

769
00:26:11,400 --> 00:26:14,500
你看这process就是这个紫禁城的PCB

770
00:26:14,900 --> 00:26:17,066
他判断紫禁城的格入派ID

771
00:26:17,066 --> 00:26:18,666
和我添加那个组一不一样

772
00:26:18,666 --> 00:26:20,399
如果一样的话我就返回成功

773
00:26:20,533 --> 00:26:21,966
好那如果不一样怎么办

774
00:26:21,966 --> 00:26:24,766
就说明紫禁城现在所属的格入派ID

775
00:26:24,766 --> 00:26:26,266
和这个新加的这个

776
00:26:26,333 --> 00:26:27,933
他要添加那个目的格入派ID

777
00:26:27,933 --> 00:26:28,533
是不一样的

778
00:26:28,533 --> 00:26:29,366
那怎么办呢

779
00:26:29,400 --> 00:26:30,400
首先我要把紫

780
00:26:30,400 --> 00:26:32,733
我要获得这个紫禁城所在的进程组

781
00:26:32,933 --> 00:26:34,099
然后呢把这个紫进程

782
00:26:34,100 --> 00:26:35,933
从这个旧的进程组中删除掉

783
00:26:36,066 --> 00:26:38,699
然后呢用这个新的进程组在这个

784
00:26:38,900 --> 00:26:40,966
在这个全局group ID里啊

785
00:26:40,966 --> 00:26:42,333
就是这个这个这个

786
00:26:42,400 --> 00:26:45,766
这个看process group这个组里这个所有的

787
00:26:45,766 --> 00:26:46,999
进程组都保存在这个

788
00:26:47,100 --> 00:26:48,333
这个双相列表里啊

789
00:26:48,333 --> 00:26:49,166
双相列表里

790
00:26:49,400 --> 00:26:50,266
那么我就找

791
00:26:50,266 --> 00:26:52,766
看看能不能这个新group有没有

792
00:26:53,000 --> 00:26:54,133
如果找到了啊

793
00:26:54,133 --> 00:26:56,166
你看如果找到了newgroup就不为空

794
00:26:56,166 --> 00:26:57,199
这个newgroup是啥呢

795
00:26:57,200 --> 00:26:59,533
就是这个就是这个结构体不为空

796
00:26:59,600 --> 00:27:00,300
那怎么办呢

797
00:27:00,300 --> 00:27:03,066
我就把这个新的process

798
00:27:03,066 --> 00:27:04,866
这个紫禁城添加到这个里

799
00:27:04,866 --> 00:27:06,933
这个这个这个找到的这个进程组里

800
00:27:06,933 --> 00:27:07,733
看到了吧

801
00:27:07,866 --> 00:27:09,399
然后呢再把这个新的进程组

802
00:27:09,400 --> 00:27:10,200
让这个

803
00:27:10,300 --> 00:27:12,800
紫禁城的group指向这个新的进程组啊

804
00:27:12,800 --> 00:27:13,933
就是这个这个结构

805
00:27:14,400 --> 00:27:15,533
结构体那好

806
00:27:15,533 --> 00:27:16,766
如果没找到怎么办呢

807
00:27:16,766 --> 00:27:19,466
没找到怎么样就用这个group ID啊

808
00:27:19,466 --> 00:27:20,666
创建一个这个结构体

809
00:27:20,666 --> 00:27:22,066
创建一个新的这个group

810
00:27:22,066 --> 00:27:23,366
process group结构体

811
00:27:23,533 --> 00:27:24,599
把它插到这个

812
00:27:25,000 --> 00:27:26,733
插到这个全局列表里

813
00:27:26,733 --> 00:27:28,666
然后把这个新的进程啊

814
00:27:28,666 --> 00:27:29,733
把这个新的进程

815
00:27:29,733 --> 00:27:31,866
就这个PID插入到这个globe里

816
00:27:31,866 --> 00:27:33,166
那都在这里就实现

817
00:27:33,800 --> 00:27:35,800
那么至此呢我们就完成了啊

818
00:27:35,800 --> 00:27:37,533
fork系统调用的介绍

