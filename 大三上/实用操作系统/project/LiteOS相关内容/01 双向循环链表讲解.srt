1
00:00:01,200 --> 00:00:02,866
各位同学大家好

2
00:00:03,400 --> 00:00:04,866
今天我们

3
00:00:04,933 --> 00:00:08,499
为大家介绍鸿蒙Leto s重要的数据结构

4
00:00:10,733 --> 00:00:13,066
那么这一讲主要分三个内容

5
00:00:13,333 --> 00:00:15,466
第一双向循环列表

6
00:00:16,133 --> 00:00:18,866
第二优先基丢列priority q

7
00:00:19,266 --> 00:00:22,333
第三排序列表salt increased

8
00:00:24,200 --> 00:00:25,866
首先我们为大家介绍

9
00:00:26,100 --> 00:00:27,533
第一种重要的数据结构

10
00:00:27,533 --> 00:00:30,499
也是最基础的数据结构双向循环链表

11
00:00:34,500 --> 00:00:36,166
那么双向循环链表

12
00:00:36,333 --> 00:00:39,133
那么它的名字叫做lost DL list

13
00:00:39,300 --> 00:00:43,100
那么DL就是DUAL list的DUAL link

14
00:00:43,100 --> 00:00:45,733
DUAL link的缩写啊因为是双向循环啊

15
00:00:45,733 --> 00:00:46,866
双向循环链表

16
00:00:47,100 --> 00:00:47,933
那么它的

17
00:00:49,366 --> 00:00:51,399
它的原码所在的这个文件路径是

18
00:00:51,400 --> 00:00:55,000
kernel include lost杠list点h这个文件

19
00:00:56,100 --> 00:00:58,466
我们看LOFT DL list

20
00:00:58,466 --> 00:01:00,666
这个数据结构是一个抽象的数据结构

21
00:01:00,800 --> 00:01:02,133
那么它只包含

22
00:01:02,300 --> 00:01:03,700
因为是双向循环列表

23
00:01:03,700 --> 00:01:05,200
因此它包含了两个指针

24
00:01:05,333 --> 00:01:07,766
一个是previous指针一个是next指针

25
00:01:07,933 --> 00:01:08,699
那么这两个指针

26
00:01:08,700 --> 00:01:09,933
分别指向这个节点的

27
00:01:09,933 --> 00:01:11,733
直接前驱和直接后继

28
00:01:12,566 --> 00:01:14,733
那么大家为什么说这是一个

29
00:01:14,900 --> 00:01:16,700
为什么说这是一个抽象的数据结构呢

30
00:01:16,700 --> 00:01:18,700
因为你看这个循环列表中

31
00:01:19,000 --> 00:01:20,133
这个节点啊

32
00:01:20,133 --> 00:01:20,866
这个结构体中

33
00:01:20,866 --> 00:01:22,499
并没有包含真正的数据域

34
00:01:22,500 --> 00:01:24,133
对不对没有包含数据域

35
00:01:24,133 --> 00:01:25,599
那为什么没有包含数据域呢

36
00:01:25,600 --> 00:01:27,500
主要是为了

37
00:01:27,766 --> 00:01:28,566
啊

38
00:01:28,666 --> 00:01:29,533
在这个

39
00:01:30,700 --> 00:01:31,566
为了实现什么

40
00:01:31,566 --> 00:01:32,066
为了实现

41
00:01:32,066 --> 00:01:33,799
如果我们要把数据加到这个

42
00:01:33,866 --> 00:01:34,799
循环链表上的话

43
00:01:34,800 --> 00:01:36,533
它就变成某一个具体的循环

44
00:01:36,533 --> 00:01:37,533
双向循环链表

45
00:01:37,666 --> 00:01:39,266
那么我们要把这个

46
00:01:39,733 --> 00:01:42,166
操作啊在在这个循环链表的操作

47
00:01:42,166 --> 00:01:42,899
比如说插入过

48
00:01:42,900 --> 00:01:44,666
删除这些操作都抽象出来

49
00:01:44,666 --> 00:01:46,999
所以我们必须要定义一个抽象的这个

50
00:01:47,400 --> 00:01:48,200
电表节点

51
00:01:48,200 --> 00:01:50,700
那么这样的话我们可以啊

52
00:01:50,700 --> 00:01:51,933
把这个抽象的电表节点

53
00:01:51,933 --> 00:01:53,866
与某一个具体的数据相结合

54
00:01:53,966 --> 00:01:54,799
那么然后呢

55
00:01:54,800 --> 00:01:56,166
在这个抽象的数据电表上呢

56
00:01:56,166 --> 00:01:59,399
所有操作都可以施加在各种数据域上

57
00:01:59,400 --> 00:02:00,333
那么这就实现了

58
00:02:00,333 --> 00:02:02,199
这个抽象数据结构的一个扩展

59
00:02:02,900 --> 00:02:05,200
那么如何实现扩展是本章啊

60
00:02:05,200 --> 00:02:06,800
是本节内容的重点和难点

61
00:02:06,800 --> 00:02:08,600
那后面我们会介绍一系列红

62
00:02:08,766 --> 00:02:11,466
来来介绍啊如何实现的这种扩展

63
00:02:14,600 --> 00:02:16,766
那么在这呢我们说一下为什么

64
00:02:16,966 --> 00:02:18,966
在这个双向循环链表结构体中

65
00:02:18,966 --> 00:02:20,266
只有指针域的原因

66
00:02:20,266 --> 00:02:21,199
那么在于

67
00:02:21,866 --> 00:02:24,333
这里的双向循环链表的数据域在

68
00:02:24,700 --> 00:02:25,600
链表结构之外

69
00:02:25,600 --> 00:02:27,100
那这样做的好处是

70
00:02:27,266 --> 00:02:30,266
把共同的双向链表提取出来

71
00:02:30,933 --> 00:02:31,266
之后

72
00:02:31,266 --> 00:02:33,266
我们可以写一个公共的双向链表

73
00:02:33,266 --> 00:02:34,066
处理程序

74
00:02:34,566 --> 00:02:35,366
双向链表

75
00:02:36,133 --> 00:02:36,966
双向循环链表

76
00:02:36,966 --> 00:02:39,099
不再关心数据的具体形式

77
00:02:40,066 --> 00:02:42,299
那么也就是说你看我们这个

78
00:02:43,166 --> 00:02:45,199
我们刚才定义的那个结构体

79
00:02:45,200 --> 00:02:47,100
可以嵌入到任何数据之内

80
00:02:47,100 --> 00:02:48,533
嵌入到任何数据之内

81
00:02:48,566 --> 00:02:49,733
那么对这个

82
00:02:49,866 --> 00:02:52,766
通过对这个抽象链表抽象结构啊

83
00:02:52,766 --> 00:02:54,399
通过对这个抽象结构体的指认

84
00:02:54,400 --> 00:02:55,000
进行操作

85
00:02:55,000 --> 00:02:57,500
我们就可以实现对任意结构体的操作

86
00:02:57,533 --> 00:02:59,066
啊那么你看

87
00:02:59,200 --> 00:03:01,333
这样的话就可以实现一个抽象啊

88
00:03:01,333 --> 00:03:02,133
抽象

89
00:03:02,700 --> 00:03:04,700
或者说我们如果要用C++来说呢

90
00:03:04,700 --> 00:03:05,866
这个类似于什么呢

91
00:03:05,866 --> 00:03:08,133
这个类似于INTERFACE啊INTERFACE

92
00:03:08,333 --> 00:03:09,766
啊不是C++就是那个加瓦

93
00:03:09,766 --> 00:03:10,699
来来举例的话

94
00:03:10,700 --> 00:03:13,133
这就类似于加瓦的INTERFACE啊INTERFACE

95
00:03:15,966 --> 00:03:19,566
那么第一个操作是初始化双向链表

96
00:03:19,700 --> 00:03:20,900
那么初始化双向链表

97
00:03:20,900 --> 00:03:23,000
首先啊我们看这个链表

98
00:03:23,000 --> 00:03:24,600
我们所介绍的双向循环

99
00:03:24,600 --> 00:03:25,600
双向循环链表都是有

100
00:03:25,600 --> 00:03:26,500
投节点的

101
00:03:26,666 --> 00:03:28,066
所以这个投机点的形式

102
00:03:28,066 --> 00:03:29,099
就是包含两个指针

103
00:03:29,100 --> 00:03:30,800
一个是previous一个是NEX

104
00:03:31,166 --> 00:03:32,666
那么我们处置化

105
00:03:32,666 --> 00:03:34,999
就是让previous和NEX都指向自身

106
00:03:35,066 --> 00:03:37,733
那么这样的话就处置化了一个空的

107
00:03:37,933 --> 00:03:38,933
双向循环列表

108
00:03:42,133 --> 00:03:46,466
那么下面这个红呢是lost DL list first

109
00:03:46,600 --> 00:03:48,333
从这个名字上我们就可以知道

110
00:03:48,533 --> 00:03:49,899
是用来获取

111
00:03:49,933 --> 00:03:52,299
当前双向循环联网的第一个节点

112
00:03:52,333 --> 00:03:53,133
那么

113
00:03:54,666 --> 00:03:55,899
这个object是什么呢

114
00:03:55,900 --> 00:03:59,000
这个object就是双向循环链表的头节点

115
00:03:59,000 --> 00:04:00,866
那么我们知道头节点的

116
00:04:00,866 --> 00:04:02,266
PST next的指向

117
00:04:02,266 --> 00:04:03,933
就是这个链表的第一个节点

118
00:04:04,333 --> 00:04:05,133
那么同理

119
00:04:05,133 --> 00:04:07,666
获取双向循环链表的最后一个节点是

120
00:04:07,800 --> 00:04:10,133
啊lost DL list last

121
00:04:10,366 --> 00:04:11,399
那么这个upject

122
00:04:11,400 --> 00:04:13,733
也是双向循环链表的头节点

123
00:04:13,733 --> 00:04:14,566
那么双循环链表

124
00:04:14,566 --> 00:04:15,899
头节点的progress指针

125
00:04:15,900 --> 00:04:17,766
指向的就是这个整个链表的

126
00:04:17,766 --> 00:04:18,699
最后一个节点

127
00:04:21,366 --> 00:04:24,133
那么下一个是lost DL list is and

128
00:04:24,300 --> 00:04:26,533
那么从这个名字你就可以判

129
00:04:26,533 --> 00:04:29,066
你就可以知道这个红主要是用来判断

130
00:04:29,133 --> 00:04:29,933
啊

131
00:04:29,933 --> 00:04:32,099
当前循环链表是否双向循环

132
00:04:32,100 --> 00:04:33,400
链表是否已经结束啊

133
00:04:33,400 --> 00:04:34,333
是否已经结束

134
00:04:34,500 --> 00:04:37,200
那么list是链表的头节点

135
00:04:37,200 --> 00:04:39,500
NODE是当前便利的这个节点

136
00:04:39,566 --> 00:04:40,533
那么如果

137
00:04:40,566 --> 00:04:42,566
便利的这个节点就是头节点的话

138
00:04:42,566 --> 00:04:43,599
那就表示什么呢

139
00:04:43,600 --> 00:04:44,333
如果相等的话

140
00:04:44,333 --> 00:04:46,099
就表示我们已经完成了

141
00:04:46,100 --> 00:04:47,700
整个这个循环链表的电力

142
00:04:47,900 --> 00:04:50,133
所以就相等就返回处完成变例

143
00:04:50,133 --> 00:04:51,499
否则就返回false

144
00:04:52,333 --> 00:04:56,366
那么下一个红lost DL list is on q

145
00:04:56,566 --> 00:04:58,066
那这个红是干嘛呢

146
00:04:58,066 --> 00:04:59,699
是判断no的这个节点

147
00:04:59,700 --> 00:05:02,733
是不是在某一个循环双向循环列表中

148
00:05:03,000 --> 00:05:04,000
那如何判断呢

149
00:05:04,000 --> 00:05:05,333
那我只只需要判断

150
00:05:05,333 --> 00:05:07,533
no的这个节点的previous和

151
00:05:07,533 --> 00:05:08,999
next的指针是不是空

152
00:05:09,300 --> 00:05:12,866
那如果是空的话那就表示它不在啊

153
00:05:12,866 --> 00:05:15,133
因为我们后边在介绍delete的时候

154
00:05:15,133 --> 00:05:16,799
如果我们把一个节点从这个

155
00:05:16,933 --> 00:05:17,933
双向循环列表中删除

156
00:05:17,933 --> 00:05:20,399
我们会把这个图RES和next都指空的

157
00:05:20,500 --> 00:05:21,766
所以如果它不为空的话

158
00:05:21,766 --> 00:05:22,566
那就表示什么呢

159
00:05:22,566 --> 00:05:24,699
就表示这个节点不在啊

160
00:05:24,700 --> 00:05:25,800
双向循环列表中

161
00:05:25,800 --> 00:05:27,000
如果不空的话

162
00:05:27,000 --> 00:05:30,133
就表示它在某一个双向循环列表中

163
00:05:32,933 --> 00:05:33,733
好

164
00:05:33,933 --> 00:05:35,866
那么下一个操作是在

165
00:05:36,466 --> 00:05:38,966
列表的指定位置插入一个节点

166
00:05:38,966 --> 00:05:41,199
那么这个是lost list add

167
00:05:41,566 --> 00:05:43,099
那么这里的list是什么呢

168
00:05:43,100 --> 00:05:45,966
就是带插入的那个双向循环链表

169
00:05:46,000 --> 00:05:47,666
no是代插入的节点

170
00:05:47,866 --> 00:05:49,533
那么比如说我们看这个例子

171
00:05:49,533 --> 00:05:50,666
这个就是什么呢

172
00:05:50,666 --> 00:05:51,399
这个就是list

173
00:05:51,400 --> 00:05:53,366
list指向就是这个节点啊

174
00:05:53,366 --> 00:05:54,733
no就是这个节点

175
00:05:54,733 --> 00:05:55,466
no是这个节点

176
00:05:55,466 --> 00:05:56,699
那我要把这个no的节点

177
00:05:56,700 --> 00:05:58,700
插入到这个list的节点的后面

178
00:05:59,366 --> 00:06:00,599
那么根据四元的知识呢

179
00:06:00,600 --> 00:06:02,400
我们知道这需要什么呢需要

180
00:06:02,733 --> 00:06:02,999
啊

181
00:06:03,000 --> 00:06:05,133
四步操作啊或者数据结构的知识

182
00:06:05,300 --> 00:06:06,300
那第一步是什么呢

183
00:06:06,300 --> 00:06:08,900
第一步把list啊这是list指针

184
00:06:09,266 --> 00:06:11,199
把力死的next啊是这个

185
00:06:11,500 --> 00:06:12,133
付给谁呢

186
00:06:12,133 --> 00:06:13,066
付给NODE的

187
00:06:13,133 --> 00:06:13,999
付给NODE next

188
00:06:14,000 --> 00:06:15,566
所以就形成了这样的一个指针

189
00:06:15,700 --> 00:06:16,700
那第二步是什么呢

190
00:06:16,700 --> 00:06:18,666
第二步是把力死它付给谁呢

191
00:06:18,666 --> 00:06:20,199
付给NODE的previous

192
00:06:20,200 --> 00:06:21,666
那就形成了这样的一个指针

193
00:06:22,133 --> 00:06:22,966
第三步是什么呢

194
00:06:22,966 --> 00:06:24,566
把NODE付给谁呢

195
00:06:24,566 --> 00:06:25,499
付给list

196
00:06:25,500 --> 00:06:26,266
这是list

197
00:06:26,266 --> 00:06:27,933
list的next的

198
00:06:28,200 --> 00:06:28,866
什么

199
00:06:28,866 --> 00:06:32,133
list的list next的什么previous

200
00:06:32,733 --> 00:06:35,166
previous指针啊previous指针

201
00:06:35,700 --> 00:06:37,866
看那就形成了这样的一个点

202
00:06:37,866 --> 00:06:38,799
这样的一个指针

203
00:06:39,466 --> 00:06:40,566
那么最后一步是什么呢

204
00:06:40,566 --> 00:06:41,999
是把note付给谁呢

205
00:06:42,000 --> 00:06:43,133
付给list的net人

206
00:06:43,133 --> 00:06:44,499
就形成了这样的一个指针

207
00:06:44,600 --> 00:06:46,300
那么大家看经过这四步操作呢

208
00:06:46,300 --> 00:06:47,200
我就把这个note

209
00:06:47,200 --> 00:06:49,066
成功的插入到了list之后

210
00:06:49,566 --> 00:06:50,933
那么插入到list之后

211
00:06:54,466 --> 00:06:55,266
好

212
00:06:55,533 --> 00:06:56,733
那么这个红

213
00:06:56,733 --> 00:06:58,699
lost list tell insert

214
00:06:58,700 --> 00:06:59,733
顾名思义就是什么

215
00:06:59,733 --> 00:07:02,366
像链表的尾部插入一个节点

216
00:07:02,700 --> 00:07:03,800
尾不长的一个节点

217
00:07:03,866 --> 00:07:05,099
那么这个例子特是什么呢

218
00:07:05,100 --> 00:07:07,266
这个例子就是列表头头节点啊

219
00:07:07,266 --> 00:07:08,299
列表的头节点

220
00:07:08,333 --> 00:07:09,066
那我们知道

221
00:07:09,066 --> 00:07:11,866
列表的头节点的previous指向的是谁

222
00:07:11,866 --> 00:07:14,266
指向的是列表的尾节点最后一个节点

223
00:07:14,333 --> 00:07:16,933
所以大家看在这儿呢就是通过例子特

224
00:07:17,200 --> 00:07:18,500
last list add

225
00:07:18,566 --> 00:07:20,099
那么第一个参数是什么呢

226
00:07:20,100 --> 00:07:22,733
第一个参数是通过list的previous

227
00:07:22,900 --> 00:07:25,066
previous指针指向列表的伪接点

228
00:07:25,133 --> 00:07:26,466
然后呢把这个伪接点

229
00:07:26,766 --> 00:07:28,999
在这个伪接点后边插入新的note接点

230
00:07:29,500 --> 00:07:31,200
那么它调用的就是刚才说的那个

231
00:07:31,200 --> 00:07:32,000
list add

232
00:07:36,933 --> 00:07:39,666
好那么下边这个是什么呢

233
00:07:39,666 --> 00:07:41,899
就是lost list had insert

234
00:07:41,900 --> 00:07:42,700
那么有了

235
00:07:43,000 --> 00:07:43,966
有了什么呀

236
00:07:44,533 --> 00:07:46,966
那么有了尾场那么就有一个头茬啊

237
00:07:46,966 --> 00:07:48,999
头茬那么头茬是什么意思呢

238
00:07:49,166 --> 00:07:51,533
头茬就是我要在list是什么

239
00:07:51,533 --> 00:07:52,699
list是头节点

240
00:07:52,800 --> 00:07:54,733
那么NODE是代插入的节点

241
00:07:54,733 --> 00:07:55,799
那我要在list

242
00:07:55,800 --> 00:07:57,366
头节点和第一个节点之间

243
00:07:57,366 --> 00:07:58,866
插入这个新的节点NODE

244
00:07:58,900 --> 00:08:00,866
大家看这个是头节点

245
00:08:00,966 --> 00:08:03,166
这个是列表的原来的第一个节点

246
00:08:03,166 --> 00:08:04,399
那同样道理啊

247
00:08:04,500 --> 00:08:06,300
那least就是这个这个

248
00:08:06,300 --> 00:08:08,666
这个这个节点no就是代插入的节点

249
00:08:08,666 --> 00:08:10,999
那么调用least at就实现了

250
00:08:11,000 --> 00:08:12,566
把新的节点插入到

251
00:08:12,766 --> 00:08:13,599
充当了什么呢

252
00:08:13,600 --> 00:08:14,733
抽头插的作用

253
00:08:14,733 --> 00:08:15,266
头插作用

254
00:08:15,266 --> 00:08:17,333
新的节点作为整个列表的第一个节点

255
00:08:17,366 --> 00:08:18,199
完成头插

256
00:08:22,100 --> 00:08:23,533
那么这也体现了一个好处

257
00:08:23,533 --> 00:08:23,899
是什么呢

258
00:08:23,900 --> 00:08:25,700
我们知道我们刚才说了

259
00:08:25,700 --> 00:08:27,100
就是双向循环列表

260
00:08:27,100 --> 00:08:29,000
都是按呃Letos的

261
00:08:29,000 --> 00:08:30,933
双向循环列表都是带有头节点的

262
00:08:30,966 --> 00:08:32,499
正是由于有有了头节点

263
00:08:32,500 --> 00:08:34,533
所以怎么样查入和删除的操作

264
00:08:34,533 --> 00:08:36,066
不需要进行各种意识判断

265
00:08:36,066 --> 00:08:38,299
那都是采用相同的方式进行就可以了

266
00:08:42,966 --> 00:08:43,699
好

267
00:08:43,700 --> 00:08:45,500
那么下面是从

268
00:08:45,766 --> 00:08:47,899
双向循环列表中删除一个节点

269
00:08:47,900 --> 00:08:51,300
叫做lost list delete啊delete

270
00:08:51,366 --> 00:08:52,399
那么这个是什么呢

271
00:08:52,400 --> 00:08:54,800
这个你看这个就是说非常简单

272
00:08:54,966 --> 00:08:55,566
非常简单

273
00:08:55,566 --> 00:08:58,466
就是说把当前的这个节点呢你看

274
00:08:58,600 --> 00:09:00,133
把当前节点的

275
00:09:00,266 --> 00:09:03,666
前驱节点复给当前节点后继的前驱

276
00:09:03,700 --> 00:09:05,400
把当前节点的后继节点

277
00:09:05,400 --> 00:09:07,166
复给当前节点后

278
00:09:07,666 --> 00:09:08,499
前驱的后继

279
00:09:08,500 --> 00:09:09,666
那么实际上就是相当于

280
00:09:09,666 --> 00:09:11,699
把NODE从原来的链表中摘除掉

281
00:09:11,766 --> 00:09:13,666
那你要注意啊在这个地方怎么样呢

282
00:09:13,666 --> 00:09:14,966
当你把一个节点从

283
00:09:15,566 --> 00:09:16,733
啊列表中摘除掉的时候

284
00:09:16,733 --> 00:09:18,566
你要把这个节点的next

285
00:09:18,566 --> 00:09:20,399
和previous都设置为空啊

286
00:09:20,400 --> 00:09:20,900
设置为空

287
00:09:20,900 --> 00:09:21,200
表示

288
00:09:21,200 --> 00:09:23,300
这个节点已经不在任何一个双向列表

289
00:09:23,300 --> 00:09:24,100
中了

290
00:09:25,133 --> 00:09:26,999
那么就是这样的一个形式啊

291
00:09:27,000 --> 00:09:27,900
这样的一个形式

292
00:09:32,500 --> 00:09:34,200
那么另外一个删除是什么意思呢

293
00:09:34,200 --> 00:09:35,966
就是重复刚才的那个操作啊

294
00:09:35,966 --> 00:09:37,099
重复刚才那个操作

295
00:09:37,133 --> 00:09:39,099
但是呢我把这个节点啊

296
00:09:39,100 --> 00:09:40,366
初始化成啊

297
00:09:40,366 --> 00:09:42,599
又初始化成一个投节点的形式啊

298
00:09:42,600 --> 00:09:46,166
所以叫做lost list delete you need啊need

299
00:09:49,366 --> 00:09:53,066
那么这个红lost list ametate是表示判断

300
00:09:53,166 --> 00:09:55,599
当前这个链表是不是空啊

301
00:09:55,600 --> 00:09:56,733
是不是否为空

302
00:09:56,866 --> 00:09:57,666
那就是什么呢

303
00:09:57,666 --> 00:10:00,066
如果啊这个链表的头接点

304
00:10:00,500 --> 00:10:03,200
就是啊就是他的下一个节点

305
00:10:03,266 --> 00:10:04,599
和他的头节点相等

306
00:10:04,766 --> 00:10:06,766
那我们就认为因为我们看这个

307
00:10:06,866 --> 00:10:07,333
还是这个

308
00:10:07,333 --> 00:10:09,533
你看如果他的next和他的

309
00:10:09,800 --> 00:10:11,700
嗯和他的这个本身是相等的

310
00:10:11,700 --> 00:10:13,700
那表示这是一个空表啊

311
00:10:13,700 --> 00:10:14,500
这是个空表

312
00:10:17,700 --> 00:10:18,500
好

313
00:10:18,500 --> 00:10:20,566
那么刚才我们给大家介绍的是什么呢

314
00:10:20,566 --> 00:10:22,933
都是像一个双向循环列表中

315
00:10:22,933 --> 00:10:24,399
插入和删除节点

316
00:10:24,400 --> 00:10:25,733
这样的一个节点操作

317
00:10:26,066 --> 00:10:27,799
那么下面我给大家介绍的是什么呢

318
00:10:27,800 --> 00:10:31,066
就是双向循环列表中对列

319
00:10:31,100 --> 00:10:33,366
就是两个双向循环列表的一个合并

320
00:10:33,366 --> 00:10:34,366
操作啊

321
00:10:34,366 --> 00:10:36,533
两个双向循环列表的一个合并操作

322
00:10:36,600 --> 00:10:38,766
那么这是o的list这是new list

323
00:10:39,100 --> 00:10:40,766
那么这个主要完成的一个操作

324
00:10:40,766 --> 00:10:41,133
是什么呢

325
00:10:41,133 --> 00:10:43,333
就是把old list啊

326
00:10:43,333 --> 00:10:44,299
把这个new list

327
00:10:44,300 --> 00:10:46,766
插入到old list的投机点之后

328
00:10:47,400 --> 00:10:48,866
啊插入到头一点之后

329
00:10:49,166 --> 00:10:50,933
那么他完成这么这么样的一个操作

330
00:10:50,933 --> 00:10:51,966
那我们在这呢

331
00:10:52,166 --> 00:10:54,599
这里用到了四个指针一个是oldest head

332
00:10:54,600 --> 00:10:55,900
一个是oldest tale

333
00:10:56,000 --> 00:10:57,933
newest had和newest tale

334
00:10:57,933 --> 00:10:59,866
那么在这个地方我们啊在这

335
00:11:00,066 --> 00:11:00,933
因为这个比较复杂

336
00:11:00,933 --> 00:11:02,266
所以我们就标记出来了

337
00:11:02,266 --> 00:11:05,066
那这个是指向了oldest tale

338
00:11:05,066 --> 00:11:07,333
这个指向的是oldest head

339
00:11:07,400 --> 00:11:09,066
这个指向的是newest head

340
00:11:09,066 --> 00:11:10,999
这个指向的是newest tale

341
00:11:12,333 --> 00:11:13,499
那么主要是什么呢

342
00:11:13,500 --> 00:11:15,466
主要是经过这样的四个指针啊

343
00:11:15,500 --> 00:11:16,500
四个指针操作

344
00:11:16,666 --> 00:11:17,766
那么下面这张图呢

345
00:11:17,766 --> 00:11:20,566
就演示了这四个指针是如何操作的

346
00:11:20,566 --> 00:11:21,566
那第一步是什么

347
00:11:21,566 --> 00:11:22,666
呢第一步是让

348
00:11:23,300 --> 00:11:24,100
啊

349
00:11:24,100 --> 00:11:25,166
o的利斯的

350
00:11:25,500 --> 00:11:27,366
头指针的next的指指向

351
00:11:27,400 --> 00:11:29,100
啊心的利斯的第一个指针

352
00:11:29,100 --> 00:11:29,933
第一个节点

353
00:11:30,266 --> 00:11:32,366
然后他俩互相指第二步操作

354
00:11:32,500 --> 00:11:35,566
第三步操作呢是完成这样的一个操作

355
00:11:35,666 --> 00:11:36,666
第四步操作呢

356
00:11:36,666 --> 00:11:39,066
是完成了一个这样的一个操作

357
00:11:39,200 --> 00:11:41,300
那么大家看经过四步操作之后

358
00:11:41,300 --> 00:11:42,366
我就把这个

359
00:11:42,533 --> 00:11:43,999
新的new list

360
00:11:44,000 --> 00:11:47,600
插入到了o的list的头节点之后啊

361
00:11:47,700 --> 00:11:48,800
所以这也是头茬

362
00:11:48,933 --> 00:11:52,466
就是像o的利斯头茬一个新的阿利斯

363
00:11:56,700 --> 00:11:57,500
好

364
00:11:57,600 --> 00:11:58,400
那么

365
00:11:58,966 --> 00:11:59,799
大家看啊

366
00:12:00,066 --> 00:12:02,399
下面我们是介绍两个操作啊

367
00:12:02,400 --> 00:12:04,466
就以刚才给大家介绍的

368
00:12:04,500 --> 00:12:06,266
list add list为基础

369
00:12:06,266 --> 00:12:07,399
来介绍两个操作

370
00:12:07,400 --> 00:12:10,700
第一个操作是loss list had insert list

371
00:12:10,700 --> 00:12:11,500
那这是什么意思呢

372
00:12:11,500 --> 00:12:12,300
就是把

373
00:12:12,366 --> 00:12:15,799
new list插入到old list的投机点之后

374
00:12:15,866 --> 00:12:16,699
那么大家看啊

375
00:12:16,700 --> 00:12:19,366
实际上这个list had insert list

376
00:12:19,366 --> 00:12:20,399
实际上就是对

377
00:12:21,166 --> 00:12:23,566
lost least at least的一个封装

378
00:12:23,566 --> 00:12:23,999
因为什么

379
00:12:24,000 --> 00:12:26,366
因为我们刚才在介绍least at least的时候

380
00:12:26,366 --> 00:12:27,699
本身就是把这个

381
00:12:28,066 --> 00:12:31,333
啊new least的头插到old least的之后

382
00:12:31,333 --> 00:12:33,666
所以它形成这样的一个结果

383
00:12:33,666 --> 00:12:34,733
那么大家看

384
00:12:34,933 --> 00:12:36,099
这个是头接点

385
00:12:36,100 --> 00:12:38,000
那这个是新插入到new least

386
00:12:38,000 --> 00:12:39,933
那这个是原来的old least

387
00:12:42,500 --> 00:12:46,400
那么下一个操作是lost list tale insert list

388
00:12:46,466 --> 00:12:47,366
那这是什么意思呢

389
00:12:47,366 --> 00:12:48,499
这个就是把

390
00:12:49,166 --> 00:12:52,899
新节新的链表插入到odelets的末尾啊

391
00:12:52,900 --> 00:12:53,766
odelets末尾

392
00:12:53,800 --> 00:12:55,466
那根据我们啊

393
00:12:55,666 --> 00:12:58,066
节点的操作啊节点维查的经验

394
00:12:58,066 --> 00:12:58,799
那么怎么做呢

395
00:12:58,800 --> 00:13:01,900
就是odelets是表头的previous指向的就是

396
00:13:02,800 --> 00:13:04,666
原来那个旧表啊

397
00:13:04,666 --> 00:13:05,999
原来的这个被插

398
00:13:06,000 --> 00:13:07,266
入的那个表末尾

399
00:13:07,300 --> 00:13:08,066
末尾的节点

400
00:13:08,066 --> 00:13:08,899
那我这样的话呢

401
00:13:08,900 --> 00:13:10,000
我就把这个新的节

402
00:13:10,000 --> 00:13:12,866
新的链表插入到这个旧列表的末尾了

403
00:13:12,866 --> 00:13:14,266
所以大家看它的操作结果

404
00:13:14,266 --> 00:13:15,399
就是这样的一个形式

405
00:13:15,400 --> 00:13:18,133
那这个呢是啊新插入的这个链表

406
00:13:18,133 --> 00:13:19,399
那这个是原来的链表

407
00:13:22,566 --> 00:13:24,999
所以呢到目前为止呢我们就完成了

408
00:13:25,000 --> 00:13:26,300
这个就是

409
00:13:26,666 --> 00:13:28,533
对抽象的啊

410
00:13:28,533 --> 00:13:30,799
双向循环列表的这些一些基本操作

411
00:13:30,800 --> 00:13:31,933
主要分为两类

412
00:13:32,100 --> 00:13:32,966
第一类是什么呢

413
00:13:32,966 --> 00:13:34,199
第一类是

414
00:13:35,000 --> 00:13:36,100
针对节点的操作

415
00:13:36,100 --> 00:13:38,600
第二类是针对列表的操作啊

416
00:13:38,600 --> 00:13:41,266
就是把比如说把一个节点插入和删除

417
00:13:41,400 --> 00:13:43,500
从这个双向循环列表中插入和删除

418
00:13:43,500 --> 00:13:44,166
另外一类呢

419
00:13:44,166 --> 00:13:46,733
就是把一个新的列表插入和

420
00:13:47,166 --> 00:13:50,533
插入啊插入到一个双向循环列列表中

421
00:13:50,933 --> 00:13:52,566
那好现在我们要介绍什么呢

422
00:13:52,566 --> 00:13:54,366
现在我们要介绍的是

423
00:13:54,600 --> 00:13:57,000
我们刚才所介绍的所有的这些啊

424
00:13:57,000 --> 00:13:58,800
关于这个双向循环里边的操作呢

425
00:13:58,800 --> 00:14:00,300
都是抽象的操作

426
00:14:00,300 --> 00:14:01,066
抽象操作

427
00:14:01,066 --> 00:14:02,266
那么在实际应用中

428
00:14:02,266 --> 00:14:04,466
我们要把这个抽象的

429
00:14:04,766 --> 00:14:05,699
双向循环链表

430
00:14:05,700 --> 00:14:06,266
这个结构题

431
00:14:06,266 --> 00:14:08,399
嵌入到某一个具体的数据结构中

432
00:14:09,000 --> 00:14:10,866
啊嵌入到某一个具体的数据结构中

433
00:14:10,933 --> 00:14:13,133
然后呢形成这个具体数据结构中的

434
00:14:13,133 --> 00:14:14,366
一个双向循环列表

435
00:14:15,366 --> 00:14:16,399
那么在这个具体的

436
00:14:16,400 --> 00:14:17,966
数据结构的双向循环列表中

437
00:14:17,966 --> 00:14:19,466
实现便利操作

438
00:14:20,400 --> 00:14:22,200
或者是节点插入操作

439
00:14:22,366 --> 00:14:24,066
或者是节点删除操作

440
00:14:24,400 --> 00:14:26,000
啊我们不会啊

441
00:14:26,000 --> 00:14:27,266
针对抽象的

442
00:14:27,500 --> 00:14:29,533
数据双向循环连板进行各种操作

443
00:14:29,533 --> 00:14:31,933
我们在实际应用中都是针对具体的

444
00:14:32,366 --> 00:14:34,133
具体的这个就是

445
00:14:35,366 --> 00:14:38,066
把抽象的这个双向结构体

446
00:14:38,066 --> 00:14:38,966
双向循环链网结构体

447
00:14:38,966 --> 00:14:40,799
嵌入到某一个具体的数据结构中

448
00:14:40,900 --> 00:14:41,500
那么然后

449
00:14:41,500 --> 00:14:43,133
呢针对这个具体的数据结构

450
00:14:43,133 --> 00:14:44,666
进行插入删除和便利

451
00:14:44,666 --> 00:14:45,466
这样的一个操作

452
00:14:45,466 --> 00:14:46,799
那么这个操作怎么做呢

453
00:14:47,200 --> 00:14:48,400
啊我们现在看一个例子啊

454
00:14:48,400 --> 00:14:49,266
我们看一个例子

455
00:14:49,566 --> 00:14:52,599
首先介绍一个红叫做lost offset off

456
00:14:52,733 --> 00:14:54,133
那么这个表是什么意思呢

457
00:14:54,133 --> 00:14:55,199
这个type是什么呢

458
00:14:55,200 --> 00:14:57,366
就是被嵌入的这个结构体

459
00:14:57,366 --> 00:14:59,133
这个被嵌入的结构体的类型

460
00:14:59,300 --> 00:15:00,566
这个member是什么意思呢

461
00:15:00,566 --> 00:15:02,933
这个member就是双向循环链表

462
00:15:02,933 --> 00:15:04,666
这个结构体的名啊

463
00:15:04,666 --> 00:15:08,066
我们刚才介绍双向循环列表lost link啊

464
00:15:08,066 --> 00:15:10,399
就是lost door list啊

465
00:15:10,400 --> 00:15:12,900
就是这个这个双向循环列表的结构体

466
00:15:12,900 --> 00:15:15,366
这个结构体在这个type结构体中的

467
00:15:15,800 --> 00:15:16,300
成员变量

468
00:15:16,300 --> 00:15:17,300
这个名叫什么

469
00:15:17,300 --> 00:15:18,366
那好我们看一下

470
00:15:18,366 --> 00:15:19,533
那这个

471
00:15:19,600 --> 00:15:21,600
这个红被定义成这样的一个形式

472
00:15:21,600 --> 00:15:22,566
那这是什么意思呢

473
00:15:22,566 --> 00:15:23,999
这个主要的意思就是

474
00:15:24,333 --> 00:15:26,099
啊我要求这个member结构

475
00:15:26,100 --> 00:15:27,400
这个member成员变量

476
00:15:27,400 --> 00:15:29,666
相对于type结构体的偏移量啊

477
00:15:29,666 --> 00:15:30,899
相对type结构体的偏移量

478
00:15:30,900 --> 00:15:33,066
比如说你看这是一个type的结构体

479
00:15:33,066 --> 00:15:34,133
这是一个type结构体

480
00:15:34,133 --> 00:15:35,766
这是member的这个

481
00:15:35,800 --> 00:15:38,300
这是member这个member成员变量成员变量

482
00:15:38,333 --> 00:15:39,999
那么经过这个含

483
00:15:40,000 --> 00:15:41,200
经过这个红的计算

484
00:15:41,200 --> 00:15:42,933
我们就可以求出这个member

485
00:15:43,533 --> 00:15:44,666
相对于这个

486
00:15:46,133 --> 00:15:49,166
结构体开始的位置它的偏移量是多少

487
00:15:49,966 --> 00:15:51,299
计算出来是一个偏移量

488
00:15:51,300 --> 00:15:52,166
那为什么

489
00:15:52,466 --> 00:15:53,766
为什么要这么计算呢

490
00:15:53,800 --> 00:15:55,133
首先我们来解释一下

491
00:15:55,133 --> 00:15:56,199
首先是大家看啊

492
00:15:56,200 --> 00:15:57,333
首先是将0

493
00:15:57,700 --> 00:15:58,866
强制转换为

494
00:15:58,866 --> 00:16:01,366
指向结构体类型type指针的

495
00:16:01,533 --> 00:16:02,499
type指针啊

496
00:16:02,500 --> 00:16:03,566
你看首先把这个0

497
00:16:03,566 --> 00:16:05,166
强制转换成结构体的指针

498
00:16:05,600 --> 00:16:06,166
然后用

499
00:16:06,166 --> 00:16:08,166
这个指针运算来访问这个member的

500
00:16:08,166 --> 00:16:08,966
乘员变量

501
00:16:09,000 --> 00:16:10,600
member乘员变量那大家看

502
00:16:10,600 --> 00:16:11,866
经过这样的一个运算之后

503
00:16:11,866 --> 00:16:12,966
我们就得到了这个

504
00:16:12,966 --> 00:16:14,333
然后我们再加一个地址

505
00:16:14,900 --> 00:16:16,666
我获得这个member成员的地址

506
00:16:16,766 --> 00:16:17,766
那大家看啊

507
00:16:17,900 --> 00:16:19,133
相当于什么啊

508
00:16:19,133 --> 00:16:19,766
相当于什么

509
00:16:19,766 --> 00:16:22,199
我获得这个member成员的地址是相对于

510
00:16:22,300 --> 00:16:23,400
相对于0的地址

511
00:16:23,400 --> 00:16:25,166
那么这个地址实际上就是member

512
00:16:25,166 --> 00:16:26,499
相对于这个strong

513
00:16:26,500 --> 00:16:28,266
机构体开始的这么一个偏移量

514
00:16:28,800 --> 00:16:29,866
所以他在这有一个

515
00:16:29,866 --> 00:16:31,166
这样的一个小技术啊

516
00:16:31,300 --> 00:16:33,466
那么该技术是实现

517
00:16:33,700 --> 00:16:36,800
抽象双向循环列表结构体泛化的基础

518
00:16:36,800 --> 00:16:37,600
即

519
00:16:37,600 --> 00:16:41,500
嵌入其他数据结构形成双向列表

520
00:16:43,900 --> 00:16:45,533
好我们刚才介绍了这个东西之后

521
00:16:45,533 --> 00:16:46,866
我们具体看一个例子

522
00:16:46,933 --> 00:16:49,866
比如说我现在呢有一个task struct啊

523
00:16:49,866 --> 00:16:53,366
loss task task CB这么样一个结构体

524
00:16:53,566 --> 00:16:55,733
那我在这个结构体中嵌入了一个

525
00:16:55,900 --> 00:16:58,000
lost DL list的这样的一个

526
00:16:58,100 --> 00:17:00,100
抽象的双向循环链表

527
00:17:00,133 --> 00:17:01,999
双向循环链表那我的目的是什么

528
00:17:02,000 --> 00:17:04,133
我的目的是用这个双向循环链表

529
00:17:04,333 --> 00:17:06,066
这样的一个结构体构成一个什么

530
00:17:06,066 --> 00:17:08,899
构成一个lost toss CB结构体构成的

531
00:17:09,066 --> 00:17:10,133
由lost TOSS

532
00:17:10,133 --> 00:17:11,166
CB结构体构成的

533
00:17:11,166 --> 00:17:12,533
这么样的一个循环链表

534
00:17:12,533 --> 00:17:13,399
双向循环链表

535
00:17:14,700 --> 00:17:17,166
那首先我们看一下这个是怎么算的啊

536
00:17:17,166 --> 00:17:18,066
这是怎么算的

537
00:17:18,066 --> 00:17:19,333
我现在想求什么呢

538
00:17:19,333 --> 00:17:21,933
我现在想求pandalice的相对于这个

539
00:17:22,966 --> 00:17:24,466
loss task CB

540
00:17:24,466 --> 00:17:26,099
这个结构体手臂指的这个偏移量

541
00:17:26,100 --> 00:17:26,966
也就是这个地方

542
00:17:26,966 --> 00:17:28,733
究竟它的偏移量是多少啊

543
00:17:28,733 --> 00:17:29,566
它的偏移量是多少

544
00:17:29,566 --> 00:17:30,499
那怎么做呢

545
00:17:30,666 --> 00:17:32,466
就是把lost toss CB作为第一

546
00:17:32,466 --> 00:17:35,099
个参数把pat list作为第二个参数

547
00:17:35,100 --> 00:17:36,366
传递给这个红啊

548
00:17:36,366 --> 00:17:37,533
传递给给这个红

549
00:17:37,566 --> 00:17:38,333
那我们看啊

550
00:17:38,333 --> 00:17:38,933
我们看

551
00:17:38,933 --> 00:17:41,133
那这个红刚才我们已经说了它是

552
00:17:41,133 --> 00:17:42,199
它是什么意思呢

553
00:17:42,200 --> 00:17:44,700
它是这个意思就是啊

554
00:17:44,700 --> 00:17:46,700
你看比如说我把

555
00:17:47,366 --> 00:17:50,266
啊我把lost toss的CB这个结构体呢

556
00:17:50,266 --> 00:17:53,199
用一个零指针啊进行强制进行转换

557
00:17:53,366 --> 00:17:55,899
然后呢求它在Panda list它中

558
00:17:56,733 --> 00:17:58,966
帕特利斯这个数据成员啊这个属性

559
00:17:58,966 --> 00:18:00,566
它的偏它的地址是多少

560
00:18:00,566 --> 00:18:03,666
我们知道这个地址就是64假如说是64

561
00:18:03,666 --> 00:18:05,133
那么这个64既是地址

562
00:18:05,133 --> 00:18:07,333
就是相对于这个0地址的地址

563
00:18:07,400 --> 00:18:08,600
又相又相当于什么

564
00:18:08,600 --> 00:18:10,166
又相当于这个偏移量啊

565
00:18:10,166 --> 00:18:11,166
又相对于这个偏量

566
00:18:11,266 --> 00:18:13,099
所以经过这个红计算之后呢

567
00:18:13,100 --> 00:18:15,266
我们知道这个判断例子的相对于这个

568
00:18:15,333 --> 00:18:18,566
past CB这个结构体的首结构体

569
00:18:18,566 --> 00:18:20,799
它的相对偏移量是多少呢就是64

570
00:18:23,166 --> 00:18:25,366
好那么有了这个64怎么用呢

571
00:18:25,366 --> 00:18:26,366
就是这么用啊

572
00:18:26,400 --> 00:18:27,500
那么这个64

573
00:18:28,000 --> 00:18:31,566
我们用loss DL list entry来求什么呢

574
00:18:31,566 --> 00:18:34,533
来求啊来求这个实际的这个

575
00:18:35,466 --> 00:18:38,699
实际在实际中啊某一个双向循环链表

576
00:18:38,766 --> 00:18:39,999
具体的这个

577
00:18:40,533 --> 00:18:41,133
成员啊

578
00:18:41,133 --> 00:18:43,566
具体的这个结构体nod的首地址啊

579
00:18:43,566 --> 00:18:44,499
首地址是什么

580
00:18:44,500 --> 00:18:45,533
那这个是怎么算的

581
00:18:45,533 --> 00:18:48,066
我看这里这个红的包含三个参数

582
00:18:48,066 --> 00:18:48,866
三个参数

583
00:18:49,000 --> 00:18:50,366
那么第一个参数是什么呢

584
00:18:50,366 --> 00:18:53,466
item是乘员变量为member的指针啊

585
00:18:53,466 --> 00:18:54,733
它是一个具体的地址

586
00:18:55,166 --> 00:18:57,366
那么tap呢是结构体类型的名称

587
00:18:57,366 --> 00:18:59,399
member呢是要获取偏移量成员

588
00:18:59,400 --> 00:19:00,666
在结构体中的名字

589
00:19:00,900 --> 00:19:02,166
那我们知道了啊

590
00:19:02,533 --> 00:19:05,199
成员member变量在这一实例中

591
00:19:05,700 --> 00:19:07,000
那么它的内存地址

592
00:19:07,000 --> 00:19:08,533
那么就是这个item表示的

593
00:19:08,533 --> 00:19:09,866
那又知道了member

594
00:19:10,200 --> 00:19:12,266
在type中相对于头部的偏移量

595
00:19:12,266 --> 00:19:14,499
那么也就是通过type还有member啊

596
00:19:14,500 --> 00:19:16,000
还有这个红求出来的

597
00:19:16,000 --> 00:19:16,566
那这样的话

598
00:19:16,566 --> 00:19:18,666
我把这个item减去这个偏移量

599
00:19:18,666 --> 00:19:19,999
那实际上得到的就是什么

600
00:19:20,000 --> 00:19:22,100
就是这个type实例在内存中的地址

601
00:19:22,600 --> 00:19:23,933
太有实力在内存中的地

602
00:19:24,066 --> 00:19:25,666
那我们下面看一个例子啊

603
00:19:25,933 --> 00:19:27,266
看例看一个例子

604
00:19:28,133 --> 00:19:28,933
看一个例子

605
00:19:30,200 --> 00:19:32,533
那么我们仍然拿这个啊

606
00:19:32,533 --> 00:19:34,333
仍然拿这个task CB啊

607
00:19:34,333 --> 00:19:36,599
lost task CB来举例子啊

608
00:19:36,600 --> 00:19:38,333
那么大家想象一下啊

609
00:19:39,100 --> 00:19:41,300
在操作系统中有很多的任务啊

610
00:19:41,300 --> 00:19:43,500
有很多的任务就是很多的进程

611
00:19:43,800 --> 00:19:45,933
现在我们说进程啊有很多的进程

612
00:19:45,933 --> 00:19:47,999
每一个进程都对应着一个lost TOSS

613
00:19:48,000 --> 00:19:49,333
CB这样的一个结构体

614
00:19:49,700 --> 00:19:51,700
那这个结构体那这样的结构体呢

615
00:19:51,700 --> 00:19:52,866
就形成了一个什么呢

616
00:19:52,866 --> 00:19:55,166
由lost Toss的CD构成的

617
00:19:55,166 --> 00:19:57,466
一些NODE构成的一个双向循环链表

618
00:19:57,533 --> 00:19:59,766
双向循环链表那么我们只知道什么呢

619
00:19:59,766 --> 00:20:00,533
我们只知道

620
00:20:00,533 --> 00:20:02,399
这个判的例词的指针的地址

621
00:20:03,266 --> 00:20:05,466
我们要想便利这个lost toss和CB的时候

622
00:20:05,466 --> 00:20:07,866
我们必须得获得每一个lost toss和CB

623
00:20:07,866 --> 00:20:09,133
这个结构体

624
00:20:09,166 --> 00:20:11,099
这个节点的节点的投地址

625
00:20:11,100 --> 00:20:12,866
但是我们并不知道这个节点的首地址

626
00:20:12,866 --> 00:20:15,299
我们只知道这个节点的pandelist的

627
00:20:15,400 --> 00:20:16,900
这个Pandlist的成员的地址

628
00:20:16,900 --> 00:20:19,000
那么这个Pandlist的成员地址是什么呢

629
00:20:19,000 --> 00:20:21,300
就是这个priority q的item

630
00:20:21,300 --> 00:20:22,300
就是这个这个

631
00:20:23,133 --> 00:20:25,933
这这个是大家看这个这个指针是什么

632
00:20:25,933 --> 00:20:29,466
是一个loss DL list的这个指针的地址

633
00:20:29,466 --> 00:20:30,599
那这个实实际上什么

634
00:20:30,600 --> 00:20:31,533
就是某一个

635
00:20:31,766 --> 00:20:34,666
task CB的Panda list的这个地址

636
00:20:34,666 --> 00:20:35,399
Panda list的地址

637
00:20:35,400 --> 00:20:36,766
那好我们知道这个地址

638
00:20:36,866 --> 00:20:38,366
那我们知道这个地址之后呢

639
00:20:38,366 --> 00:20:41,533
我们通过lost task CB和这个Panda list

640
00:20:41,533 --> 00:20:42,399
也就是这个

641
00:20:42,866 --> 00:20:43,799
也就是这个红

642
00:20:43,966 --> 00:20:45,733
这个红那我们就可以知道

643
00:20:46,500 --> 00:20:47,733
它相对于啊

644
00:20:47,733 --> 00:20:50,566
这个panelist的相对于这个task CB的这个

645
00:20:51,000 --> 00:20:51,900
这个偏移量是多少

646
00:20:51,900 --> 00:20:53,166
我们前面知道了这个偏移量

647
00:20:53,166 --> 00:20:56,199
比如说是6464啊 64

648
00:20:56,200 --> 00:20:59,100
那么这样的话我通过这个entry红一减

649
00:20:59,333 --> 00:21:00,933
我知道了这个的实际的地址

650
00:21:00,933 --> 00:21:02,099
我又知道这个偏移量

651
00:21:02,100 --> 00:21:03,400
那我用这个实际的地址

652
00:21:03,400 --> 00:21:04,300
减去这个偏移量

653
00:21:04,300 --> 00:21:05,766
是不是就得到的是这个

654
00:21:05,900 --> 00:21:07,700
low stars和CB的首地址啊

655
00:21:07,866 --> 00:21:08,299
对吧

656
00:21:08,300 --> 00:21:10,300
因为我们知道在c语言编译的时候

657
00:21:10,300 --> 00:21:12,400
这个整个task的

658
00:21:12,666 --> 00:21:14,066
整个这个strap的结构体

659
00:21:14,066 --> 00:21:15,899
所有的数据成员是顺序存储的

660
00:21:15,900 --> 00:21:17,066
那么我用这个偏一

661
00:21:17,066 --> 00:21:19,066
我用这个实际地址减去这个偏一量

662
00:21:19,066 --> 00:21:20,966
所得到的这个地址就是这个

663
00:21:21,300 --> 00:21:21,933
这个top

664
00:21:21,933 --> 00:21:24,733
这个pandelice所在的这个lost task CB

665
00:21:24,733 --> 00:21:26,766
这个这个这个节点的收地址

666
00:21:26,933 --> 00:21:28,599
所以它就是这样的一个情况

667
00:21:28,600 --> 00:21:29,700
那我们看一下这个图

668
00:21:29,700 --> 00:21:30,766
我们看一下这个图

669
00:21:30,866 --> 00:21:31,866
那么假设呢

670
00:21:31,866 --> 00:21:34,766
我们这个啊priority q item

671
00:21:34,766 --> 00:21:36,199
它的地址是1024啊

672
00:21:36,200 --> 00:21:41,166
1024 那么通过这个loss offs offset off

673
00:21:41,200 --> 00:21:42,333
我们就可以求出

674
00:21:42,333 --> 00:21:44,199
刚才我们去求出这个Panda list

675
00:21:44,200 --> 00:21:45,400
它这是Panda list

676
00:21:45,400 --> 00:21:47,600
这panda list相当于首部的地址是多少

677
00:21:47,600 --> 00:21:50,333
是64 那我用这个1024减去64

678
00:21:50,500 --> 00:21:51,866
那得到的这个地址

679
00:21:51,966 --> 00:21:52,766
就是什么呢

680
00:21:52,766 --> 00:21:53,999
就是这个啊

681
00:21:54,000 --> 00:21:57,133
priority q item所在的那个

682
00:21:57,266 --> 00:21:59,466
pass和CB那个节点的首离值

683
00:22:00,000 --> 00:22:00,266
啊

684
00:22:00,266 --> 00:22:00,733
首离值

685
00:22:00,733 --> 00:22:02,599
那这样的话大家看我们是不是就可以

686
00:22:02,600 --> 00:22:05,133
比如说我又有一个新的这个数据结构

687
00:22:05,133 --> 00:22:06,999
那我把这个dualist

688
00:22:07,000 --> 00:22:09,133
这个抽象的节点嵌入到这个新的

689
00:22:09,133 --> 00:22:11,566
结构里我仍然可以通过这个entry红

690
00:22:11,566 --> 00:22:12,599
来获得这个

691
00:22:12,900 --> 00:22:13,900
无论什么样的结构体

692
00:22:13,900 --> 00:22:16,866
我都会获得这个结构体类型节点的

693
00:22:17,066 --> 00:22:18,599
节点的那个地址

694
00:22:19,566 --> 00:22:22,766
那这是一个非常巧妙的这么一个操作

695
00:22:25,766 --> 00:22:26,566
那么

696
00:22:27,200 --> 00:22:28,133
这个操作是什么呢

697
00:22:28,133 --> 00:22:29,966
这个操作是对抽象的

698
00:22:30,100 --> 00:22:31,866
双向循环链表进行便利啊

699
00:22:31,866 --> 00:22:32,366
进行便利

700
00:22:32,366 --> 00:22:33,999
那么大家看这个很简单啊

701
00:22:34,100 --> 00:22:36,366
就是list是投节点啊

702
00:22:36,366 --> 00:22:36,933
投节点

703
00:22:36,933 --> 00:22:38,566
那投节点首先取得第一个节点

704
00:22:38,566 --> 00:22:39,399
复改Atom

705
00:22:39,500 --> 00:22:42,333
然后呢就是说如果没有结束

706
00:22:42,333 --> 00:22:42,799
看到了吧

707
00:22:42,800 --> 00:22:43,933
这个是如果没有结束

708
00:22:43,933 --> 00:22:45,799
就是ATM不等于头节点的时候

709
00:22:45,800 --> 00:22:46,466
那怎么样呢

710
00:22:46,466 --> 00:22:47,899
我就便利下一个节点

711
00:22:50,366 --> 00:22:53,066
那么刚才是抽象的这个

712
00:22:53,200 --> 00:22:54,800
双向循环链表的这个便利

713
00:22:54,800 --> 00:22:55,666
那么这个是什么呢

714
00:22:55,666 --> 00:22:57,199
这个是具体的啊

715
00:22:57,400 --> 00:22:58,966
双向循环链表的便利

716
00:22:58,966 --> 00:23:00,799
你可以这么想象你可以这么想象

717
00:23:00,800 --> 00:23:03,100
就是我现在呢想想要便利谁呢

718
00:23:03,100 --> 00:23:04,300
我现在想要便利

719
00:23:04,300 --> 00:23:05,766
由刚才那个lost TOSS

720
00:23:05,766 --> 00:23:08,399
CB所构成的一个双向循环链表啊

721
00:23:08,400 --> 00:23:09,333
双向循环列表

722
00:23:09,333 --> 00:23:10,733
那在这里头ATM是什么呢

723
00:23:10,733 --> 00:23:13,799
ATM实际上就是他返回的那个

724
00:23:14,066 --> 00:23:15,899
他返回的那个就是

725
00:23:15,966 --> 00:23:18,299
lost TOSS CB的那个指针啊

726
00:23:18,300 --> 00:23:21,200
它返回那个lost指向lost啊

727
00:23:21,200 --> 00:23:23,400
指向lost TOSS和CB的那个

728
00:23:23,400 --> 00:23:25,000
某一个具体节点的指针

729
00:23:25,166 --> 00:23:26,166
那么list是什

730
00:23:26,166 --> 00:23:27,766
么呢list就是

731
00:23:28,133 --> 00:23:29,366
就是刚才的那个

732
00:23:29,366 --> 00:23:32,366
就是做个类比的话就是类似于这个

733
00:23:32,366 --> 00:23:34,699
就是Pro to q的item啊item

734
00:23:35,400 --> 00:23:39,100
那么type和和这个member相当于什么

735
00:23:39,100 --> 00:23:41,133
type就是是lost toss的CD

736
00:23:41,133 --> 00:23:43,266
而member就是Pandlist Pandlist

737
00:23:43,266 --> 00:23:44,399
那好我们看一下

738
00:23:44,533 --> 00:23:48,399
首先呢我通过这个啊我通过这个这个

739
00:23:49,533 --> 00:23:50,266
啊

740
00:23:50,266 --> 00:23:53,533
呃我通过这个entry啊我通过这个entry

741
00:23:53,733 --> 00:23:54,599
刚才我们说了吧

742
00:23:54,600 --> 00:23:56,566
这个例子就相当于是那个priority的

743
00:23:56,566 --> 00:23:59,666
那个就是相当于那个priority q item啊

744
00:23:59,666 --> 00:24:00,466
相当于这个

745
00:24:00,900 --> 00:24:02,166
priority q item

746
00:24:02,700 --> 00:24:05,000
那么大家看我通过这个喊这个红

747
00:24:05,000 --> 00:24:06,466
我们就可以获得什么呢

748
00:24:06,466 --> 00:24:09,999
就是某一个具体的task lost task CB

749
00:24:10,000 --> 00:24:11,700
lost task CB的手地址

750
00:24:11,733 --> 00:24:13,533
那我把这个手地址付给ATM

751
00:24:14,100 --> 00:24:15,900
啊好覆盖item那这个表示什么呢

752
00:24:15,900 --> 00:24:16,766
就表示哎

753
00:24:16,766 --> 00:24:18,799
这个item member不就是那个pandlist吗

754
00:24:18,800 --> 00:24:21,900
pandlist如果这个pandlist不等于啊

755
00:24:21,900 --> 00:24:23,866
就是没有不等于头阶点的话

756
00:24:23,866 --> 00:24:24,799
就表示这个

757
00:24:25,533 --> 00:24:27,766
什么呢Toss CB的循环列表没有便利完

758
00:24:27,766 --> 00:24:28,266
那又怎么样

759
00:24:28,266 --> 00:24:30,899
我就求下一个链表啊

760
00:24:30,900 --> 00:24:32,533
链表的下一个节点看到了吗

761
00:24:32,533 --> 00:24:35,699
我把下一个Toss和CB的指针投掷啊

762
00:24:36,100 --> 00:24:37,900
下一个Toss和CB的note指针

763
00:24:37,900 --> 00:24:38,766
付给这个item

764
00:24:38,966 --> 00:24:40,899
所以这就完成了一个抽象的便利

765
00:24:41,500 --> 00:24:43,466
那么大家想一想啊想一想

766
00:24:43,500 --> 00:24:45,133
那么这个item是什么

767
00:24:45,366 --> 00:24:47,266
就是这个这个type是可以

768
00:24:47,266 --> 00:24:49,566
这个type呢是可以是任何这个

769
00:24:49,766 --> 00:24:52,333
任何的这个任何的数据类型

770
00:24:52,366 --> 00:24:53,466
任何的数据类型

771
00:24:53,600 --> 00:24:55,266
所以这就实现了一个什么呀

772
00:24:55,266 --> 00:24:56,366
你看我我给你举的

773
00:24:56,366 --> 00:24:58,199
例子是task CB是吧

774
00:24:58,200 --> 00:25:00,933
task CB那可以是process CB

775
00:25:01,566 --> 00:25:02,733
是吧啊

776
00:25:02,733 --> 00:25:04,199
还可以是任何其他类型那

777
00:25:04,200 --> 00:25:05,666
所以说这就实现了一个什么

778
00:25:05,666 --> 00:25:07,699
抽象的双向循环列表泛化

779
00:25:10,066 --> 00:25:11,199
那么下边这些弧呢

780
00:25:11,200 --> 00:25:13,566
是关于双向循环链表啊

781
00:25:13,566 --> 00:25:15,266
具体的双向循环链表的

782
00:25:15,266 --> 00:25:16,999
这个一些其他的这些

783
00:25:17,000 --> 00:25:17,800
操作啊

784
00:25:18,266 --> 00:25:20,466
那么我们刚才给你的操作是什么呢

785
00:25:20,466 --> 00:25:21,266
是取得

786
00:25:21,266 --> 00:25:23,699
抽象的循环双向循环链表的投节点

787
00:25:23,766 --> 00:25:24,799
而这个的是什么呢

788
00:25:24,800 --> 00:25:27,600
是取得具体的双向循环链表

789
00:25:27,600 --> 00:25:29,133
针对某一个具体数据结构的

790
00:25:29,133 --> 00:25:30,133
双向循环链表的

791
00:25:30,133 --> 00:25:30,933
这么一个

792
00:25:32,266 --> 00:25:32,599
啊

793
00:25:32,600 --> 00:25:34,800
这么一个投节点的这么一个操作啊

794
00:25:34,800 --> 00:25:35,566
这么一个操作

795
00:25:35,566 --> 00:25:37,966
操作大家看在这个地方呢你看

796
00:25:38,333 --> 00:25:40,066
他实际上是对这个

797
00:25:40,166 --> 00:25:42,499
lost DL历史安锤这么一个

798
00:25:42,500 --> 00:25:44,133
这个这个红的一个封装啊

799
00:25:44,133 --> 00:25:45,866
把这个红封装成一个函数啊

800
00:25:45,866 --> 00:25:47,599
把这个红进行了一次封装啊

801
00:25:47,600 --> 00:25:48,466
进行了一次封装

802
00:25:50,133 --> 00:25:51,099
那么这是什么意思呢

803
00:25:51,100 --> 00:25:53,700
就是取得某一个具体数据类型的

804
00:25:53,800 --> 00:25:55,333
双向循环链板的投机点

805
00:25:59,600 --> 00:26:01,100
那么这个是什么呢

806
00:26:01,100 --> 00:26:02,500
这个是把

807
00:26:02,566 --> 00:26:04,666
这个具体类型的双向循环

808
00:26:04,666 --> 00:26:05,533
列表的投机点

809
00:26:05,533 --> 00:26:07,866
从这个list中删除掉啊

810
00:26:08,066 --> 00:26:09,533
从这个list中删除掉

811
00:26:10,333 --> 00:26:11,399
那么这个就是这个红

812
00:26:11,400 --> 00:26:12,266
那大家看

813
00:26:12,733 --> 00:26:15,499
获得啊获得具体首先是什么

814
00:26:15,500 --> 00:26:17,400
判断这个链表是不是空啊

815
00:26:17,400 --> 00:26:19,766
如果是空的话呢就结束看到了吧

816
00:26:19,866 --> 00:26:20,899
AMPT amp AMPT

817
00:26:20,900 --> 00:26:22,566
如果AMPT就就结束

818
00:26:22,666 --> 00:26:23,766
否则的话呢

819
00:26:23,933 --> 00:26:26,166
就获得这个双向循环链

820
00:26:26,166 --> 00:26:28,266
具体的双向循环链表的第一个节点

821
00:26:28,533 --> 00:26:30,166
第一个节点啊复给t

822
00:26:30,300 --> 00:26:31,500
然后呢把这个节点呢

823
00:26:31,500 --> 00:26:32,800
从这个列表中删除掉

824
00:26:39,600 --> 00:26:40,566
好现在我们看一

825
00:26:40,566 --> 00:26:41,599
下这个红

826
00:26:41,933 --> 00:26:45,466
那么这个红呢是lost listen type

827
00:26:45,566 --> 00:26:47,733
那么它呢主要完成的是

828
00:26:47,900 --> 00:26:49,400
获取双向列表中

829
00:26:49,400 --> 00:26:52,300
指定节点后t节点所在结构体地址

830
00:26:52,766 --> 00:26:53,999
那么我们看一下

831
00:26:54,000 --> 00:26:57,700
首先第一条呢是判断啊这个

832
00:26:58,600 --> 00:27:00,366
链表是否为空啊

833
00:27:00,500 --> 00:27:03,600
是否为空或者说是否已经啊便利结束

834
00:27:03,766 --> 00:27:05,599
那么如果没有的话

835
00:27:05,600 --> 00:27:09,566
那么我就以item的PST next

836
00:27:09,900 --> 00:27:10,600
啊

837
00:27:10,600 --> 00:27:12,000
item是当前节点

838
00:27:12,133 --> 00:27:15,133
PST next是当前节点的后续节点啊作为

839
00:27:15,666 --> 00:27:16,733
作为输入菜

840
00:27:17,266 --> 00:27:20,099
参数来求当前节点后继节点

841
00:27:20,100 --> 00:27:21,600
所在的结构体的

842
00:27:21,800 --> 00:27:22,700
啊受地址

843
00:27:23,133 --> 00:27:25,099
通过这个lost DL list安锤

844
00:27:25,133 --> 00:27:26,266
那么因此呢

845
00:27:26,266 --> 00:27:26,899
这个红

846
00:27:26,900 --> 00:27:29,900
它就是返回当前节点后继节点的那个

847
00:27:30,533 --> 00:27:32,166
所在结构体的地址

848
00:27:33,000 --> 00:27:34,866
以上呢我们就完成了对

849
00:27:35,733 --> 00:27:39,166
light OS中双向循环链表的介绍

